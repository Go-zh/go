<!--{
	"Title": "Go 编程语言规范",
	"Subtitle": "版本：2019 年 12 月 13 日 | 译者：Oling Cat",
	"Path": "/ref/spec"
}-->

<!--{
	"Title": "The Go Programming Language Specification",
	"Subtitle": "Version of Dec 13, 2019",
	"Path": "/ref/spec"
}-->

<div class="english">
<h2 id="Introduction">Introduction</h2>
</div>

<h2 id="引言">引言</h2>

<div class="english">
<p>
This is a reference manual for the Go programming language. For
more information and other documents, see <a href="/">golang.org</a>.
</p>
</div>

<p>
这是一份关于 Go 语言的参考手册。欲获取更多信息与文档，
请访问 <a href="/">go-zh.org</a>。
</p>

<div class="english">
<p>
Go is a general-purpose language designed with systems programming
in mind. It is strongly typed and garbage-collected and has explicit
support for concurrent programming.  Programs are constructed from
<i>packages</i>, whose properties allow efficient management of
dependencies.
</p>
</div>

<p>
Go 是通用型的编程语言，它为系统编程而设计。它是强类型化的语言，具有垃圾回收机制，
并显式支持并发编程。程序由<b>包</b>构造，以此来提供高效的依赖管理功能。
既有实现使用传统的“编译 - 链接”模型，生成可执行的二进制文件。
</p>

<div class="english">
<p>
The grammar is compact and simple to parse, allowing for easy analysis
by automatic tools such as integrated development environments.
</p>
</div>

<p>
其语法紧凑而易解析，便于 IDE 等自动化工具分析。
</p>

<div class="english">
<h2 id="Notation">Notation</h2>
</div>

<h2 id="记法">记法</h2>

<div class="english">
<p>
The syntax is specified using Extended Backus-Naur Form (EBNF):
</p>

<pre class="grammar">
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
</pre>
</div>

<p>
语法使用扩展巴克斯-诺尔范式（EBNF）定义：
</p>

<pre class="grammar">
生成式 = 生成式名 "=" [ 表达式 ] "." .
表达式 = 选择项 { "|" 选择项 } .
选择项 = 条目 { 条目 } .
条目   = 生成式名 | 标记 [ "…" 标记 ] | 分组 | 可选项 | 重复项 .
分组   = "(" 表达式 ")" .
可选项 = "[" 表达式 "]" .
重复项 = "{" 表达式 "}" .
</pre>

<div class="english">
<p>
Productions are expressions constructed from terms and the following
operators, in increasing precedence:
</p>

<pre class="grammar">
|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
</pre>
</div>

<p>
生成式由表达式构造，表达式通过术语及以下操作符构造，自上而下优先级递增（低=&gt;高）：
</p>

<pre class="grammar">
|   选择
()  分组
[]  可选（0 或 1 次）
{}  重复（0 到 n 次）
</pre>

<div class="english">
<p>
Lower-case production names are used to identify lexical tokens.
Non-terminals are in CamelCase. Lexical tokens are enclosed in
double quotes <code>""</code> or back quotes <code>``</code>.
</p>
</div>

<p>
小写生成式名用于标识词法标记。非最终（Non-terminals）词法标记使用驼峰记法（CamelCase）。
位于双引号 <code>""</code> 或反引号 <code>``</code> 内的即为词法标记。
</p>

<div class="english">
<p>
The form <code>a … b</code> represents the set of characters from
<code>a</code> through <code>b</code> as alternatives. The horizontal
ellipsis <code>…</code> is also used elsewhere in the spec to informally denote various
enumerations or code snippets that are not further specified. The character <code>…</code>
(as opposed to the three characters <code>...</code>) is not a token of the Go
language.
</p>
</div>

<p>
形式 <code>a … b</code> 表示把从 <code>a</code> 到 <code>b</code> 的字符集作为选择项。
横向省略号 <code>…</code> 也在本文档中非正式地表示各种列举或简略的代码片断。
单个字符 <code>…</code>（不同于三个字符 <code>...</code>）并非 Go 语言本身的标记。
</p>

<div class="english">
<h2 id="Source_code_representation">Source code representation</h2>
</div>

<h2 id="源码的表示">源码的表示</h2>

<div class="english">
<p>
Source code is Unicode text encoded in
<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. The text is not
canonicalized, so a single accented code point is distinct from the
same character constructed from combining an accent and a letter;
those are treated as two code points.  For simplicity, this document
will use the unqualified term <i>character</i> to refer to a Unicode code point
in the source text.
</p>
</div>

<p>
源码为采用 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 编码的 Unicode 文本，
其文本并未标准化。因此单个带变音符号的码点不同于结合了字母与变音符号的字符结构，
它们应视作两个码点。为简单起见，本文档将使用非正式的术语<b>字符</b>在源文本中指代 Unicode 码点。
</p>

<div class="english">
<p>
Each code point is distinct; for instance, upper and lower case letters
are different characters.
</p>
</div>

<p>
每个码点都是不同的，例如，大写与小写的字母就是不同的字符。
</p>

<div class="english">
<p>
Implementation restriction: For compatibility with other tools, a
compiler may disallow the NUL character (U+0000) in the source text.
</p>
</div>

<p>
实现限制：为兼容其它工具，编译器会阻止字符 NUL（U+0000）出现在源码文本中。
</p>

<div class="english">
<p>
Implementation restriction: For compatibility with other tools, a
compiler may ignore a UTF-8-encoded byte order mark
(U+FEFF) if it is the first Unicode code point in the source text.
A byte order mark may be disallowed anywhere else in the source.
</p>
</div>

<p>
实现限制：为兼容其它工具，若 UTF-8 编码的字节序标记（U+FEFF）为源文本中的第一个
Unicode 码点，那么编译器就会忽略它。字节序标记不允许在源文件中的其它任何地方出现。
</p>

<div class="english">
<h3 id="Characters">Characters</h3>
</div>

<h3 id="字符">字符</h3>

<div class="english">
<p>
The following terms are used to denote specific Unicode character classes:
</p>
</div>

<p>
具体的 Unicode 字符类别由以下术语表示：
</p>

<div class="english">
<pre class="ebnf">
newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as "Letter" */ .
unicode_digit  = /* a Unicode code point classified as "Number, decimal digit" */ .
</pre>
</div>

<pre class="ebnf">
换行符      = /* 即 Unicode 码点 U+000A */ .
Unicode字符 = /* 除换行符以外的任意 Unicode 码点 */ .
Unicode字母 = /* 类型为“字母”的 Unicode 码点 */ .
Unicode数字 = /* 类型为“数值，十进制数字”的 Unicode 码点 */ .
</pre>

<div class="english">
<p>
In <a href="https://www.unicode.org/versions/Unicode8.0.0/">The Unicode Standard 8.0</a>,
Section 4.5 "General Category" defines a set of character categories.
Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo
as Unicode letters, and those in the Number category Nd as Unicode digits.
</p>
</div>

<p>
在<a href="https://www.unicode.org/versions/Unicode8.0.0/">Unicode 标准 8.0</a>，
章节 4.5“一般类别”中定义了字符集类别。其中类别 Lu，Ll，Lt，Lm 及 Lo 被视为
Unicode 字母，类别 Nd 被视为 Unicode 数字。
</p>

<div class="english">
<h3 id="Letters_and_digits">Letters and digits</h3>
</div>

<h3 id="字母和数字">字母和数字</h3>

<div class="english">
<p>
The underscore character <code>_</code> (U+005F) is considered a letter.
</p>
</div>

<p>
下划线字符 <code>_</code>（U+005F）被视为一个字母。
</p>

<div class="english">
<pre class="ebnf">
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
binary_digit  = "0" | "1" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
</pre>
</div>

<pre class="ebnf">
字母         = Unicode字母 | "_" .
十进制数字   = "0" … "9" .
八进制数字   = "0" … "7" .
十六进制数字 = "0" … "9" | "A" … "F" | "a" … "f" .
</pre>

<div class="english">
<h2 id="Lexical_elements">Lexical elements</h2>
</div>

<h2 id="词法元素">词法元素</h2>

<div class="english">
<h3 id="Comments">Comments</h3>
</div>

<h3 id="注释">注释</h3>

<div class="english">
<p>
Comments serve as program documentation. There are two forms:
</p>
</div>

<p>
注释会作为程序文档，它们有两种形式：
</p>

<div class="english">
<ol>
<li>
<i>Line comments</i> start with the character sequence <code>//</code>
and stop at the end of the line.
</li>
<li>
<i>General comments</i> start with the character sequence <code>/*</code>
and stop with the first subsequent character sequence <code>*/</code>.
</li>
</ol>
</div>

<ol>
<li>
<b>行注释</b>以字符序列 <code>//</code> 开始，至行尾结束。
</li>
<li>
<b>块注释</b>以字符序列 <code>/*</code> 开始，至其后的第一处字符序列
<code>*/</code> 结束。
</li>
</ol>

<div class="english">
<p>
A comment cannot start inside a <a href="#Rune_literals">rune</a> or
<a href="#String_literals">string literal</a>, or inside a comment.
A general comment containing no newlines acts like a space.
Any other comment acts like a newline.
</p>
</div>

<p>
注释不能从 <a href="#Rune_literals">符文</a> 或
<a href="#String_literals">字符串字面</a> 中开始，也不能在其它注释中。
不包含换行符的块注释视作一个空格，其余任何注释均视做一个换行符。
</p>


<div class="english">
<h3 id="Tokens">Tokens</h3>
</div>

<h3 id="标记">标记</h3>

<div class="english">
<p>
Tokens form the vocabulary of the Go language.
There are four classes: <i>identifiers</i>, <i>keywords</i>, <i>operators
and punctuation</i>, and <i>literals</i>.  <i>White space</i>, formed from
spaces (U+0020), horizontal tabs (U+0009),
carriage returns (U+000D), and newlines (U+000A),
is ignored except as it separates tokens
that would otherwise combine into a single token. Also, a newline or end of file
may trigger the insertion of a <a href="#Semicolons">semicolon</a>.
While breaking the input into tokens,
the next token is the longest sequence of characters that form a
valid token.
</p>
</div>

<p>
标记构成 Go 语言的词汇。它有四种类型：<b>标识符</b>，<b>关键字</b>，
<b>运算符与标点</b>以及<b>字面</b>。<b>空白符</b>包括空格（U+0020），
横向制表符（U+0009），回车符（U+000D）和换行符（U+000A），除非用它们来分隔会结合成单个的标记，
否则将被忽略。此外，换行符或 EOF（文件结束符）会触发<a href="#分号">分号</a>的插入。
当把输入分解为标记时，可形成有效标记的最长字符序列将作为下一个标记。
</p>


<div class="english">
<h3 id="Semicolons">Semicolons</h3>
</div>

<h3 id="分号">分号</h3>

<div class="english">
<p>
The formal grammar uses semicolons <code>";"</code> as terminators in
a number of productions. Go programs may omit most of these semicolons
using the following two rules:
</p>
</div>

<p>
正式语法使用分号 <code>";"</code> 作为一些生成式的终止符。Go 程序会使用以下两条规则来省略大多数分号：
</p>

<div class="english">
<ol>
<li>
<p>
When the input is broken into tokens, a semicolon is automatically inserted
into the token stream immediately after a line's final token if that token is
</p>
<ul>
	<li>an
	    <a href="#Identifiers">identifier</a>
	</li>

	<li>an
	    <a href="#Integer_literals">integer</a>,
	    <a href="#Floating-point_literals">floating-point</a>,
	    <a href="#Imaginary_literals">imaginary</a>,
	    <a href="#Rune_literals">rune</a>, or
	    <a href="#String_literals">string</a> literal
	</li>

	<li>one of the <a href="#Keywords">keywords</a>
	    <code>break</code>,
	    <code>continue</code>,
	    <code>fallthrough</code>, or
	    <code>return</code>
	</li>

	<li>one of the <a href="#Operators_and_punctuation">operators and punctuation</a>
	    <code>++</code>,
	    <code>--</code>,
	    <code>)</code>,
	    <code>]</code>, or
	    <code>}</code>
	</li>
</ul>
</li>

<li>
To allow complex statements to occupy a single line, a semicolon
may be omitted before a closing <code>")"</code> or <code>"}"</code>.
</li>
</ol>
</div>

<ol>
<li>
<p>
When the input is broken into tokens, a semicolon is automatically inserted
into the token stream immediately after a line's final token if that token is
</p>
<p>
当输入被分解成标记时，若该行的最后一个标记为以下之一，那么分号就会在该标记之后立即自动插入：
</p>
<ul>
	<li>
		<a href="#标识符">标识符</a>
	</li>

	<li>
		<a href="#整数">整数</a>，
		<a href="#浮点数">浮点数</a>，
		<a href="#虚数">虚数</a>，
		<a href="#符文">符文</a>或
		<a href="#字符串">字符串</a>字面
	</li>

	<li><a href="#关键字">关键字</a>
		<code>break</code>，
		<code>continue</code>，
		<code>fallthrough</code> 或
		<code>return</code>
	</li>

	<li><a href="#运算符与标点">运算符与标点</a>
		<code>++</code>，
		<code>--</code>，
		<code>)</code>，
		<code>]</code> 或
		<code>}</code>
	</li>
</ul>
</li>

<li>
为允许复合语句占据单行，闭合的 <code>")"</code> 或 <code>"}"</code> 之前的分号可以省略。
</li>
</ol>

<div class="english">
<p>
To reflect idiomatic use, code examples in this document elide semicolons
using these rules.
</p>
</div>

<p>
为符合习惯用法，本文档中的代码示例将使用这些规则省略分号。
</p>


<div class="english">
<h3 id="Identifiers">Identifiers</h3>
</div>

<h3 id="标识符">标识符</h3>

<div class="english">
<p>
Identifiers name program entities such as variables and types.
An identifier is a sequence of one or more letters and digits.
The first character in an identifier must be a letter.
</p>
<pre class="ebnf">
identifier = letter { letter | unicode_digit } .
</pre>
</div>

<p>
标识符被用来命名程序实体，例如变量和类型。一个标识符由一个或多个字母和数字组成。
标识符的第一个字符必须是字母。
</p>
<pre class="ebnf">
标识符 = 字母 { 字母 | Unicode数字 } .
</pre>
<pre>
a
_x9
ThisVariableIsExported
αβ
</pre>

<div class="english">
<p>
Some identifiers are <a href="#Predeclared_identifiers">predeclared</a>.
</p>
</div>

<p>
有些标识符是<a href="#预声明标识符">预声明</a>的。
</p>


<div class="english">
<h3 id="Keywords">Keywords</h3>
</div>

<h3 id="关键字">关键字</h3>

<div class="english">
<p>
The following keywords are reserved and may not be used as identifiers.
</p>
</div>

<p>
以下为保留关键字，不能用作标识符。
</p>

<pre class="grammar">
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
</pre>

<div class="english">
<h3 id="Operators_and_punctuation">Operators and punctuation</h3>
</div>

<h3 id="运算符与标点">运算符与标点</h3>

<div class="english">
<p>
The following character sequences represent <a href="#Operators">operators</a>
(including <a href="#assign_op">assignment operators</a>) and punctuation:
</p>
</div>

<p>
以下字符序列表示<a href="#运算符">运算符</a>
（包括<a href="#赋值操作">赋值操作符</a>）和与标点：
</p>

<pre class="grammar">
+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )
-    |     -=    |=     ||    &lt;     &lt;=    [    ]
*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }
/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;
%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :
     &amp;^          &amp;^=
</pre>

<div class="english">
<h3 id="Integer_literals">Integer literals</h3>
</div>

<h3 id="整数字面">整数字面</h3>

<div class="english">
<p>
An integer literal is a sequence of digits representing an
<a href="#Constants">integer constant</a>.
An optional prefix sets a non-decimal base: <code>0b</code> or <code>0B</code>
for binary, <code>0</code>, <code>0o</code>, or <code>0O</code> for octal,
and <code>0x</code> or <code>0X</code> for hexadecimal.
A single <code>0</code> is considered a decimal zero.
In hexadecimal literals, letters <code>a</code> through <code>f</code>
and <code>A</code> through <code>F</code> represent values 10 through 15.
</p>

<p>
For readability, an underscore character <code>_</code> may appear after
a base prefix or between successive digits; such underscores do not change
the literal's value.
</p>
<pre class="ebnf">
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .
decimal_lit    = "0" | ( "1" … "9" ) [ [ "_" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .

decimal_digits = decimal_digit { [ "_" ] decimal_digit } .
binary_digits  = binary_digit { [ "_" ] binary_digit } .
octal_digits   = octal_digit { [ "_" ] octal_digit } .
hex_digits     = hex_digit { [ "_" ] hex_digit } .
</pre>
</div>

<p>
整数字面由数字序列组成，代表<a href="#常量">整数常量</a> 。非十进制数由这些前缀定义：
<code>0</code> 为八进制数前缀，<code>0x</code> 或 <code>0X</code> 为十六进制数前缀。
在十六进制数字面中，字母 <code>a-f</code> 或 <code>A-F</code> 表示值 10 到 15。
</p>
<pre class="ebnf">
整数字面       = 十进制数字面 | 八进制数字面 | 十六进制数字面 .
十进制数字面   = ( "1" … "9" ) { 十进制数字 } .
八进制数字面   = "0" { 八进制数字 } .
十六进制数字面 = "0" ( "x" | "X" ) 十六进制数字 { 十六进制数字 } .
</pre>

<pre>
42
4_2
0600
0_600
0o600
0O600       // second character is capital letter 'O'
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727

_42         // an identifier, not an integer literal
42_         // invalid: _ must separate successive digits
4__2        // invalid: only one _ at a time
0_xBadFace  // invalid: _ must separate successive digits
</pre>

<div class="english">
<h3 id="Floating-point_literals">Floating-point literals</h3>
</div>

<h3 id="浮点数字面">浮点数字面</h3>

<div class="english">
<p>
A floating-point literal is a decimal or hexadecimal representation of a
<a href="#Constants">floating-point constant</a>.
</p>
</div>

<p>
浮点数字面由十进制<a href="#常量">浮点常量</a>表示。
</p>

<div class="english">
<p>
A decimal floating-point literal consists of an integer part (decimal digits),
a decimal point, a fractional part (decimal digits), and an exponent part
(<code>e</code> or <code>E</code> followed by an optional sign and decimal digits).
One of the integer part or the fractional part may be elided; one of the decimal point
or the exponent part may be elided.
An exponent value exp scales the mantissa (integer and fractional part) by 10<sup>exp</sup>.
</p>
</div>

<p>
十进制浮点数字面由整数部分（十进制数字）、小数点、小数部分（十进制数字）和指数部分构成。
指数部分由一个 <code>e</code> 或 <code>E</code> 紧跟一个可选的正负号和一些十进制数字构成。
整数部分或小数部分二者之一可以省略；小数点或指数部分二者之一亦可省略。
指数值 exp 按照 10<sup>exp</sup> 缩放尾数（整数和小数部分）。
</p>

<div class="english">
<p>
A hexadecimal floating-point literal consists of a <code>0x</code> or <code>0X</code>
prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits),
and an exponent part (<code>p</code> or <code>P</code> followed by an optional sign and decimal digits).
One of the integer part or the fractional part may be elided; the radix point may be elided as well,
but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.)
An exponent value exp scales the mantissa (integer and fractional part) by 2<sup>exp</sup>.
</p>
</div>

<p>
十六进制浮点数字面由 <code>0x</code> 或 <code>0X</code>前缀、整数部分（十六进制数字）、
小数点、小数部分（十六进制数字）和指数部分构成。指数部分由一个 <code>p</code> 或 <code>P</code>
紧跟一个可选的正负号和一些十进制数字构成。整数部分或小数部分二者之一可以省略；
小数点亦可省略，但指数部分是必须的。（此语法遵循 IEEE 754-2008 §5.12.3。）
指数值 exp 按照 2<sup>exp</sup> 缩放尾数（整数和小数部分）。
</p>

<div class="english">
<p>
For readability, an underscore character <code>_</code> may appear after
a base prefix or between successive digits; such underscores do not change
the literal value.
</p>
</div>

<p>
为可读性起见，基本前缀之后或连续的数字之间可出现一个下划线字符 <code>_</code>，
下划线并不改变其字面值。
</p>

<div class="english">
<pre class="ebnf">
float_lit         = decimal_float_lit | hex_float_lit .

decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                    decimal_digits decimal_exponent |
                    "." decimal_digits [ decimal_exponent ] .
decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .

hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
hex_mantissa      = [ "_" ] hex_digits "." [ hex_digits ] |
                    [ "_" ] hex_digits |
                    "." hex_digits .
hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .
</pre>
</div>

<pre class="ebnf">
浮点数字面         = 十进制浮点数字面 | 十六进制浮点数字面 .

十进制浮点数字面   = 十进制数字 "." [ 十进制数字 ] [ 十进制指数 ] |
                     十进制数字 十进制指数 |
                     "." 十进制数字 [ 十进制指数 ] .
十进制指数         = ( "e" | "E" ) [ "+" | "-" ] 十进制数字 .

十六进制浮点数字面 = "0" ( "x" | "X" ) 十六进制尾数 十六进制指数 .
十六进制尾数       = [ "_" ] 十六进制数字 "." [ 十六进制数字 ] |
                     [ "_" ] 十六进制数字 |
                     "." 十六进制数字 .
十六进制指数       = ( "p" | "P" ) [ "+" | "-" ] 十进制数字 .
</pre>

<div class="english">
<pre>
0.
72.40
072.40       // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // == 15.0
0.15e+0_2    // == 15.0

0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
0x15e-2      // == 0x15e - 2 (integer subtraction)

0x.p1        // invalid: mantissa has no digits
1p-2         // invalid: p exponent requires hexadecimal mantissa
0x1.5e-2     // invalid: hexadecimal mantissa requires p exponent
1_.5         // invalid: _ must separate successive digits
1._5         // invalid: _ must separate successive digits
1.5_e1       // invalid: _ must separate successive digits
1.5e_1       // invalid: _ must separate successive digits
1.5e1_       // invalid: _ must separate successive digits
</pre>
</div>

<pre>
0.
72.40
072.40       // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // == 15.0
0.15e+0_2    // == 15.0

0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
0x15e-2      // == 0x15e - 2（整数相减）

0x.p1        // 无效：尾数没有数字
1p-2         // 无效：p 指数需要十六进制尾数
0x1.5e-2     // 无效：十六进制尾数需要 p 指数
1_.5         // 无效：_ 必须分隔连续的数字
1._5         // 无效：_ 必须分隔连续的数字
1.5_e1       // 无效：_ 必须分隔连续的数字
1.5e_1       // 无效：_ 必须分隔连续的数字
1.5e1_       // 无效：_ 必须分隔连续的数字
</pre>

<div class="english">
<h3 id="Imaginary_literals">Imaginary literals</h3>
</div>

<h3 id="虚数字面">虚数字面</h3>

<div class="english">
<p>
An imaginary literal represents the imaginary part of a
<a href="#Constants">complex constant</a>.
It consists of an <a href="#Integer_literals">integer</a> or
<a href="#Floating-point_literals">floating-point</a> literal
followed by the lower-case letter <code>i</code>.
</p>

<pre class="ebnf">
imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .
</pre>
</div>

<p>
虚数字面由十进制<a href="#常量">复数常量</a>的虚部表示。
它由<a href="#浮点数字面">浮点数字面</a>或十进制整数紧跟小写字母 <code>i</code> 构成。
虚数字面的值即为其整数或浮点数字面乘以虚数单位 <i>i</i>。
</p>

<pre class="ebnf">
虚数字面 = (十进制数 | 浮点数字面) "i" .
</pre>

<div class="english">
<p>
For backward compatibility, an imaginary literal's integer part consisting
entirely of decimal digits (and possibly underscores) is considered a decimal
integer, even if it starts with a leading <code>0</code>.
</p>
</div>

<p>
为了向前兼容，虚数字面中完全由十进制数字（以及下划线）构成的整数部分会被视为十进制整数，
即便带有前导的 <code>0</code> 也是如此。
</p>

<div class="english">
<pre>
0i
0123i         // == 123i for backward-compatibility
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
</pre>
</div>

<pre>
0i
0123i         // == 123i 为了向前兼容
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
</pre>


<div class="english">
<h3 id="Rune_literals">Rune literals</h3>
</div>

<h3 id="符文字面">符文字面</h3>

<div class="english">
<p>
A rune literal represents a <a href="#Constants">rune constant</a>,
an integer value identifying a Unicode code point.
A rune literal is expressed as one or more characters enclosed in single quotes,
as in <code>'x'</code> or <code>'\n'</code>.
Within the quotes, any character may appear except newline and unescaped single
quote. A single quoted character represents the Unicode value
of the character itself,
while multi-character sequences beginning with a backslash encode
values in various formats.
</p>
</div>

<p>
符文字面由一个<a href="#常量">符文常量</a>表示，一个整数值确定一个 Unicode 码点。
一个符文字面由围绕在单引号中的一个或更多字符表示，例如 <code>'x'</code> 或 <code>'\n'</code>。
在引号内，除换行符和未转义的单引号之外，任何字符都可出现。引号内的单个字符表示该字符的 Unicode 值，
而以反斜杠开头的多字符序列则会编码为不同的形式。
</p>

<div class="english">
<p>
The simplest form represents the single character within the quotes;
since Go source text is Unicode characters encoded in UTF-8, multiple
UTF-8-encoded bytes may represent a single integer value.  For
instance, the literal <code>'a'</code> holds a single byte representing
a literal <code>a</code>, Unicode U+0061, value <code>0x61</code>, while
<code>'ä'</code> holds two bytes (<code>0xc3</code> <code>0xa4</code>) representing
a literal <code>a</code>-dieresis, U+00E4, value <code>0xe4</code>.
</p>
</div>

<p>
最简单的形式就是引号内只有一个字符；由于 Go 源码文本是 UTF-8 编码的 Unicode 字符，
多个 UTF-8 编码的字节可能表示单一的整数值。例如，字面 <code>'a'</code> 包含一个字节，
表示一个字面 <code>a</code>，其 Unicode 编码为 U+0061，值为 <code>0x61</code>；而
<code>'ä'</code> 则包含两个字节（<code>0xc3</code> <code>0xa4</code>），表示一个字面
<code>分音符-a</code>，其 Unicode 编码为 U+00E4，值为 <code>0xe4</code>。
</p>

<div class="english">
<p>
Several backslash escapes allow arbitrary values to be encoded as
ASCII text.  There are four ways to represent the integer value
as a numeric constant: <code>\x</code> followed by exactly two hexadecimal
digits; <code>\u</code> followed by exactly four hexadecimal digits;
<code>\U</code> followed by exactly eight hexadecimal digits, and a
plain backslash <code>\</code> followed by exactly three octal digits.
In each case the value of the literal is the value represented by
the digits in the corresponding base.
</p>
</div>

<p>
反斜杠转义允许用 ASCII 文本来编码任意值。将整数值表示为数值常量有四种方法：
<code>\x</code> 紧跟两个十六进制数字；<code>\u</code> 紧跟四个十六进制数字；
<code>\U</code> 紧跟八个十六进制数字；单个 <code>\</code> 紧跟三个八进制数字。
在任何情况下，字面值都是其相应进制的数字表示的值。
</p>

<div class="english">
<p>
Although these representations all result in an integer, they have
different valid ranges.  Octal escapes must represent a value between
0 and 255 inclusive.  Hexadecimal escapes satisfy this condition
by construction. The escapes <code>\u</code> and <code>\U</code>
represent Unicode code points so within them some values are illegal,
in particular those above <code>0x10FFFF</code> and surrogate halves.
</p>
</div>

<p>
尽管这些表示方式都会产生整数，其有效范围却不相同。八进制转义只能表示 0 到 255 之间的值。
十六进制转义则视其结构而定。转义符 <code>\u</code> 和 <code>\U</code> 表示 Unicode 码点，
因此其中的一些值是非法的，特别是那些大于 <code>0x10FFFF</code> 的值和半代理值（surrogate halves）。
</p>

<div class="english">
<p>
After a backslash, certain single-character escapes represent special values:
</p>

<pre class="grammar">
\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within rune literals)
\"   U+0022 double quote  (valid escape only within string literals)
</pre>
</div>

<p>
在反斜杠后，某些单字符转义表示特殊值：
</p>
<pre class="grammar">
\a   U+0007 警报或铃声
\b   U+0008 退格
\f   U+000C 换页
\n   U+000A 换行
\r   U+000D 回车
\t   U+0009 横向制表符
\v   U+000b 纵向制表符
\\   U+005c 反斜杠
\'   U+0027 单引号（仅在符文字面中有效）
\"   U+0022 双引号（仅在字符串字面中有效）
</pre>

<div class="english">
<p>
All other sequences starting with a backslash are illegal inside rune literals.
</p>
<pre class="ebnf">
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
</pre>

<pre>
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // rune literal containing single quote character
'aa'         // illegal: too many characters
'\xa'        // illegal: too few hexadecimal digits
'\0'         // illegal: too few octal digits
'\uDFFF'     // illegal: surrogate half
'\U00110000' // illegal: invalid Unicode code point
</pre>
</div>

<p>
在符文字面中，所有其它以反斜杠开始的序列都是非法的。
</p>
<pre class="ebnf">
符文字面       = "'" ( Unicode值 | 字节值 ) "'" .
Unicode值      = Unicode字符 | 小Unicode值 | 大Unicode值 | 转义字符 .
字节值         = 八进制字节值 | 十六进制字节值 .
八进制字节值   = `\` 八进制数字 八进制数字 八进制数字 .
十六进制字节值 = `\` "x" 十六进制数字 十六进制数字 .
小Unicode值    = `\` "u" 十六进制数字 十六进制数字 十六进制数字 十六进制数字 .
大Unicode值    = `\` "U" 十六进制数字 十六进制数字 十六进制数字 十六进制数字
						 十六进制数字 十六进制数字 十六进制数字 十六进制数字 .
转义字符       = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
</pre>

<pre>
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // 包含单引号字符的符文字面
'aa'         // 非法：字符过多
'\xa'        // 非法：16 进制数字过少
'\0'         // 非法：8 进制数字过少
'\uDFFF'     // 非法：半代理值
'\U00110000' // 非法：无效的 Unicode 码点
</pre>


<div class="english">
<h3 id="String_literals">String literals</h3>
</div>

<h3 id="字符串字面">字符串字面</h3>

<div class="english">
<p>
A string literal represents a <a href="#Constants">string constant</a>
obtained from concatenating a sequence of characters. There are two forms:
raw string literals and interpreted string literals.
</p>
</div>

<p>
字符串字面表示<a href="#常量">字符串常量</a>，可通过连结字符序列获得。
它有两种形式：原始字符串字面和解译字符串字面。
</p>

<div class="english">
<p>
Raw string literals are character sequences between back quotes
<code>``</code>.  Within the quotes, any character is legal except
back quote. The value of a raw string literal is the
string composed of the uninterpreted (implicitly UTF-8-encoded) characters
between the quotes;
in particular, backslashes have no special meaning and the string may
contain newlines.
Carriage return characters ('\r') inside raw string literals
are discarded from the raw string value.
</p>
</div>

<p>
原始字符串字面为反引号 <code>``</code> 之间的字符序列。在该引号内，
除反引号外的任何字符都是合法的。原始字符串字面的值为此引号之间的未解译
（隐式 UTF-8 编码的）字符组成的字符串；换言之，反斜杠没有特殊意义且字符串可包含换行符。
原始字符串字面中的回车符（'\r'）将会从原始字符串的值中丢弃。
</p>

<div class="english">
<p>
Interpreted string literals are character sequences between double
quotes, as in <code>&quot;bar&quot;</code>.
Within the quotes, any character may appear except newline and unescaped double quote.
The text between the quotes forms the
value of the literal, with backslash escapes interpreted as they
are in <a href="#Rune_literals">rune literals</a> (except that <code>\'</code> is illegal and
<code>\"</code> is legal), with the same restrictions.
The three-digit octal (<code>\</code><i>nnn</i>)
and two-digit hexadecimal (<code>\x</code><i>nn</i>) escapes represent individual
<i>bytes</i> of the resulting string; all other escapes represent
the (possibly multi-byte) UTF-8 encoding of individual <i>characters</i>.
Thus inside a string literal <code>\377</code> and <code>\xFF</code> represent
a single byte of value <code>0xFF</code>=255, while <code>ÿ</code>,
<code>\u00FF</code>, <code>\U000000FF</code> and <code>\xc3\xbf</code> represent
the two bytes <code>0xc3</code> <code>0xbf</code> of the UTF-8 encoding of character
U+00FF.
</p>

<pre class="ebnf">
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
</pre>

<pre>
`abc`                // same as "abc"
`\n
\n`                  // same as "\\n\n\\n"
"\n"
"\""                 // same as `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // illegal: surrogate half
"\U00110000"         // illegal: invalid Unicode code point
</pre>
</div>

<p>
解译字符串字面为双引号 <code>&quot;bar&quot;</code> 之间的字符序列。
在该引号内，除换行符和未转义双引号外的任何字符均可出现。引号内的文本形成字面的值，
反斜杠转义序列如同在<a href="#符文字面">符文字面</a>中一样以相同的限制被解译
（其中<code>\'</code>是非法的，而 <code>\"</code> 是合法的）。
三位八进制（<code>\</code><i>nnn</i>）和两位十六进制（<code>\x</code><i>nn</i>）
转义表示字符串值的独立<b>字节</b>；其它转义符表示（可多字节）UTF-8 编码的独立<b>字符</b>。
因此在字符串字面中，<code>\377</code> 和 <code>\xFF</code> 表示值为 <code>0xFF</code>=255 的单个字节，
而<code>ÿ</code>、<code>\u00FF</code>、<code>\U000000FF</code> 和 <code>\xc3\xbf</code>
则表示 UTF-8 编码的字符 U+00FF 的两个字节<code>0xc3</code> <code>0xbf</code>。
</p>

<pre class="ebnf">
字符串字面     = 原始字符串字面 | 解译字符串字面 .
原始字符串字面 = "`" { Unicode字符 | 换行符 } "`" .
解译字符串字面 = `"` { Unicode值 | 字节值 } `"` .
</pre>

<pre>
`abc`                // 等价于 "abc"
`\n
\n`                  // 等价于 "\\n\n\\n"
"\n"
"\""                 // 等价于 `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // 非法：半代理值
"\U00110000"         // 非法：无效的 Unicode 码点
</pre>

<div class="english">
<p>
These examples all represent the same string:
</p>

<pre>
"日本語"                                 // UTF-8 input text
`日本語`                                 // UTF-8 input text as a raw literal
"\u65e5\u672c\u8a9e"                    // the explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // the explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // the explicit UTF-8 bytes
</pre>
</div>

<p>
这些例子都表示相同的字符串：
</p>

<pre>
"日本語"                                // UTF-8 输入的文本
`日本語`                                // UTF-8 输入的原始字面文本
"\u65e5\u672c\u8a9e"                    // 显式的 Unicode 码点
"\U000065e5\U0000672c\U00008a9e"        // 显式的 Unicode 码点
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 显式的 UTF-8 字节
</pre>

<div class="english">
<p>
If the source code represents a character as two code points, such as
a combining form involving an accent and a letter, the result will be
an error if placed in a rune literal (it is not a single code
point), and will appear as two code points if placed in a string
literal.
</p>
</div>

<p>
如果源码将两个码点表示为一个字符，例如包含着重号和字母的结合形式，
那么将它放置在符文字面中就会产生一个错误（它不是单一码点），而放置在字符串字面中则会显示为两个码点。
</p>

<div class="english">
<h2 id="Constants">Constants</h2>
</div>

<h2 id="常量">常量</h2>

<div class="english">
<p>There are <i>boolean constants</i>,
<i>rune constants</i>,
<i>integer constants</i>,
<i>floating-point constants</i>, <i>complex constants</i>,
and <i>string constants</i>. Rune, integer, floating-point,
and complex constants are
collectively called <i>numeric constants</i>.
</p>
</div>

<p>
常量包含<b>布尔常量</b>，<b>符文常量</b>，
<b>整数常量</b>，<b>浮点数常量</b>，
<b>复数常量</b>和<b>字符串常量</b>。
符文，整数，浮点数和复数常量统称为<b>数值常量</b>。
</p>

<div class="english">
<p>
A constant value is represented by a
<a href="#Rune_literals">rune</a>,
<a href="#Integer_literals">integer</a>,
<a href="#Floating-point_literals">floating-point</a>,
<a href="#Imaginary_literals">imaginary</a>,
or
<a href="#String_literals">string</a> literal,
an identifier denoting a constant,
a <a href="#Constant_expressions">constant expression</a>,
a <a href="#Conversions">conversion</a> with a result that is a constant, or
the result value of some built-in functions such as
<code>unsafe.Sizeof</code> applied to any value,
<code>cap</code> or <code>len</code> applied to
<a href="#Length_and_capacity">some expressions</a>,
<code>real</code> and <code>imag</code> applied to a complex constant
and <code>complex</code> applied to numeric constants.
The boolean truth values are represented by the predeclared constants
<code>true</code> and <code>false</code>. The predeclared identifier
<a href="#Iota">iota</a> denotes an integer constant.
</p>
</div>

<p>
常量的值可由
<a href="#符文字面">符文</a>，
<a href="#整数字面">整数</a>，
<a href="#浮点数字面">浮点数</a>，
<a href="#虚数字面">虚数</a> 或
<a href="#字符串字面">字符串</a>字面表示，
一个标识符可代表一个常量，一个<a href="#常量表达式">常量表达式</a>，
一个结果为常量的<a href="#类型转换">类型转换</a>，或一些内建函数的返回值。
例如 <code>unsafe.Sizeof</code> 作用于任何值时产生的值，
<code>cap</code> 或 <code>len</code> 作用于<a href="#长度与容量">一些表达式</a>时产生的值，
<code>real</code> 和 <code>imag</code> 作用于复数常量时产生的值，以及
<code>complex</code> 作用于数值常量所产生的值。
布尔值由预声明的常量 <code>true</code> 和 <code>false</code> 来表示。
预声明标识符 <a href="#Iota">iota</a> 表示一个整数常量。
</p>

<div class="english">
<p>
In general, complex constants are a form of
<a href="#Constant_expressions">constant expression</a>
and are discussed in that section.
</p>
</div>

<p>
通常，复数常量的形式为
<a href="#常量表达式">常量表达式</a>，这一点将在该节中讨论。
</p>

<div class="english">
<p>
Numeric constants represent exact values of arbitrary precision and do not overflow.
Consequently, there are no constants denoting the IEEE-754 negative zero, infinity,
and not-a-number values.
</p>
</div>

<p>
数值常量可表示任意精度的精确值而不会溢出，因此也就没有表示 IEEE-754 负零和无限的常量。
</p>

<div class="english">
<p>
Constants may be <a href="#Types">typed</a> or <i>untyped</i>.
Literal constants, <code>true</code>, <code>false</code>, <code>iota</code>,
and certain <a href="#Constant_expressions">constant expressions</a>
containing only untyped constant operands are untyped.
</p>
</div>

<p>
常量可以是<a href="#类型">类型化</a>的或<b>无类型化</b>的。字面常量，<code>true</code>，<code>false</code>，
<code>iota</code> 和某些只包含无类型化操作数的<a href="#常量表达式">常量表达式</a>是无类型化的。
</p>

<div class="english">
<p>
A constant may be given a type explicitly by a <a href="#Constant_declarations">constant declaration</a>
or <a href="#Conversions">conversion</a>, or implicitly when used in a
<a href="#Variable_declarations">variable declaration</a> or an
<a href="#Assignments">assignment</a> or as an
operand in an <a href="#Expressions">expression</a>.
It is an error if the constant value
cannot be <a href="#Representability">represented</a> as a value of the respective type.
</p>
</div>

<p>
常量可由<a href="#常量声明">常量声明</a>或<a href="#类型转换">类型转换</a>显式地赋予其类型，
也可由<a href="#变量声明">变量声明</a>或<a href="#赋值">赋值</a>以及作为
<a href="#表达式">表达式</a>中的操作数隐式地赋予其类型。若常量的值不能由其类型表示就会产生一个错误。
例如，<code>3.0</code> 可赋予任何整数或浮点数类型的常量，而 <code>2147483648.0</code>
（等价于 <code>1&lt;&lt;31</code>）则只能赋予 <code>float32</code>, <code>float64</code>
或 <code>uint32</code> 类型的常量，而不能赋予 <code>int32</code> 或 <code>string</code>类型的常量。
</p>

<div class="english">
<p>
An untyped constant has a <i>default type</i> which is the type to which the
constant is implicitly converted in contexts where a typed value is required,
for instance, in a <a href="#Short_variable_declarations">short variable declaration</a>
such as <code>i := 0</code> where there is no explicit type.
The default type of an untyped constant is <code>bool</code>, <code>rune</code>,
<code>int</code>, <code>float64</code>, <code>complex128</code> or <code>string</code>
respectively, depending on whether it is a boolean, rune, integer, floating-point,
complex, or string constant.
</p>
</div>

<p>
无类型化的常量有一个<b>默认类型</b>，也就是当上下文中需要类型化常量时通过隐式转换出来的类型，
例如在 <code>i := 0</code> 这种无显示类型的 <a href="#短变量声明">短变量声明</a>中。
无类型化常量的默认类型分别为 <code>bool</code>、<code>rune</code>、<code>int</code>、
<code>float64</code>、<code>complex128</code> 或 <code>string</code>
之一，取决于它是布尔值、符文、整数、浮点数、复数还是字符串常量。
</p>

<div class="english">
<p>
Implementation restriction: Although numeric constants have arbitrary
precision in the language, a compiler may implement them using an
internal representation with limited precision.  That said, every
implementation must:
</p>

<ul>
	<li>Represent integer constants with at least 256 bits.</li>

	<li>Represent floating-point constants, including the parts of
	    a complex constant, with a mantissa of at least 256 bits
	    and a signed binary exponent of at least 16 bits.</li>

	<li>Give an error if unable to represent an integer constant
	    precisely.</li>

	<li>Give an error if unable to represent a floating-point or
	    complex constant due to overflow.</li>

	<li>Round to the nearest representable constant if unable to
	    represent a floating-point or complex constant due to limits
	    on precision.</li>
</ul>

<p>
These requirements apply both to literal constants and to the result
of evaluating <a href="#Constant_expressions">constant
expressions</a>.
</p>
</div>

<p>
实现限制：尽管数值常量在该语言中可拥有任意精度，
但编译器可能使用其有限精度的内部表示来实现它们。即，每个实现必须：
</p>
<ul>
	<li>使用至少 256 位表示整数常量。</li>

	<li>使用至少 256 位表示浮点常量，包括复数常量及尾数部分；
		使用至少 32 位表示指数符号。</li>

	<li>若无法精确表示一个整数常量，则给出一个错误。</li>

	<li>若由于溢出而无法表示一个浮点或复数常量，则给出一个错误。</li>

	<li>若由于精度限制而无法表示一个浮点或复数常量，则舍入为最近似的可表示常量。</li>
</ul>
<p>
这些要求适用于字面常量和<a href="#常量表达式">常量表达式</a>的求值结果。
</p>


<div class="english">
<h2 id="Variables">Variables</h2>
</div>

<h2 id="变量">变量</h2>

<div class="english">
<p>
A variable is a storage location for holding a <i>value</i>.
The set of permissible values is determined by the
variable's <i><a href="#Types">type</a></i>.
</p>
</div>

<p>
变量是用于保存<b>值</b>的存储位置。允许值的集合由变量的<b><a href="#类型">类型</a></b>确定。
</p>

<div class="english">
<p>
A <a href="#Variable_declarations">variable declaration</a>
or, for function parameters and results, the signature
of a <a href="#Function_declarations">function declaration</a>
or <a href="#Function_literals">function literal</a> reserves
storage for a named variable.

Calling the built-in function <a href="#Allocation"><code>new</code></a>
or taking the address of a <a href="#Composite_literals">composite literal</a>
allocates storage for a variable at run time.
Such an anonymous variable is referred to via a (possibly implicit)
<a href="#Address_operators">pointer indirection</a>.
</p>
</div>

<p>
<a href="#变量声明">变量声明</a>以及<a href="#函数声明">函数声明</a>或
<a href="#函数字面">函数字面</a>的签名（用于表示函数的形参和结果）
为已命名变量保留了存储。

调用内建函数 <a href="#分配"><code>new</code></a>或获取<a href="#复合字面">复合字面</a>
的地址会在运行时为变量分配存储。匿名变量通过（可能为隐式的）<a href="#指针操作符">指针重定向</a>来引用。
</p>

<div class="english">
<p>
<i>Structured</i> variables of <a href="#Array_types">array</a>, <a href="#Slice_types">slice</a>,
and <a href="#Struct_types">struct</a> types have elements and fields that may
be <a href="#Address_operators">addressed</a> individually. Each such element
acts like a variable.
</p>
</div>

<p>
<a href="#数组类型">数组</a>、<a href="#切片类型">切片</a>和<a href="#结构体类型">结构体</a>
类型的<b>结构化</b>变量拥有可独立<a href="#地址操作符">寻址</a>的元素和字段。
每个这种元素的行为和用法均与变量相同。
</p>

<div class="english">
<p>
The <i>static type</i> (or just <i>type</i>) of a variable is the
type given in its declaration, the type provided in the
<code>new</code> call or composite literal, or the type of
an element of a structured variable.
Variables of interface type also have a distinct <i>dynamic type</i>,
which is the concrete type of the value assigned to the variable at run time
(unless the value is the predeclared identifier <code>nil</code>,
which has no type).
The dynamic type may vary during execution but values stored in interface
variables are always <a href="#Assignability">assignable</a>
to the static type of the variable.
</p>
</div>

<p>
变量的<b>静态类型</b>（或只说<b>类型</b>）就是它在声明时给定的类型，或者在
<code>new</code> 调用时提供的类型或复合字面，或者结构化变量的元素的类型。
接口类型的变量还有个独特的<b>动态类型</b>，它是在运行时赋予变量的值的具体类型
（除非该值为预声明的标识符 <code>nil</code>，它没有类型）。动态类型在执行过程中可能会改变，
但存储在接口变量中的值总是<a href="#可赋值性">可赋予</a>静态类型的变量的。
</p>

<div class="english">
<pre>
var x interface{}  // x is nil and has static type interface{}
var v *T           // v has value nil, static type *T
x = 42             // x has value 42 and dynamic type int
x = v              // x has value (*T)(nil) and dynamic type *T
</pre>
</div>

<pre>
var x interface{}  // x 为 nil 且拥有静态类型 interface{}
var v *T           // v 拥有值 nil 和静态类型 *T
x = 42             // x 拥有值 42 和动态类型 int
x = v              // x 拥有值 (*T)(nil) 和动态类型 *T
</pre>

<div class="english">
<p>
A variable's value is retrieved by referring to the variable in an
<a href="#Expressions">expression</a>; it is the most recent value
<a href="#Assignments">assigned</a> to the variable.
If a variable has not yet been assigned a value, its value is the
<a href="#The_zero_value">zero value</a> for its type.
</p>
</div>

<p>
A variable's value is retrieved by referring to the variable in an
<a href="#Expressions">expression</a>; it is the most recent value
<a href="#Assignments">assigned</a> to the variable.
变量的值可通过在<a href="#表达式">表达式</a>中引用变量取得。若变量尚未赋值，
其值即为其类型的<a href="#零值">零值</a>。
</p>


<div class="english">
<h2 id="Types">Types</h2>
</div>

<h2 id="类型">类型</h2>

<div class="english">
<p>
A type determines a set of values together with operations and methods specific
to those values. A type may be denoted by a <i>type name</i>, if it has one,
or specified using a <i>type literal</i>, which composes a type from existing types.
</p>

<pre class="ebnf">
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType .
</pre>
</div>

<p>
类型决定值的集合与该类型值特定的操作。已命名类型可通过（或许为<a href="#限定标识符">限定的</a>）
<b>类型名</b>指定；未命名类型可通过<b>类型字面</b>指定，它将根据既有的类型组成新的类型。
</p>

<pre class="ebnf">
类型     = 类型名 | 类型字面 | "(" 类型 ")" .
类型名   = 标识符 | 限定标识符 .
类型字面 = 数组类型 | 结构体类型 | 指针类型 | 函数类型 | 接口类型 |
		   切片类型 | 映射类型 | 信道类型 .
</pre>

<div class="english">
<p>
The language <a href="#Predeclared_identifiers">predeclares</a> certain type names.
Others are introduced with <a href="#Type_declarations">type declarations</a>.
<i>Composite types</i>&mdash;array, struct, pointer, function,
interface, slice, map, and channel types&mdash;may be constructed using
type literals.
</p>
</div>

<p>
布尔值，数值与字符串类型的实例的命名是<a href="#预声明标识符">预声明</a>的。
数组，结构体，指针，函数，接口，切片，映射和信道这些<b>复合类型</b>可由类型字面构造。
</p>

<div class="english">
<p>
Each type <code>T</code> has an <i>underlying type</i>: If <code>T</code>
is one of the predeclared boolean, numeric, or string types, or a type literal,
the corresponding underlying
type is <code>T</code> itself. Otherwise, <code>T</code>'s underlying type
is the underlying type of the type to which <code>T</code> refers in its
<a href="#Type_declarations">type declaration</a>.
</p>
</div>

<p>
每个类型 <code>T</code> 都有一个<b>基本类型</b>：若 <code>T</code>
为预声明的布尔、数值或字符串类型或者类型字面，其相应的基本类型为 <code>T</code>
本身。否则，<code>T</code>的基本类型为其<a href="#类型声明">类型声明</a>中所依据类型的基本类型。
</p>

<pre>
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)
</pre>

<div class="english">
<p>
The underlying type of <code>string</code>, <code>A1</code>, <code>A2</code>, <code>B1</code>,
and <code>B2</code> is <code>string</code>.
The underlying type of <code>[]B1</code>, <code>B3</code>, and <code>B4</code> is <code>[]B1</code>.
</p>
</div>

<p>
以上 <code>string</code>，<code>T1</code> 和 <code>T2</code> 的基本类型为 <code>string</code>。
<code>[]T1</code>，<code>T3</code> 和 <code>T4</code> 的基本类型为 <code>[]T1</code> 。
</p>

<div class="english">
<h3 id="Method_sets">Method sets</h3>
</div>

<h3 id="方法集">方法集</h3>

<div class="english">
<p>
A type may have a <i>method set</i> associated with it.
The method set of an <a href="#Interface_types">interface type</a> is its interface.
The method set of any other type <code>T</code> consists of all
<a href="#Method_declarations">methods</a> declared with receiver type <code>T</code>.
The method set of the corresponding <a href="#Pointer_types">pointer type</a> <code>*T</code>
is the set of all methods declared with receiver <code>*T</code> or <code>T</code>
(that is, it also contains the method set of <code>T</code>).
Further rules apply to structs containing embedded fields, as described
in the section on <a href="#Struct_types">struct types</a>.
Any other type has an empty method set.
In a method set, each method must have a
<a href="#Uniqueness_of_identifiers">unique</a>
non-<a href="#Blank_identifier">blank</a> <a href="#MethodName">method name</a>.
</p>
</div>

<p>
类型可拥有一个与其相关联的<b>方法集</b>。
<a href="#接口类型">接口类型</a>的方法集为其接口。其它任意类型 <code>T</code> 的方法集由所有以接收者类型
<code>T</code> 声明的方法组成。与<a href="#指针类型">指针类型</a> <code>*T</code> 相应的方法集为所有以接收者 <code>*T</code> 或 <code>T</code>
声明的方法的集（就是说，它也包含 <code>T</code> 的方法集）。根据<a href="#结构体类型">结构体类型</a>一节的描述，
更进一步的规则也适用于包含匿名字段的结构体。任何其它类型都有一个空方法集。
在方法集中，每个方法都必须有<a href="#标识符的唯一性">唯一</a>的非<a href="#空白标识符">空白</a><a href="#方法名">方法名</a>。
</p>

<div class="english">
<p>
The method set of a type determines the interfaces that the
type <a href="#Interface_types">implements</a>
and the methods that can be <a href="#Calls">called</a>
using a receiver of that type.
</p>
</div>

<p>
一个类型的方法集决定了它所<a href="#接口类型">实现</a>的接口
以及可使用该类型接收者<a href="#函数与方法的调用">调用</a>的方法。
</p>

<div class="english">
<h3 id="Boolean_types">Boolean types</h3>
</div>

<h3 id="布尔类型">布尔类型</h3>

<div class="english">
<p>
A <i>boolean type</i> represents the set of Boolean truth values
denoted by the predeclared constants <code>true</code>
and <code>false</code>. The predeclared boolean type is <code>bool</code>;
it is a <a href="#Type_definitions">defined type</a>.
</p>
</div>

<p>
<b>布尔类型</b>表示由预声明常量 <code>true</code> 和 <code>false</code> 所代表的布尔值的集。
预声明的布尔类型为 <code>bool</code>。
</p>

<div class="english">
<h3 id="Numeric_types">Numeric types</h3>
</div>

<h3 id="数值类型">数值类型</h3>

<div class="english">
<p>
A <i>numeric type</i> represents sets of integer or floating-point values.
The predeclared architecture-independent numeric types are:
</p>

<pre class="grammar">
uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
</pre>
</div>

<p>
<b>数值类型</b>表示整数值和浮点数值的集。
架构无关的预声明数值类型为：
</p>

<pre class="grammar">
uint8       所有无符号  8 位整数集（0 到 255）
uint16      所有无符号 16 位整数集（0 到 65535）
uint32      所有无符号 32 位整数集（0 到 4294967295）
uint64      所有无符号 64 位整数集（0 到 18446744073709551615）

int8        所有带符号  8 位整数集（-128 到 127）
int16       所有带符号 16 位整数集（-32768 到 32767）
int32       所有带符号 32 位整数集（-2147483648 到 2147483647）
int64       所有带符号 64 位整数集（-9223372036854775808 到 9223372036854775807）

float32     所有 IEEE-754 32 位浮点数集
float64     所有 IEEE-754 64 位浮点数集

complex64   所有带 float32 实部和虚部的复数集
complex128  所有带 float64 实部和虚部的复数集

byte        uint8 的别名
rune        int32 的别名
</pre>

<div class="english">
<p>
The value of an <i>n</i>-bit integer is <i>n</i> bits wide and represented using
<a href="https://en.wikipedia.org/wiki/Two's_complement">two's complement arithmetic</a>.
</p>
</div>

<p>
<i>n</i> 位的整数值是 <i>n</i> 位宽的，它使用
<a href="https://en.wikipedia.org/wiki/Two's_complement">二进制补码运算</a>表示。
</p>

<div class="english">
<p>
There is also a set of predeclared numeric types with implementation-specific sizes:
</p>

<pre class="grammar">
uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
</pre>
</div>

<p>
大小取决于具体实现的预声明数值类型：
</p>

<pre class="grammar">
uint     32 或 64 位
int      大小与 uint 相同
uintptr  大到足以存储指针值无解释位的无符号整数
</pre>

<div class="english">
<p>
To avoid portability issues all numeric types are <a href="#Type_definitions">defined
types</a> and thus distinct except
<code>byte</code>, which is an <a href="#Alias_declarations">alias</a> for <code>uint8</code>, and
<code>rune</code>, which is an alias for <code>int32</code>.
Explicit conversions
are required when different numeric types are mixed in an expression
or assignment. For instance, <code>int32</code> and <code>int</code>
are not the same type even though they may have the same size on a
particular architecture.
</p>
</div>

<p>
为避免可移植性问题，除 <code>byte</code> 为 <code>uint8</code> 的别名以及
<code>rune</code> 为 <code>int32</code> 的别名外，所有数值类型都是不同的。
当不同的数值类型混合在一个表达式或赋值操作中时，必须进行类型转换。
例如，<code>int32</code> 与 <code>int</code> 是不同的类型，
尽管它们在特定架构上可能有相同的大小。
</p>

<div class="english">
<h3 id="String_types">String types</h3>
</div>

<h3 id="字符串类型">字符串类型</h3>

<div class="english">
<p>
A <i>string type</i> represents the set of string values.
A string value is a (possibly empty) sequence of bytes.
The number of bytes is called the length of the string and is never negative.
Strings are immutable: once created,
it is impossible to change the contents of a string.
The predeclared string type is <code>string</code>;
it is a <a href="#Type_definitions">defined type</a>.
</p>
</div>

<p>
<b>字符串类型</b>表示字符串值的集。字符串的值为（可能为空的）字节序列。字符串是不可变的：
一旦被创建，字符串的内容就不能更改。预声明的字符串类型为 <code>string</code>。
</p>

<div class="english">
<p>
The length of a string <code>s</code> can be discovered using
the built-in function <a href="#Length_and_capacity"><code>len</code></a>.
The length is a compile-time constant if the string is a constant.
A string's bytes can be accessed by integer <a href="#Index_expressions">indices</a>
0 through <code>len(s)-1</code>.
It is illegal to take the address of such an element; if
<code>s[i]</code> is the <code>i</code>'th byte of a
string, <code>&amp;s[i]</code> is invalid.
</p>
</div>

<p>
字符串 <code>s</code> 的长度可使用内建函数
<a href="#长度与容量"><code>len</code></a> 获取。若该字符串为常量，则其长度即为编译时常量。
字符串的字节可通过整数（§<a href="#下标">下标</a>）0 至 <code>len(s)-1</code> 访问。
获取这样一个元素的地址是非法的；若 <code>s[i]</code> 为字符串的第 <code>i</code>
个字节，<code>&amp;s[i]</code> 就是无效的。
</p>


<div class="english">
<h3 id="Array_types">Array types</h3>
</div>

<h3 id="数组类型">数组类型</h3>

<div class="english">
<p>
An array is a numbered sequence of elements of a single
type, called the element type.
The number of elements is called the length of the array and is never negative.
</p>

<pre class="ebnf">
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
</pre>
</div>

<p>
数组是单一类型元素的编号序列，该单一类型称为元素类型。元素的数量称为长度且为非负数。
</p>

<pre class="ebnf">
数组类型 = "[" 数组长度 "]" 元素类型 .
数组长度 = 表达式 .
元素类型 = 类型 .
</pre>

<div class="english">
<p>
The length is part of the array's type; it must evaluate to a
non-negative <a href="#Constants">constant</a>
<a href="#Representability">representable</a> by a value
of type <code>int</code>.
The length of array <code>a</code> can be discovered
using the built-in function <a href="#Length_and_capacity"><code>len</code></a>.
The elements can be addressed by integer <a href="#Index_expressions">indices</a>
0 through <code>len(a)-1</code>.
Array types are always one-dimensional but may be composed to form
multi-dimensional types.
</p>

<pre>
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
</pre>
</div>

<p>
长度是数组类型的一部分，其求值结果必须可表示为 <code>int</code> 类型的非负<a href="#常量">常量</a>。
数组 <code>a</code> 的长度可使用内建函数 <a href="#长度与容量"><code>len</code></a>获取，
其元素可通过整数<a href="#下标表达式">下标</a> 0 到 <code>len(a)-1</code> 寻址。
数组类型总是一维的，但可组合构成多维的类型。
</p>

<pre>
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // 等价于[2]([2]([2]float64))
</pre>

<div class="english">
<h3 id="Slice_types">Slice types</h3>
</div>

<h3 id="切片类型">切片类型</h3>

<div class="english">
<p>
A slice is a descriptor for a contiguous segment of an <i>underlying array</i> and
provides access to a numbered sequence of elements from that array.
A slice type denotes the set of all slices of arrays of its element type.
The number of elements is called the length of the slice and is never negative.
The value of an uninitialized slice is <code>nil</code>.
</p>

<pre class="ebnf">
SliceType = "[" "]" ElementType .
</pre>
</div>

<p>
切片是其<b>底层数组</b>上连续一段的描述符，它提供了访问此数组的元素的编号序列。
切片类型表示元素类型为数组的所有切片的集。未初始化切片的值为 <code>nil</code>。
</p>

<pre class="ebnf">
切片类型 = "[" "]" 元素类型 .
</pre>

<div class="english">
<p>
The length of a slice <code>s</code> can be discovered by the built-in function
<a href="#Length_and_capacity"><code>len</code></a>; unlike with arrays it may change during
execution.  The elements can be addressed by integer <a href="#Index_expressions">indices</a>
0 through <code>len(s)-1</code>.  The slice index of a
given element may be less than the index of the same element in the
underlying array.
</p>
</div>

<p>
切片 <code>s</code> 的长度可通过内建函数
<a href="#长度与容量"><code>len</code></a>获取；不同于数组的是，切片可在执行过程中被改变，
其元素可通过整数（§<a href="#下标表达式">下标</a>） 0 到 <code>len(s)-1</code> 寻址。
给定元素的切片下标可能小于它在其底层数组中的下标。
</p>

<div class="english">
<p>
A slice, once initialized, is always associated with an underlying
array that holds its elements.  A slice therefore shares storage
with its array and with other slices of the same array; by contrast,
distinct arrays always represent distinct storage.
</p>
</div>

<p>
切片一旦初始化，就总是伴随着一个包含其元素的底层数组。
因此，切片与其数组及其它本数组的切片共享存储；
与此相反，不同的数组总是表示其不同的存储。
</p>

<div class="english">
<p>
The array underlying a slice may extend past the end of the slice.
The <i>capacity</i> is a measure of that extent: it is the sum of
the length of the slice and the length of the array beyond the slice;
a slice of length up to that capacity can be created by
<a href="#Slice_expressions"><i>slicing</i></a> a new one from the original slice.
The capacity of a slice <code>a</code> can be discovered using the
built-in function <a href="#Length_and_capacity"><code>cap(a)</code></a>.
</p>
</div>

<p>
切片的底层数组可扩展其切片的结尾。<b>容量</b>是该扩展的量度：
它是切片的长度和切片往后数组的长度之和；长度达到其容量的切片可通过从原切片
<a href="#切片表达式"><b>切下</b></a>一个新的来创建。
切片 <code>a</code> 的容量可使用内建函数 <a href="#长度与容量"><code>cap(a)</code></a> 获取。
</p>

<div class="english">
<p>
A new, initialized slice value for a given element type <code>T</code> is
made using the built-in function
<a href="#Making_slices_maps_and_channels"><code>make</code></a>,
which takes a slice type
and parameters specifying the length and optionally the capacity:
</p>
</div>

<p>
给定元素类型 <code>T</code> 的一个新的，已初始化的切片值使用内建函数
<a href="#创建切片、映射与信道"><code>make</code></a>创建，
它需要一个切片类型和指定其长度与可选容量的形参。
</p>

<pre>
make([]T, length)
make([]T, length, capacity)
</pre>

<div class="english">
<p>
A slice created with <code>make</code> always allocates a new, hidden array
to which the returned slice value refers. That is, executing
</p>
</div>

<p>
通过 <code>make</code> 创建的切片总是分配一个新的、隐藏的数组，该数组被返回的切片值所引用。即，执行
</p>

<pre>
make([]T, length, capacity)
</pre>

<div class="english">
<p>
produces the same slice as allocating an array and <a href="#Slice_expressions">slicing</a>
it, so these two expressions are equivalent:
</p>
</div>

<p>
产生切片与分配数组后再<a href="#切片表达式">切下</a>它相同，因此这两个表达式是等价的：
</p>

<pre>
make([]int, 50, 100)
new([100]int)[0:50]
</pre>

<div class="english">
<p>
Like arrays, slices are always one-dimensional but may be composed to construct
higher-dimensional objects.
With arrays of arrays, the inner arrays are, by construction, always the same length;
however with slices of slices (or arrays of slices), the inner lengths may vary dynamically.
Moreover, the inner slices must be initialized individually.
</p>
</div>

<p>
类似于数组，切片总是一维的，但可组合构造更高维的对象。
元素为数组的数组，根据其构造，其内部数组的长度始终相同；
然而元素为切片的切片（或元素为数组的切片），其内部长度会动态地改变。
此外，其内部的切片必须单独进行初始化。
</p>

<div class="english">
<h3 id="Struct_types">Struct types</h3>
</div>

<h3 id="结构体类型">结构体类型</h3>

<div class="english">
<p>
A struct is a sequence of named elements, called fields, each of which has a
name and a type. Field names may be specified explicitly (IdentifierList) or
implicitly (EmbeddedField).
Within a struct, non-<a href="#Blank_identifier">blank</a> field names must
be <a href="#Uniqueness_of_identifiers">unique</a>.
</p>

<pre class="ebnf">
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit .
</pre>

<pre>
// An empty struct.
struct {}

// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
</pre>
</div>

<p>
结构体是已命名的元素序列，被称为字段，其中每一个元素都有一个名字和类型。
字段名可显示地指定（标识符列表）或隐式地指定（匿名字段）。
在结构体中，非<a href="#空白标识符">空白</a>字段名必须是<a href="#标识符的唯一性">唯一</a>的。
</p>

<pre class="ebnf">
结构体类型 = "struct" "{" { 字段声明 ";" } "}" .
字段声明 = (标识符列表 类型 | 匿名字段) [ 标注 ] .
匿名字段 = [ "*" ] 类型名 .
标注     = 字符串字面 .
</pre>

<pre>
// 空结构体
struct {}

// 带 6 个字段的结构体
struct {
	x, y int
	u float32
	_ float32  // 填充
	A *[]int
	F func()
}
</pre>

<div class="english">
<p>
A field declared with a type but no explicit field name is called an <i>embedded field</i>.
An embedded field must be specified as
a type name <code>T</code> or as a pointer to a non-interface type name <code>*T</code>,
and <code>T</code> itself may not be
a pointer type. The unqualified type name acts as the field name.
</p>

<pre>
// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}
</pre>
</div>

<p>
通过有类型而无显式字段名声明的字段为<b>匿名字段</b>，亦称为<b>嵌入式</b>字段或该结构体中此种类型的嵌入。
这种字段类型必须作为一个类型名 <code>T</code> 或一个非接口类型名的指针 <code>*T</code>来实现，
且 <code>T</code> 本身不能为指针类型。未限定类型名的行为类似于字段名。
</p>

<pre>
// 带有类型为 T1、*T2、P.T3 和 *P.T4 的四个匿名字段的结构体
struct {
	T1        // 字段名为 T1
	*T2       // 字段名为 T2
	P.T3      // 字段名为 T3
	*P.T4     // 字段名为 T4
	x, y int  // 字段名为 x 和 y
}
</pre>

<div class="english">
<p>
The following declaration is illegal because field names must be unique
in a struct type:
</p>

<pre>
struct {
	T     // conflicts with embedded field *T and *P.T
	*T    // conflicts with embedded field T and *P.T
	*P.T  // conflicts with embedded field T and *T
}
</pre>
</div>

<p>
以下为非法声明，因为字段名在结构体类型中必须是唯一的：
</p>

<pre>
struct {
	T     // 与匿名字段 *T 及 *P.T 相冲突
	*T    // 与匿名字段 T 及 *P.T 相冲突
	*P.T  // 与匿名字段 T 及 *T 相冲突
}
</pre>

<div class="english">
<p>
A field or <a href="#Method_declarations">method</a> <code>f</code> of an
embedded field in a struct <code>x</code> is called <i>promoted</i> if
<code>x.f</code> is a legal <a href="#Selectors">selector</a> that denotes
that field or method <code>f</code>.
</p>
</div>

<p>
在结构体 <code>x</code> 中，若 <code>x.f</code> 为表示字段或<a href="#方法声明">方法</a>
<code>f</code> 的合法<a href="#选择器">选择器</a>，则匿名字段的字段或方法 <code>f</code>
即为<b>已提升</b>的。
</p>

<div class="english">
<p>
Promoted fields act like ordinary fields
of a struct except that they cannot be used as field names in
<a href="#Composite_literals">composite literals</a> of the struct.
</p>
</div>

<p>
已提升字段除了不能用作该结构体<a href="#复合字面">复合字面</a>中的字段名外，
其行为如同结构体的一般字段。
</p>

<div class="english">
<p>
Given a struct type <code>S</code> and a <a href="#Type_definitions">defined type</a>
<code>T</code>, promoted methods are included in the method set of the struct as follows:
</p>
<ul>
	<li>
	If <code>S</code> contains an embedded field <code>T</code>,
	the <a href="#Method_sets">method sets</a> of <code>S</code>
	and <code>*S</code> both include promoted methods with receiver
	<code>T</code>. The method set of <code>*S</code> also
	includes promoted methods with receiver <code>*T</code>.
	</li>

	<li>
	If <code>S</code> contains an embedded field <code>*T</code>,
	the method sets of <code>S</code> and <code>*S</code> both
	include promoted methods with receiver <code>T</code> or
	<code>*T</code>.
	</li>
</ul>
</div>

<p>
给定结构体类型 <code>S</code> 与名为 <code>T</code> 的类型，包含在结构体方法集中的已提升方法如下：
</p>
<ul>
	<li>
	若 <code>S</code> 包含一个匿名字段 <code>T</code>，则 <code>S</code> 与 <code>*S</code>
	的<a href="#方法集">方法集</a>均包含带接收者 <code>T</code> 的已提升方法。<code>*S</code>
	的方法集也包含带接收者 <code>*T</code> 的已提升方法。
	</li>

	<li>
	若 <code>S</code> 包含匿名字段 <code>*T</code>，则 <code>S</code> 与 <code>*S</code>
	的方法集均包含带接收者 <code>T</code> 或 <code>*T</code> 的已提升方法。
	</li>
</ul>

<div class="english">
<p>
A field declaration may be followed by an optional string literal <i>tag</i>,
which becomes an attribute for all the fields in the corresponding
field declaration. An empty tag string is equivalent to an absent tag.
The tags are made visible through a <a href="/pkg/reflect/#StructTag">reflection interface</a>
and take part in <a href="#Type_identity">type identity</a> for structs
but are otherwise ignored.
</p>

<pre>
struct {
	x, y float64 ""  // an empty tag string is like an absent tag
	name string  "any string is permitted as a tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// A struct corresponding to a TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers;
// they follow the convention outlined by the reflect package.
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
</pre>
</div>

<p>
字段声明可后跟一个可选的字符串字面<b>标注</b>，成为所有相应字段声明中字段的属性。
空标注字符串等价于没有标注。标注可通过 <a href="/pkg/reflect/#StructTag">反射接口</a> 获得，
并成为结构体的<a href="#类型标识">类型标识</a>的一部分，其它情况下会被忽略。

</p>
<pre>
struct {
	x, y float64 ""  // 空标注字符串相当于没有标注
	name string  "任何字符串都允许作为标注"
	_    [4]byte "这不是一个结构体字段"
}

// 一个对应于时间戳协议缓冲的结构体.
// 标注字符串定义了协议缓冲的字段号，它们遵循 reflect 包所用的约定。
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
</pre>

<div class="english">
<h3 id="Pointer_types">Pointer types</h3>
</div>

<h3 id="指针类型">指针类型</h3>

<div class="english">
<p>
A pointer type denotes the set of all pointers to <a href="#Variables">variables</a> of a given
type, called the <i>base type</i> of the pointer.
The value of an uninitialized pointer is <code>nil</code>.
</p>

<pre class="ebnf">
PointerType = "*" BaseType .
BaseType    = Type .
</pre>
</div>

<p>
指针类型表示一个所有给定类型<a href="#变量">变量</a>的指针的集，称为指针的<b>基础类型</b>。
未初始化的指针的值为 <code>nil</code>。
</p>

<pre class="ebnf">
指针类型 = "*" 基础类型 .
基础类型 = 类型 .
</pre>

<pre>
*Point
*[4]int
</pre>

<div class="english">
<h3 id="Function_types">Function types</h3>
</div>

<h3 id="函数类型">函数类型</h3>

<div class="english">
<p>
A function type denotes the set of all functions with the same parameter
and result types. The value of an uninitialized variable of function type
is <code>nil</code>.
</p>

<pre class="ebnf">
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
</pre>
</div>

<p>
函数类型表示所有带相同形参和返回类型的集。未初始化的函数类型变量的的值为 <code>nil</code>。
</p>

<pre class="ebnf">
函数类型 = "func" 签名 .
签名     = 形参 [ 结果 ] .
结果     = 形参 | 类型 .
形参     = "(" [ 形参列表 [ "," ] ] ")" .
形参列表 = 形参声明 { "," 形参声明 } .
形参声明 = [ 标识符列表 ] [ "..." ] 类型 .
</pre>

<div class="english">
<p>
Within a list of parameters or results, the names (IdentifierList)
must either all be present or all be absent. If present, each name
stands for one item (parameter or result) of the specified type and
all non-<a href="#Blank_identifier">blank</a> names in the signature
must be <a href="#Uniqueness_of_identifiers">unique</a>.
If absent, each type stands for one item of that type.
Parameter and result
lists are always parenthesized except that if there is exactly
one unnamed result it may be written as an unparenthesized type.
</p>
</div>

<p>
在形参或结果的列表中，其名称（标识符列表）必须都存在或都不存在。
若存在，则每个名称代表一个指定类型的项（形参或结果），所有在签名中的非
<a href="#空白标识符">空白</a>名称必须是<a href="#标识符的唯一性">唯一</a>的。
若不存在，则每个类型代表一个此类型的项。若恰好有一个未命名的值，它可能写作一个不加括号的类型，
除此之外，形参和结果的列表总是在括号中。
</p>

<div class="english">
<p>
The final incoming parameter in a function signature may have
a type prefixed with <code>...</code>.
A function with such a parameter is called <i>variadic</i> and
may be invoked with zero or more arguments for that parameter.
</p>
</div>

<p>
函数签名中加入的最后一个形参可能有一个带 <code>...</code> 前缀的类型。
带这样形参的函数被称为<b>变参函数</b>，它可接受零个或多个实参。
</p>

<pre>
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
</pre>


<div class="english">
<h3 id="Interface_types">Interface types</h3>
</div>

<h3 id="接口类型">接口类型</h3>

<div class="english">
<p>
An interface type specifies a <a href="#Method_sets">method set</a> called its <i>interface</i>.
A variable of interface type can store a value of any type with a method set
that is any superset of the interface. Such a type is said to
<i>implement the interface</i>.
The value of an uninitialized variable of interface type is <code>nil</code>.
</p>

<pre class="ebnf">
InterfaceType      = "interface" "{" { ( MethodSpec | InterfaceTypeName ) ";" } "}" .
MethodSpec         = MethodName Signature .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
</pre>
</div>

<p>
接口类型指定一个称为<b>接口</b>的 <a href="#方法集">方法集</a>。
接口类型变量可存储任何带方法集类型的值，该方法集为此接口的超集。
这种类型表示<b>实现此接口</b>。未初始化的接口类型变量的值为 <code>nil</code>。
</p>

<pre class="ebnf">
接口类型   = "interface" "{" { 方法实现 ";" } "}" .
方法实现   = 方法名 签名 | 接口类型名 .
方法名     = 标识符 .
接口类型名 = 类型名 .
</pre>

<div class="english">
<p>
An interface type may specify methods <i>explicitly</i> through method specifications,
or it may <i>embed</i> methods of other interfaces through interface type names.
</p>

<pre>
// A simple File interface.
interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
</pre>

<p>
The name of each explicitly specified method must be <a href="#Uniqueness_of_identifiers">unique</a>
and not <a href="#Blank_identifier">blank</a>.
</p>

<pre>
interface {
	String() string
	String() string  // illegal: String not unique
	_(x int)         // illegal: method must have non-blank name
}
</pre>
</div>

<p>
对于所有的方法集，在一个接口类型中，每个方法必须有<a href="#标识符的唯一性">唯一的非
</a><a href="#空白标识符">空白</a>名字。
</p>

<pre>
// 一个简单的 File 接口
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
</pre>

<div class="english">
<p>
More than one type may implement an interface.
For instance, if two types <code>S1</code> and <code>S2</code>
have the method set
</p>
</div>

<p>
不止一个类型可实现同一接口。例如，若两个类型 <code>S1</code> 和 <code>S2</code> 拥有方法集
</p>

<pre>
func (p T) Read(p []byte) (n int, err error)
func (p T) Write(p []byte) (n int, err error)
func (p T) Close() error
</pre>

<div class="english">
<p>
(where <code>T</code> stands for either <code>S1</code> or <code>S2</code>)
then the <code>File</code> interface is implemented by both <code>S1</code> and
<code>S2</code>, regardless of what other methods
<code>S1</code> and <code>S2</code> may have or share.
</p>
</div>

<p>
（其中 <code>T</code> 代表 <code>S1</code> 或 <code>S2</code>）
那么 <code>File</code> 接口都将被 <code>S1</code> 和 <code>S2</code>所实现，
不论如何，方法 <code>S1</code> 和 <code>S2</code> 都会拥有或共享它。
</p>

<div class="english">
<p>
A type implements any interface comprising any subset of its methods
and may therefore implement several distinct interfaces. For
instance, all types implement the <i>empty interface</i>:
</p>
</div>

<p>
类型可实现任何接口，包括任何其方法的子集，因此可能实现几个不同的接口。
例如，所有类型都实现了<b>空接口</b>：
</p>

<pre>
interface{}
</pre>

<div class="english">
<p>
Similarly, consider this interface specification,
which appears within a <a href="#Type_declarations">type declaration</a>
to define an interface called <code>Locker</code>:
</p>
</div>

<p>
同样，考虑此接口的实现，它出现在<a href="#类型声明">类型声明</a>
中以定义一个名为 <code>Locker</code> 的接口：
</p>

<pre>
type Locker interface {
	Lock()
	Unlock()
}
</pre>

<div class="english">
<p>
If <code>S1</code> and <code>S2</code> also implement
</p>
</div>

<p>
若 <code>S1</code> 和 <code>S2</code> 也实现
</p>

<pre>
func (p T) Lock() { … }
func (p T) Unlock() { … }
</pre>

<div class="english">
<p>
they implement the <code>Locker</code> interface as well
as the <code>File</code> interface.
</p>
</div>

<p>
它们不仅会实现 <code>Locker</code> 还会实现 <code>File</code> 接口
</p>

<div class="english">
<p>
An interface <code>T</code> may use a (possibly qualified) interface type
name <code>E</code> in place of a method specification. This is called
<i>embedding</i> interface <code>E</code> in <code>T</code>.
The <a href="#Method_sets">method set</a> of <code>T</code> is the <i>union</i>
of the method sets of <code>T</code>’s explicitly declared methods and of
<code>T</code>’s embedded interfaces.
</p>

<pre>
type Reader interface {
	Read(p []byte) (n int, err error)
	Close() error
}

type Writer interface {
	Write(p []byte) (n int, err error)
	Close() error
}

// ReadWriter's methods are Read, Write, and Close.
type ReadWriter interface {
	Reader  // includes methods of Reader in ReadWriter's method set
	Writer  // includes methods of Writer in ReadWriter's method set
}
</pre>

<p>
A <i>union</i> of method sets contains the (exported and non-exported)
methods of each method set exactly once, and methods with the
<a href="#Uniqueness_of_identifiers">same</a> names must
have <a href="#Type_identity">identical</a> signatures.
</p>

<pre>
type ReadCloser interface {
	Reader   // includes methods of Reader in ReadCloser's method set
	Close()  // illegal: signatures of Reader.Close and Close are different
}
</pre>
</div>

<p>
一个接口 <code>T</code> 可通过包含一个（可能被限制的）名为 <code>E</code>
的接口类型来代替方法的指定。这称为在 <code>T</code> 中<b>嵌入</b>接口
<code>E</code>，它会将 <code>E</code> 中所有（已导出和未导出的）方法添加到接口
<code>T</code> 中。
</p>

<pre>
type ReadWriter interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
}

type File interface {
	ReadWriter  // 等价于添加了 ReadWriter 的方法
	Locker      // 等价于添加了 Locker 的方法
	Close()
}

type LockedFile interface {
	Locker
	File        // 非法：Lock、Unlock 不唯一
	Lock()      // 非法：Lock 不唯一
}
</pre>

<div class="english">
<p>
An interface type <code>T</code> may not embed itself
or any interface type that embeds <code>T</code>, recursively.
</p>

<pre>
// illegal: Bad cannot embed itself
type Bad interface {
	Bad
}

// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
</pre>
</div>

<p>
接口类型 <code>T</code> 不能嵌入其自身或任何递归地嵌入 <code>T</code> 的接口类型。
</p>

<pre>
// 非法：Bad 不能嵌入其自身
type Bad interface {
	Bad
}

// 非法：Bad1 不能通过 Bad2 嵌入其自身
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
</pre>

<div class="english">
<h3 id="Map_types">Map types</h3>
</div>

<h3 id="映射类型">映射类型</h3>

<div class="english">
<p>
A map is an unordered group of elements of one type, called the
element type, indexed by a set of unique <i>keys</i> of another type,
called the key type.
The value of an uninitialized map is <code>nil</code>.
</p>

<pre class="ebnf">
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
</pre>
</div>

<p>
映射是一个同种类型元素的无序组，该类型称为元素类型；
映射通过另一类型唯一的<b>键</b>集索引，该类型称为键类型。
未初始化的映射值为 <code>nil</code>。
</p>

<pre class="ebnf">
映射类型    = "map" "[" 键类型 "]" 元素类型 .
键类型      = 类型 .
</pre>

<div class="english">
<p>
The <a href="#Comparison_operators">comparison operators</a>
<code>==</code> and <code>!=</code> must be fully defined
for operands of the key type; thus the key type must not be a function, map, or
slice.
If the key type is an interface type, these
comparison operators must be defined for the dynamic key values;
failure will cause a <a href="#Run_time_panics">run-time panic</a>.

</p>
</div>

<p>
<a href="#比较操作符">比较操作符</a> <code>==</code> 和 <code>!=</code>
必须由键类型的操作数完全定义；因此键类型不能是函数，映射或切片。
若该键类型为接口类型，这些比较运算符必须由动态键值定义；
失败将导致一个 <a href="#运行时恐慌">运行时恐慌</a>.
</p>

<pre>
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
</pre>

<div class="english">
<p>
The number of map elements is called its length.
For a map <code>m</code>, it can be discovered using the
built-in function <a href="#Length_and_capacity"><code>len</code></a>
and may change during execution. Elements may be added during execution
using <a href="#Assignments">assignments</a> and retrieved with
<a href="#Index_expressions">index expressions</a>; they may be removed with the
<a href="#Deletion_of_map_elements"><code>delete</code></a> built-in function.
</p>
</div>

<p>
元素的数量称为长度。
对于映射 <code>m</code>，其长度可使用内建函数 <a href="#长度与容量"><code>len</code></a>
获取并可在执行时更改。元素可在执行时使用<a href="#赋值">赋值</a>来添加并通过
<a href="#下标表达式">下标表达式</a> 来检索；它们也可通过内建函数
<a href="#映射元素的删除"><code>delete</code></a> 删除。
</p>

<div class="english">
<p>
A new, empty map value is made using the built-in
function <a href="#Making_slices_maps_and_channels"><code>make</code></a>,
which takes the map type and an optional capacity hint as arguments:
</p>
</div>

<p>
一个新的，空的映射值使用内建函数 <a href="#创建切片、映射与信道"><code>make</code></a> 创建，
它使该映射类型和可选容量作为实参提示：
</p>

<pre>
make(map[string]int)
make(map[string]int, 100)
</pre>

<div class="english">
<p>
The initial capacity does not bound its size:
maps grow to accommodate the number of items
stored in them, with the exception of <code>nil</code> maps.
A <code>nil</code> map is equivalent to an empty map except that no elements
may be added.
</p>
</div>

<p>
初始容量不能限定它的大小：映射通过增长来适应存储在其中的项数，除了 <code>nil</code> 映射以外。
一个 <code>nil</code> 映射等价于一个空映射，只是 <code>nil</code> 映射不能添加元素。
</p>

<div class="english">
<h3 id="Channel_types">Channel types</h3>
</div>

<h3 id="信道类型">信道类型</h3>

<div class="english">
<p>
A channel provides a mechanism for
<a href="#Go_statements">concurrently executing functions</a>
to communicate by
<a href="#Send_statements">sending</a> and
<a href="#Receive_operator">receiving</a>
values of a specified element type.
The value of an uninitialized channel is <code>nil</code>.
</p>

<pre class="ebnf">
ChannelType = ( "chan" | "chan" "&lt;-" | "&lt;-" "chan" ) ElementType .
</pre>
</div>

<p>
信道为<a href="#Go语句">并发地执行函数 </a>提供了一种机制，
通过<a href="#发送语句">发送</a>和<a href="#接收操作符">接受</a>具体元素类型的值来通信。
未初始化的信道值为 <code>nil</code>。
</p>

<pre class="ebnf">
信道类型 = ( "chan" [ "chan" "&lt;-" ] | "&lt;-" "chan" ) 元素类型 .
</pre>

<div class="english">
<p>
The optional <code>&lt;-</code> operator specifies the channel <i>direction</i>,
<i>send</i> or <i>receive</i>. If no direction is given, the channel is
<i>bidirectional</i>.
A channel may be constrained only to send or only to receive by
<a href="#Assignments">assignment</a> or
explicit <a href="#Conversions">conversion</a>.
</p>

<pre>
chan T          // can be used to send and receive values of type T
chan&lt;- float64  // can only be used to send float64s
&lt;-chan int      // can only be used to receive ints
</pre>
</div>

<p>
可选的 <code>&lt;-</code> 操作符指定信道的<b>方向</b>，<b>发送</b>或<b>接收</b>。
若没有给定方向，那么该信道就是<b>双向的</b>。
信道可通过<a href="#类型转换">类型转换</a> 或 <a href="#赋值">赋值</a>被强制为只发送或只接收。
</p>

<pre>
chan T          // 可以被用来发送和接收类型 T 的值
chan&lt;- float64  // 只能被用来发送浮点数
&lt;-chan int      // 只能被用来接收整数
</pre>

<div class="english">
<p>
The <code>&lt;-</code> operator associates with the leftmost <code>chan</code>
possible:
</p>

<pre>
chan&lt;- chan int    // same as chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // same as chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // same as &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)
</pre>
</div>

<p>
<code>&lt;-</code> 操作符结合最左边的 <code>chan</code> 可能的方式：
</p>

<pre>
chan&lt;- chan int    // 等价于 chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // 等价于 chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // 等价于 &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)
</pre>

<div class="english">
<p>
A new, initialized channel
value can be made using the built-in function
<a href="#Making_slices_maps_and_channels"><code>make</code></a>,
which takes the channel type and an optional <i>capacity</i> as arguments:
</p>
</div>

<p>
一个新的，已初始化的信道值可使用内建函数 <a href="#创建切片、映射与信道"><code>make</code></a> 创建，
它接受信道类型和一个可选的<b>容量</b>作为实参：
</p>

<pre>
make(chan int, 100)
</pre>

<div class="english">
<p>
The capacity, in number of elements, sets the size of the buffer in the channel.
If the capacity is zero or absent, the channel is unbuffered and communication
succeeds only when both a sender and receiver are ready. Otherwise, the channel
is buffered and communication succeeds without blocking if the buffer
is not full (sends) or not empty (receives).
A <code>nil</code> channel is never ready for communication.
</p>
</div>

<p>
容量根据元素的数量设置信道中缓存的大小。若容量为零或缺失，则信道为无缓冲的，
且仅当发送者和接收者均已准备就绪时通信才会成功；否则，信道即为带缓冲的，
且当缓冲未满（发送）或非空（接收）时，通信操作无阻塞成功。
<code>nil</code> 信道永远不会准备好通信。
</p>

<div class="english">
<p>
A channel may be closed with the built-in function
<a href="#Close"><code>close</code></a>.
The multi-valued assignment form of the
<a href="#Receive_operator">receive operator</a>
reports whether a received value was sent before
the channel was closed.
</p>
</div>

<p>
信道可通过内建函数 <a href="#关闭"><code>close</code></a> 关闭；
<a href="#接收操作符">接收操作符</a>的多值赋值形式可在信道关闭前
报告接收的值是否已发送。
</p>

<div class="english">
<p>
A single channel may be used in
<a href="#Send_statements">send statements</a>,
<a href="#Receive_operator">receive operations</a>,
and calls to the built-in functions
<a href="#Length_and_capacity"><code>cap</code></a> and
<a href="#Length_and_capacity"><code>len</code></a>
by any number of goroutines without further synchronization.
Channels act as first-in-first-out queues.
For example, if one goroutine sends values on a channel
and a second goroutine receives them, the values are
received in the order sent.
</p>
</div>

<p>
单个信道可在<a href="#发送语句">发送语句</a>和<a href="#接收操作符">接收操作符</a>中使用，
且可由任意数量的Go程对其调用内建函数 <a href="#长度与容量"><code>cap</code></a>
和 <a href="#长度与容量"><code>len</code></a> 而无需进一步的同步。
信道可充当先进先出的队列。例如，若Go程在信道上发送了一些值，而第二个信道接收了它们，
那么这些值会按照发送的顺序来接收。
</p>

<div class="english">
<h2 id="Properties_of_types_and_values">Properties of types and values</h2>
</div>

<h2 id="类型与值的性质">类型与值的性质</h2>

<div class="english">
<h3 id="Type_identity">Type identity</h3>
</div>

<h3 id="类型标识">类型标识</h3>

<div class="english">
<p>
Two types are either <i>identical</i> or <i>different</i>.
</p>
</div>

<p>
两个类型若非<b>相同</b>即为<b>不同</b>。
</p>

<div class="english">
<p>
A <a href="#Type_definitions">defined type</a> is always different from any other type.
Otherwise, two types are identical if their <a href="#Types">underlying</a> type literals are
structurally equivalent; that is, they have the same literal structure and corresponding
components have identical types. In detail:
</p>

<ul>
	<li>Two array types are identical if they have identical element types and
	    the same array length.</li>

	<li>Two slice types are identical if they have identical element types.</li>

	<li>Two struct types are identical if they have the same sequence of fields,
	    and if corresponding fields have the same names, and identical types,
	    and identical tags.
	    <a href="#Exported_identifiers">Non-exported</a> field names from different
	    packages are always different.</li>

	<li>Two pointer types are identical if they have identical base types.</li>

	<li>Two function types are identical if they have the same number of parameters
	    and result values, corresponding parameter and result types are
	    identical, and either both functions are variadic or neither is.
	    Parameter and result names are not required to match.</li>

	<li>Two interface types are identical if they have the same set of methods
	    with the same names and identical function types.
	    <a href="#Exported_identifiers">Non-exported</a> method names from different
	    packages are always different. The order of the methods is irrelevant.</li>

	<li>Two map types are identical if they have identical key and element types.</li>

	<li>Two channel types are identical if they have identical element types and
	    the same direction.</li>
</ul>
</div>

<p>
若两个<a href="#类型">已命名类型</a>的类型名源自相同的<a href="#类型声明">类型实现</a>，它们就是相同的。
一个已命名类型和一个<a href="#类型">未命名类型</a>总不相同。若两个未命名类型其相应的类型字面相同，
那么它们的类型相同，即，它们的字面结构是否相同且其相应的组件类型是否相同。细节详述：
</p>

<ul>
	<li>若两个数组类型其元素类型相同且长度相同，那么它们的类型相同。</li>

	<li>若两个切片类型其元素类型相同，那么它们的类型相同。</li>

	<li>若两个结构体类型其字段序列相同，相应字段名相同，类型相同，标注相同，那么它们的类型相同。
		两个匿名字段其名字被认为相同。出自不同包的小写字段名总不相同。</li>

	<li>若两个指针类型其基础类型相同，那么它们的类型相同。</li>

	<li>若两个函数类型其形参个数相同，返回值相同，相应形参类型相同，返回值类型相同，
		两函数都可变或都不可变，那么它们的类型相同。形参和返回值名无需匹配。</li>

	<li>若两个接口类型其方法集相同，名字相同，函数类型相同，那么它们的类型相同。
		出自不同包的小写方法名总不相同。两接口类型是否相同与方法的次序无关。</li>

	<li>若两个映射类型其键值类型相同，那么它们的类型相同。</li>

	<li>若两个信道类型其值类型相同，方向相同，那么它们的类型相同。</li>
</ul>

<div class="english">
<p>
Given the declarations
</p>
</div>

<p>
给定声明
</p>

<pre>
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string
)

type (
	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1
)

type	C0 = B0
</pre>

<div class="english">
<p>
these types are identical:
</p>

<pre>
A0, A1, and []string
A2 and struct{ a, b int }
A3 and int
A4, func(int, float64) *[]string, and A5

B0 and C0
[]int and []int
struct{ a, b *T5 } and struct{ a, b *T5 }
func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5
</pre>
</div>

<p>
这些类型是相同的：
</p>

<pre>
T0 和 T0
[]int 和 []int
struct{ a, b *T5 } 和 struct{ a, b *T5 }
func(x int, y float64) *[]string 和 func(int, float64) (result *[]string)
</pre>

<div class="english">
<p>
<code>B0</code> and <code>B1</code> are different because they are new types
created by distinct <a href="#Type_definitions">type definitions</a>;
<code>func(int, float64) *B0</code> and <code>func(x int, y float64) *[]string</code>
are different because <code>B0</code> is different from <code>[]string</code>.
</p>
</div>

<p>
<code>T0</code> 和 <code>T1</code> 是不同的，因为它们由不同声明的类型命名；
<code>func(int, float64) *T0</code> 和 <code>func(x int, y float64) *[]string</code> 是不同的，
因为 <code>T0</code> 不同于 <code>[]string</code>。
</p>


<div class="english">
<h3 id="Assignability">Assignability</h3>
</div>

<h3 id="可赋值性">可赋值性</h3>

<div class="english">
<p>
A value <code>x</code> is <i>assignable</i> to a <a href="#Variables">variable</a> of type <code>T</code>
("<code>x</code> is assignable to <code>T</code>") if one of the following conditions applies:
</p>

<ul>
<li>
<code>x</code>'s type is identical to <code>T</code>.
</li>
<li>
<code>x</code>'s type <code>V</code> and <code>T</code> have identical
<a href="#Types">underlying types</a> and at least one of <code>V</code>
or <code>T</code> is not a <a href="#Type_definitions">defined</a> type.
</li>
<li>
<code>T</code> is an interface type and
<code>x</code> <a href="#Interface_types">implements</a> <code>T</code>.
</li>
<li>
<code>x</code> is a bidirectional channel value, <code>T</code> is a channel type,
<code>x</code>'s type <code>V</code> and <code>T</code> have identical element types,
and at least one of <code>V</code> or <code>T</code> is not a defined type.
</li>
<li>
<code>x</code> is the predeclared identifier <code>nil</code> and <code>T</code>
is a pointer, function, slice, map, channel, or interface type.
</li>
<li>
<code>x</code> is an untyped <a href="#Constants">constant</a>
<a href="#Representability">representable</a>
by a value of type <code>T</code>.
</li>
</ul>
</div>

<p>
在下列情况下，值 <code>x</code><b>可赋予</b>类型为 <code>T</code> 的<a href="#变量">变量</a>
（"<code>x</code> 可赋予 <code>T</code>"）：
</p>

<ul>
<li>
当 <code>x</code> 的类型和 <code>T</code> 相同时。
</li>
<li>
当 <code>x</code> 的类型 <code>V</code> 和 <code>T</code> 有相同的
<a href="#类型">底层类型</a> 且在 <code>V</code> 或 <code>T</code> 中至少有一个不是<a href="#类型">已命名类型</a>时。
</li>
<li>
当 <code>T</code> 为接口类型且 <code>x</code> <a href="#接口类型">实现</a>了 <code>T</code>时。
</li>
<li>
当 <code>x</code> 为双向信道值、<code>T</code> 为信道类型、
<code>x</code> 的类型 <code>V</code> 和 <code>T</code> 的元素类型相同且在
<code>V</code> 或 <code>T</code> 中至少有一个不是已命名类型时。
</li>
<li>
当 <code>x</code> 为预声明标识符 <code>nil</code> 且 <code>T</code>
为指针、函数、切片、映射、通道或接口类型时。
</li>
<li>
当 <code>x</code> 为无类型化，可通过类型 <code>T</code> 的值来表示的 <a href="#常量">常量</a>时。
</li>
</ul>

<div class="english">
<p>
Any value may be assigned to the <a href="#Blank_identifier">blank identifier</a>.
</p>
</div>

<p>
任何类型都可赋予<a href="#空白标识符">空白标识符</a>.
</p>


<div class="english">
<h3 id="Representability">Representability</h3>
</div>

<h3 id="可表示性">可表示性</h3>

<div class="english">
<p>
A <a href="#Constants">constant</a> <code>x</code> is <i>representable</i>
by a value of type <code>T</code> if one of the following conditions applies:
</p>

<ul>
<li>
<code>x</code> is in the set of values <a href="#Types">determined</a> by <code>T</code>.
</li>

<li>
<code>T</code> is a floating-point type and <code>x</code> can be rounded to <code>T</code>'s
precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE
negative zero further simplified to an unsigned zero. Note that constant values never result
in an IEEE negative zero, NaN, or infinity.
</li>

<li>
<code>T</code> is a complex type, and <code>x</code>'s
<a href="#Complex_numbers">components</a> <code>real(x)</code> and <code>imag(x)</code>
are representable by values of <code>T</code>'s component type (<code>float32</code> or
<code>float64</code>).
</li>
</ul>
</div>

<p>
若满足以下条件，则<a href="#常量">常量</a> <code>x</code> <b>可表示</b> 为
<code>T</code> 类型的值：
</p>

<ul>
<li>
<code>x</code> 在由 <code>T</code> 所<a href="#类型">确定</a>的值的集合中。
</li>

<li>
<code>T</code> 为浮点类型且 <code>x</code> 可被舍入到 <code>T</code> 的精度而不会溢出。
舍入遵循 IEEE 754 「舍入到偶数」规则，不过 IEEE 负零会进一步简化为无符号零。
注意常量值永远不会产生 IEEE 负零、NaN 或无限。
</li>

<li>
<code>T</code> 为复数类型，且 <code>x</code> 的<a href="#复数">实虚部</a>
<code>real(x)</code> 和 <code>imag(x)</code> 可被表示为 <code>T</code>
的部分类型（<code>float32</code> 或 <code>float64</code>）的值。
</li>
</ul>

<div class="english">
<pre>
x                   T           x is representable by a value of T because

'a'                 byte        97 is in the set of byte values
97                  rune        rune is an alias for int32, and 97 is in the set of 32-bit integers
"foo"               string      "foo" is in the set of string values
1024                int16       1024 is in the set of 16-bit integers
42.0                byte        42 is in the set of unsigned 8-bit integers
1e10                uint64      10000000000 is in the set of unsigned 64-bit integers
2.718281828459045   float32     2.718281828459045 rounds to 2.7182817 which is in the set of float32 values
-1e-1000            float64     -1e-1000 rounds to IEEE -0.0 which is further simplified to 0.0
0i                  int         0 is an integer value
(42 + 0i)           float32     42.0 (with zero imaginary part) is in the set of float32 values
</pre>

<pre>
x                   T           x is not representable by a value of T because

0                   bool        0 is not in the set of boolean values
'a'                 string      'a' is a rune, it is not in the set of string values
1024                byte        1024 is not in the set of unsigned 8-bit integers
-1                  uint16      -1 is not in the set of unsigned 16-bit integers
1.1                 int         1.1 is not an integer value
42i                 float32     (0 + 42i) is not in the set of float32 values
1e1000              float64     1e1000 overflows to IEEE +Inf after rounding
</pre>
</div>

<pre>
x                   T           x 可表示为一个 T 类型的值，因为

'a'                 byte        97 属于 byte 值的集合
97                  rune        rune 是 int32 的别名，且 97 属于 32 位整数值的集合
"foo"               string      "foo" 属于 string 值的集合
1024                int16       1024 属于 16 位整数的集合
42.0                byte        42 属于无符号 8 位整数的集合
1e10                uint64      10000000000 属于 64 位无符号整数的集合
2.718281828459045   float32     2.718281828459045 舍入到 2.7182817，它属于 float32 值的集合
-1e-1000            float64     -1e-1000 舍入到 IEEE -0.0，它进一步简化为 0.0
0i                  int         0 是一个整数值
(42 + 0i)           float32     42.0（实部为零）属于 float32 值的集合
</pre>

<pre>
x                   T           x 无法表示为一个 T 类型的值，因为

0                   bool        0 不属于布尔值的集合
'a'                 string      'a' 是一个 rune，它不属于 string 值的集合
1024                byte        1024 不属于无符号 8 位整数的集合
-1                  uint16      -1 不属于 16 位无符号整数的集合
1.1                 int         1.1 不是一个整数值
42i                 float32     (0 + 42i) 不属于 float32 值的集合
1e1000              float64     1e1000 舍入后溢出到 IEEE +Inf
</pre>


<div class="english">
<h2 id="Blocks">Blocks</h2>
</div>

<h2 id="块">块</h2>

<div class="english">
<p>
A <i>block</i> is a possibly empty sequence of declarations and statements
within matching brace brackets.
</p>
</div>

<pre class="ebnf">
Block = "{" StatementList "}" .
StatementList = { Statement ";" } .
</pre>

<p>
<b>块</b>为一对大括号括住的，可能为空的一系列声明和语句。
</p>

<pre class="ebnf">
块 = "{" 语句列表 "}" .
语句列表 = { 语句 ";" } .
</pre>

<div class="english">
<p>
In addition to explicit blocks in the source code, there are implicit blocks:
</p>

<ol>
	<li>The <i>universe block</i> encompasses all Go source text.</li>

	<li>Each <a href="#Packages">package</a> has a <i>package block</i> containing all
	    Go source text for that package.</li>

	<li>Each file has a <i>file block</i> containing all Go source text
	    in that file.</li>

	<li>Each <a href="#If_statements">"if"</a>,
	    <a href="#For_statements">"for"</a>, and
	    <a href="#Switch_statements">"switch"</a>
	    statement is considered to be in its own implicit block.</li>

	<li>Each clause in a <a href="#Switch_statements">"switch"</a>
	    or <a href="#Select_statements">"select"</a> statement
	    acts as an implicit block.</li>
</ol>
</div>

<p>
除显式源码块外，还有隐式块：
</p>

<ol>
	<li><b>全域块</b>包含所有的 Go 源码文本。</li>

	<li>每个<a href="#包">包</a>都有包含其所有 Go 源码文本的<b>包块</b>。</li>

	<li>每个文件都有包含其所有 Go 源码文本的<b>文件块</b>。</li>

	<li>每个 <a href="#If语句">if</a>、<a href="#For语句">for</a> 和
		<a href="#Switch语句">switch</a> 语句都被视为处于其自身的隐式块中。</li>

	<li>每个 <a href="#Switch语句">switch</a> 或 <a href="#Select语句">select</a>
		语句中的子句其行为如同隐式块。</li>
</ol>

<div class="english">
<p>
Blocks nest and influence <a href="#Declarations_and_scope">scoping</a>.
</p>
</div>

<p>
块可嵌套并会影响<a href="#声明与作用域">作用域</a>。
</p>


<div class="english">
<h2 id="Declarations_and_scope">Declarations and scope</h2>
</div>

<h2 id="声明与作用域">声明与作用域</h2>

<div class="english">
<p>
A <i>declaration</i> binds a non-<a href="#Blank_identifier">blank</a> identifier to a
<a href="#Constant_declarations">constant</a>,
<a href="#Type_declarations">type</a>,
<a href="#Variable_declarations">variable</a>,
<a href="#Function_declarations">function</a>,
<a href="#Labeled_statements">label</a>, or
<a href="#Import_declarations">package</a>.
Every identifier in a program must be declared.
No identifier may be declared twice in the same block, and
no identifier may be declared in both the file and package block.
</p>

<p>
The <a href="#Blank_identifier">blank identifier</a> may be used like any other identifier
in a declaration, but it does not introduce a binding and thus is not declared.
In the package block, the identifier <code>init</code> may only be used for
<a href="#Package_initialization"><code>init</code> function</a> declarations,
and like the blank identifier it does not introduce a new binding.
</p>

<pre class="ebnf">
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
</pre>
</div>

<p>
声明可将非<a href="#空白标识符">空白</a>标识符绑定到一个<a href="#常量声明">常量</a>、
<a href="#类型声明">类型</a>、<a href="#变量声明">变量</a>、<a href="#函数声明">函数</a>、
<a href="#标签语句">标签</a>或<a href="#导入声明">包</a>。
在程序中，每个标识符都必须被声明。同一标识符不能在同一块中声明两次，且在文件与包块中不能同时声明。
</p>

<p>
<a href="#空白标识符">空白标识符</a>可像其它标识符一样在声明中使用，但由于它不会引入绑定，
因此也就视作未声明的。在包块中，标识符 <code>init</code> 仅能用作
<a href="#包初始化"><code>init</code> 函数</a>声明，且与空白标识符一样不会引入新的绑定。
</p>

<pre class="ebnf">
声明 = 常量声明 | 类型声明 | 变量声明 .
顶级声明 = 声明 | 函数声明 | 方法声明 .
</pre>

<div class="english">
<p>
The <i>scope</i> of a declared identifier is the extent of source text in which
the identifier denotes the specified constant, type, variable, function, label, or package.
</p>
</div>

<p>
已声明标识符的<b>作用域</b>即为该标识符所表示的具体常量、类型、变量、函数、标签或包在源文本中的作用范围。
</p>

<div class="english">
<p>
Go is lexically scoped using <a href="#Blocks">blocks</a>:
</p>

<ol>
	<li>The scope of a <a href="#Predeclared_identifiers">predeclared identifier</a> is the universe block.</li>

	<li>The scope of an identifier denoting a constant, type, variable,
	    or function (but not method) declared at top level (outside any
	    function) is the package block.</li>

	<li>The scope of the package name of an imported package is the file block
	    of the file containing the import declaration.</li>

	<li>The scope of an identifier denoting a method receiver, function parameter,
	    or result variable is the function body.</li>

	<li>The scope of a constant or variable identifier declared
	    inside a function begins at the end of the ConstSpec or VarSpec
	    (ShortVarDecl for short variable declarations)
	    and ends at the end of the innermost containing block.</li>

	<li>The scope of a type identifier declared inside a function
	    begins at the identifier in the TypeSpec
	    and ends at the end of the innermost containing block.</li>
</ol>
</div>

<p>
Go 使用<a href="#块">块</a>表示词法作用域：
</p>

<ol>
	<li><a href="#预声明标识符">预声明标识符</a>的作用域为全域块。</li>

	<li>在顶级（即在任何函数之外）声明的表示常量、类型、变量或函数
		（而非方法）的标识符其作用域为该包块。</li>

	<li>已导入包的包名作用域为包含该导入声明的文件块。</li>

	<li>表示方法接收器、函数形参或返回值变量的标识符，其作用域为该函数体。</li>

	<li>在函数中声明为常量或变量的标识符，其作用域始于该函数中具体常量实现或变量实现
		（ShortVarDecl 表示短变量声明）的结尾，止于最内部包含块的结尾。</li>

	<li>在函数中声明为类型的标识符，其作用域始于该函数中具体类型实现的标识符，
		止于最内部包含块的结尾。</li>
</ol>

<div class="english">
<p>
An identifier declared in a block may be redeclared in an inner block.
While the identifier of the inner declaration is in scope, it denotes
the entity declared by the inner declaration.
</p>
</div>

<p>
在块中声明的标识符可在其内部块中重新声明。
当其内部声明的标识符在作用域中时，即表示其实体在该内部声明中声明。
</p>

<div class="english">
<p>
The <a href="#Package_clause">package clause</a> is not a declaration; the package name
does not appear in any scope. Its purpose is to identify the files belonging
to the same <a href="#Packages">package</a> and to specify the default package name for import
declarations.
</p>
</div>

<p>
<a href="#包子句">包子句</a>并非声明；包名不会出现在任何作用域中。
其目的是为了识别该文件是否属于相同的<a href="#包">包</a>并为导入声明指定默认包名。
</p>


<div class="english">
<h3 id="Label_scopes">Label scopes</h3>
</div>

<h3 id="标签作用域">标签作用域</h3>

<div class="english">
<p>
Labels are declared by <a href="#Labeled_statements">labeled statements</a> and are
used in the <a href="#Break_statements">"break"</a>,
<a href="#Continue_statements">"continue"</a>, and
<a href="#Goto_statements">"goto"</a> statements.
It is illegal to define a label that is never used.
In contrast to other identifiers, labels are not block scoped and do
not conflict with identifiers that are not labels. The scope of a label
is the body of the function in which it is declared and excludes
the body of any nested function.
</p>
</div>

<p>
标签通过<a href="#标签语句">标签语句</a>声明，并用于
<a href="#Break语句">break</a>、<a href="#Continue语句">continue</a>
和 <a href="#Goto语句">goto</a> 语句。
定义不会使用的标签是非法的。与其它标识符相反，标签并不限定作用域且与非标签标识符并不冲突。
标签的作用域为除任何嵌套函数体外其声明的函数体。
</p>


<div class="english">
<h3 id="Blank_identifier">Blank identifier</h3>
</div>

<h3 id="空白标识符">空白标识符</h3>

<div class="english">
<p>
The <i>blank identifier</i> is represented by the underscore character <code>_</code>.
It serves as an anonymous placeholder instead of a regular (non-blank)
identifier and has special meaning in <a href="#Declarations_and_scope">declarations</a>,
as an <a href="#Operands">operand</a>, and in <a href="#Assignments">assignments</a>.
</p>
</div>

<p>
<b>空白标识符</b>用下划线字符 <code>_</code> 表示。它作为匿名占位符而非普通的（非空）标识符，
在<a href="#声明与作用域">声明</a>中，作为<a href="#操作数">操作数</a>以及在<a href="#赋值">赋值</a>中有特殊的意义，
</p>


<div class="english">
<h3 id="Predeclared_identifiers">Predeclared identifiers</h3>
</div>

<h3 id="预声明标识符">预声明标识符</h3>

<div class="english">
<p>
The following identifiers are implicitly declared in the
<a href="#Blocks">universe block</a>:
</p>
<pre class="grammar">
Types:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap close complex copy delete imag len
	make new panic print println real recover
</pre>
</div>

<p>
在<a href="#块">全域块</a>中，以下标识符是隐式声明的：
</p>

<pre class="grammar">
类型：
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

常量：
	true false iota

零值：
	nil

函数：
	append cap close complex copy delete imag len
	make new panic print println real recover
</pre>


<div class="english">
<h3 id="Exported_identifiers">Exported identifiers</h3>
</div>

<h3 id="可导出标识符">可导出标识符</h3>

<div class="english">
<p>
An identifier may be <i>exported</i> to permit access to it from another package.
An identifier is exported if both:
</p>
<ol>
	<li>the first character of the identifier's name is a Unicode upper case
	letter (Unicode class "Lu"); and</li>
	<li>the identifier is declared in the <a href="#Blocks">package block</a>
	or it is a <a href="#Struct_types">field name</a> or
	<a href="#MethodName">method name</a>.</li>
</ol>
<p>
All other identifiers are not exported.
</p>
</div>

<p>
标识符可被<b>导出</b>以允许从另一个包访问。同时符合以下条件即为可导出标识符：
</p>

<ol>
	<li>标识符名的第一个字符为 Unicode 大写字母（Unicode 类别“Lu”）；且</li>
	<li>该标识符在<a href="#块">包块</a>中已声明或为<a href="#结构体类型">字段名</a>或
	<a href="#方法名">方法名</a>。</li>
</ol>
<p>
其它所有标识符均为未导出的。
</p>


<div class="english">
<h3 id="Uniqueness_of_identifiers">Uniqueness of identifiers</h3>
</div>

<h3 id="标识符的唯一性">标识符的唯一性</h3>

<div class="english">
<p>
Given a set of identifiers, an identifier is called <i>unique</i> if it is
<i>different</i> from every other in the set.
Two identifiers are different if they are spelled differently, or if they
appear in different <a href="#Packages">packages</a> and are not
<a href="#Exported_identifiers">exported</a>. Otherwise, they are the same.
</p>
</div>

<p>
给定一个标识符集，若其中一个标识符<b>不同于</b>该集中的任一标识符，那么它就是<b>唯一的</b>。
若两个标识符拼写不同，或它们出现在不同的<a href="#包">包</a>中且未
<a href="可导出标识符">导出</a>，那么它们就是不同的。否则，它们就是相同的。
</p>

<div class="english">
<h3 id="Constant_declarations">Constant declarations</h3>
</div>

<h3 id="常量声明">常量声明</h3>

<div class="english">
<p>
A constant declaration binds a list of identifiers (the names of
the constants) to the values of a list of <a href="#Constant_expressions">constant expressions</a>.
The number of identifiers must be equal
to the number of expressions, and the <i>n</i>th identifier on
the left is bound to the value of the <i>n</i>th expression on the
right.
</p>

<pre class="ebnf">
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
</pre>
</div>

<p>
常量声明将一个标识符（即常量名）列表绑定至一个<a href="#常量表达式">常量表达式</a>列表的值。
标识符的数量必须与表达式的数量相等，且左边第 <i>n</i> 个标识符会绑定至右边的第 <i>n</i> 个表达式的值。
</p>

<pre class="ebnf">
常量声明   = "const" ( 常量实现 | "(" { 常量实现 ";" } ")" ) .
常量实现   = 标识符列表 [ [ 类型 ] "=" 表达式列表 ] .

标识符列表 = 标识符 { "," 标识符 } .
表达式列表 = 表达式 { "," 表达式 } .
</pre>

<div class="english">
<p>
If the type is present, all constants take the type specified, and
the expressions must be <a href="#Assignability">assignable</a> to that type.
If the type is omitted, the constants take the
individual types of the corresponding expressions.
If the expression values are untyped <a href="#Constants">constants</a>,
the declared constants remain untyped and the constant identifiers
denote the constant values. For instance, if the expression is a
floating-point literal, the constant identifier denotes a floating-point
constant, even if the literal's fractional part is zero.
</p>

<pre>
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant
const (
	size int64 = 1024
	eof        = -1  // untyped integer constant
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", untyped integer and string constants
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
</pre>
</div>

<p>
若该类型存在，所有常量都将获得该类型实现，且该表达式对于该类型必须是
<a href="#可赋值性">可赋值</a>的。若该类型被省略，则该常量将获得其对应表达式的具体类型。
若该表达式值为无类型化<a href="#常量">常量</a>，则其余已声明无类型化常量与该常量标识符表示其常量值。
例如，若该表达式为浮点数字面，则该常量标识符表示一个浮点数常量，即使该字面的小数部分为零。
</p>

<pre>
const Pi float64 = 3.14159265358979323846
const zero = 0.0       // 无类型化浮点常量
const (
	size int64 = 1024
	eof        = -1    // 无类型化整数常量
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", 无类型化整数和字符串常量
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
</pre>

<div class="english">
<p>
Within a parenthesized <code>const</code> declaration list the
expression list may be omitted from any but the first ConstSpec.
Such an empty list is equivalent to the textual substitution of the
first preceding non-empty expression list and its type if any.
Omitting the list of expressions is therefore equivalent to
repeating the previous list.  The number of identifiers must be equal
to the number of expressions in the previous list.
Together with the <a href="#Iota"><code>iota</code> constant generator</a>
this mechanism permits light-weight declaration of sequential values:
</p>

<pre>
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // this constant is not exported
)
</pre>
</div>

<p>
在 <code>const</code> 后括号中的声明列表中，除第一个 ConstSpec 外，任何表达式列表都可省略。
若前面第一个非空表达式有类型，那么这样的空列表等价于该表达式原文和类型的代换。
因此，省略表达式的列表等价于重复前面的列表。其标识符的数量必须与上一个表达式的数量相等。
连同 <a href="#Iota"><code>iota</code> 常量生成器</a>，该机制允许轻量级连续值声明：
</p>

<pre>
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // 该常量未导出
)
</pre>


<h3 id="Iota">Iota</h3>

<div class="english">
<p>
Within a <a href="#Constant_declarations">constant declaration</a>, the predeclared identifier
<code>iota</code> represents successive untyped integer <a href="#Constants">
constants</a>. Its value is the index of the respective <a href="#ConstSpec">ConstSpec</a>
in that constant declaration, starting at zero.
It can be used to construct a set of related constants:
</p>

<pre>
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 &lt;&lt; iota  // a == 1  (iota == 0)
	b = 1 &lt;&lt; iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, unused)
	d = 1 &lt;&lt; iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (untyped integer constant)
	v float64 = iota * 42  // v == 42.0  (float64 constant)
	w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0
const y = iota  // y == 0
</pre>
</div>

<p>
在<a href="#常量声明">常量声明</a>中预声明标识符 <code>iota</code> 表示连续的无类型化整数
<a href="#常量">常量</a>。每当保留字 <code>const</code> 出现在源码中和每个
<a href="#常量实现">常量实现</a>增量后，它都会被重置为 0。它可被用来构造相关常量的集：
</p>

<pre>
const ( // iota 重置为 0
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const ( // iota 重置为 0
	a = 1 &lt;&lt; iota  // a == 1
	b = 1 &lt;&lt; iota  // b == 2
	c = 3          // c == 3  （iota 未使用但仍在递增）
	d = 1 &lt;&lt; iota  // d == 8
)

const ( // iota 重置为 0
	u         = iota * 42  // u == 0     （无类型化整数常量）
	v float64 = iota * 42  // v == 42.0  （float64 常量）
	w         = iota * 42  // w == 84    （无类型化整数常量）
)

const x = iota  // x == 0  （iota 已重置）
const y = iota  // y == 0  （iota 已重置）
</pre>

<div class="english">
<p>
By definition, multiple uses of <code>iota</code> in the same ConstSpec all have the same value:
</p>

<pre>
const (
	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                  //                        (iota == 2, unused)
	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)
)
</pre>
</div>

<p>
在表达式列表中，每个 <code>iota</code> 的值都相同，因为它只在每个常量实现后增量。
</p>

<pre>
const (
	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0
	bit1, mask1                           // bit1 == 2, mask1 == 1
	_, _                                  // 跳过 iota == 2
	bit3, mask3                           // bit3 == 8, mask3 == 7
)
</pre>

<div class="english">
<p>
This last example exploits the <a href="#Constant_declarations">implicit repetition</a>
of the last non-empty expression list.
</p>
</div>

<p>
最后一个例子采用上一个非空表达式列表的隐式副本。
</p>


<div class="english">
<h3 id="Type_declarations">Type declarations</h3>
</div>

<h3 id="类型声明">类型声明</h3>

<div class="english">
<p>
A type declaration binds an identifier, the <i>type name</i>, to a <a href="#Types">type</a>.
Type declarations come in two forms: alias declarations and type definitions.
</p>

<pre class="ebnf">
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec = AliasDecl | TypeDef .
</pre>
</div>

<p>
类型声明将标识符，即<b>类型名</b>绑定至<a href="#类型">类型</a>。
类型声明有两种形式：别名声明和类型定义。
</p>

<pre class="ebnf">
类型声明     = "type" ( 类型实现 | "(" { 类型实现 ";" } ")" ) .
类型实现     = 别名声明 | 类型定义 .
</pre>

<div class="english">
<h4 id="Alias_declarations">Alias declarations</h4>
</div>

<h4 id="别名声明">别名声明</h4>

<div class="english">
<p>
An alias declaration binds an identifier to the given type.
</p>

<pre class="ebnf">
AliasDecl = identifier "=" Type .
</pre>
</div>

<p>
别名声明将标识符绑定至给定的类型。
</p>

<pre class="ebnf">
别名声明 = 标识符 "=" 类型 .
</pre>

<div class="english">
<p>
Within the <a href="#Declarations_and_scope">scope</a> of
the identifier, it serves as an <i>alias</i> for the type.
</p>

<pre>
type (
	nodeList = []*Node  // nodeList and []*Node are identical types
	Polar    = polar    // Polar and polar denote identical types
)
</pre>
</div>

<p>
在标识符的<a href="#Declarations_and_scope">作用域</a>中，它会作为该类型的
<b>别名</b>。
</p>

<pre>
type (
	nodeList = []*Node  // nodeList 和 []*Node 是相同的类型
	Polar    = polar    // Polar 和 polar 表示相同的类型
)
</pre>

<div class="english">
<h4 id="Type_definitions">Type definitions</h4>
</div>

<h4 id="类型定义">类型定义</h4>

<div class="english">
<p>
A type definition creates a new, distinct type with the same
<a href="#Types">underlying type</a> and operations as the given type,
and binds an identifier to it.
</p>

<pre class="ebnf">
TypeDef = identifier Type .
</pre>
</div>

<p>
类型定义创建一个新的，不同的类型并将一个标识符绑定至它，但它和给定的类型拥有相同的
<a href="#类型">底层类型</a>和操作。
</p>

<pre class="ebnf">
类型定义 = 标识符 类型 .
</pre>

<div class="english">
<p>
The new type is called a <i>defined type</i>.
It is <a href="#Type_identity">different</a> from any other type,
including the type it is created from.
</p>

<pre>
type (
	Point struct{ x, y float64 }  // Point and struct{ x, y float64 } are different types
	polar Point                   // polar and Point denote different types
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
</pre>
</div>

<p>
新的类型叫做<b>定义的类型</b>。它与其它任何类型，包括用于创建它的类型都
<a href="#类型标识">不同</a>。
</p>

<pre>
type (
	Point struct{ x, y float64 }  // Point 和 struct{ x, y float64 } 是不同的类型
	polar Point                   // polar 和 Point 表示不同的类型
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
</pre>

<div class="english">
<p>
A defined type may have <a href="#Method_declarations">methods</a> associated with it.
It does not inherit any methods bound to the given type,
but the <a href="#Method_sets">method set</a>
of an interface type or of elements of a composite type remains unchanged:
</p>

<pre>
// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of PtrMutex's underlying type *Mutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its embedded field Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
</pre>
</div>

<p>
定义的类型可拥有关联到它的<a href="#方法声明">方法</a>。
它不继承任何绑定到给定类型的<a href="#方法声明">方法</a>，
但接口类型或复合类型的元素的<a href="#方法集">方法集</a>保持不变：
</p>

<pre>
// Mutex 为带有 Lock 和 Unlock 两个方法的数据类型.
type Mutex struct         { /* Mutex 字段 */ }
func (m *Mutex) Lock()    { /* Lock 实现 */ }
func (m *Mutex) Unlock()  { /* Unlock 实现 */ }

// NewMutex 和 Mutex 拥有相同的组成，但它的方法集为空.
type NewMutex Mutex

// PtrMutex 的<a href="#指针类型">底层类型</a> *Mutex 的方法集保持不变，
// 但 PtrMutex 的方法集为空.
type PtrMutex *Mutex

// *PrintableMutex 的方法集包含绑定至其匿名字段 Mutex 的方法 Lock 和 Unlock.
type PrintableMutex struct {
	Mutex
}

// MyBlock 为与 Block 拥有相同方法集的接口类型.
type MyBlock Block
</pre>

<div class="english">
<p>
Type definitions may be used to define different boolean, numeric,
or string types and associate methods with them:
</p>
</div>

<p>
类型定义可用来定义不同的布尔值、数值或字符串类型并对其附上方法：
</p>

<pre>
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT%+dh", tz)
}
</pre>


<div class="english">
<h3 id="Variable_declarations">Variable declarations</h3>
</div>

<h3 id="变量声明">变量声明</h3>

<div class="english">
<p>
A variable declaration creates one or more <a href="#Variables">variables</a>,
binds corresponding identifiers to them, and gives each a type and an initial value.
</p>

<pre class="ebnf">
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
</pre>
</div>

<p>
变量声明创建一个或多个变量，为它们绑定对应的标识符，赋予其类型和初始值。
</p>

<pre class="ebnf">
变量声明     = "var" ( 变量实现 | "(" { 变量实现 ";" } ")" ) .
变量实现     = 标识符列表 ( 类型 [ "=" 表达式列表 ] | "=" 表达式列表 ) .
</pre>

<div class="english">
<pre>
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in "found"
</pre>
</div>

<pre>
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // 映射检查；只与“found”有关
</pre>

<div class="english">
<p>
If a list of expressions is given, the variables are initialized
with the expressions following the rules for <a href="#Assignments">assignments</a>.
Otherwise, each variable is initialized to its <a href="#The_zero_value">zero value</a>.
</p>
</div>

<p>
若给定一个表达式列表，则变量会按照§<a href="#赋值">赋值</a>规则以表达式来初始化；
否则，每个变量初始化为其 <a href="#零值">零值</a>。
</p>

<div class="english">
<p>
If a type is present, each variable is given that type.
Otherwise, each variable is given the type of the corresponding
initialization value in the assignment.
If that value is an untyped constant, it is first implicitly
<a href="#Conversions">converted</a> to its <a href="#Constants">default type</a>;
if it is an untyped boolean value, it is first implicitly converted to type <code>bool</code>.
The predeclared value <code>nil</code> cannot be used to initialize a variable
with no explicit type.
</p>
</div>

<p>
若类型存在，每个变量都会赋予该类型。否则，每个变量都会赋予在赋值中初始化值对应的类型。
若该值为无类型化常量，它首先会<a href="#转换">转换</a>为其<a href="#常量">默认类型</a>；
若它是一个为类型化的布尔值，它首先会转换为 <code>bool</code> 类型。
预声明的值 <code>nil</code> 无法在没有显式的类型时用于初始化变量。
</p>

<div class="english">
<pre>
var d = math.Sin(0.5)  // d is float64
var i = 42             // i is int
var t, ok = x.(T)      // t is T, ok is bool
var n = nil            // illegal
</pre>
</div>

<pre>
var d = math.Sin(0.5)  // d 为 float64
var i = 42             // i 为 int
var t, ok = x.(T)      // t 为 T, ok 为 bool
var n = nil            // 非法
</pre>

<div class="english">
<p>
Implementation restriction: A compiler may make it illegal to declare a variable
inside a <a href="#Function_declarations">function body</a> if the variable is
never used.
</p>
</div>

<p>
实现限制：若在<a href="#函数声明">函数体</a>内声明不会使用的变量，编译器可能将其判定为非法。
</p>

<div class="english">
<h3 id="Short_variable_declarations">Short variable declarations</h3>
</div>

<h3 id="短变量声明">短变量声明</h3>

<div class="english">
<p>
A <i>short variable declaration</i> uses the syntax:
</p>

<pre class="ebnf">
ShortVarDecl = IdentifierList ":=" ExpressionList .
</pre>
</div>

<p>
<b>短变量声明</b>使用此语法：
</p>

<pre class="ebnf">
短变量声明 = 标识符列表 ":=" 表达式列表 .
</pre>

<div class="english">
<p>
It is shorthand for a regular <a href="#Variable_declarations">variable declaration</a>
with initializer expressions but no types:
</p>

<pre class="grammar">
"var" IdentifierList = ExpressionList .
</pre>

<pre>
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() returns a connected pair of Files and an error, if any
_, y, _ := coord(p)   // coord() returns three values; only interested in y coordinate
</pre>
</div>

<p>
它是有初始化表达式无类型化的常规<a href="#变量声明">变量声明</a>的缩写：
</p>

<pre class="grammar">
"var" 标识符列表 = 表达式列表 .
</pre>

<pre>
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() 返回一对相关连的文件，若存在错误同样也会返回
_, y, _ := coord(p)  // coord() 返回三个值；只关心与和 y 同位的值
</pre>

<div class="english">
<p>
Unlike regular variable declarations, a short variable declaration may <i>redeclare</i>
variables provided they were originally declared earlier in the same block
(or the parameter lists if the block is the function body) with the same type,
and at least one of the non-<a href="#Blank_identifier">blank</a> variables is new.
As a consequence, redeclaration can only appear in a multi-variable short declaration.
Redeclaration does not introduce a new variable; it just assigns a new value to the original.
</p>

<pre>
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
a, a := 1, 2                              // illegal: double declaration of a or no new variable if a was declared elsewhere
</pre>
</div>

<p>
不同于常规变量声明，在至少有一个非<a href="#Blank_identifier">空白</a>变量时，
短变量声明可在相同块中（若块为函数体则为形参列表），对原先声明的变量以相同的类型<b>重声明</b>。
因此，重声明只能出现在多变量短声明中。重声明不会引入新的变量；它只能赋予新的值给原来的变量。
</p>

<pre>
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // 重声明 offset
a, a := 1, 2                              // 非法：重复声明了 a，或者若 a 在别处声明，但此处没有新的变量
</pre>

<div class="english">
<p>
Short variable declarations may appear only inside functions.
In some contexts such as the initializers for
<a href="#If_statements">"if"</a>,
<a href="#For_statements">"for"</a>, or
<a href="#Switch_statements">"switch"</a> statements,
they can be used to declare local temporary variables.
</p>
</div>

<p>
短变量声明只能出现在函数内部。在某些情况下，例如初始化 <a href="#If语句">if</a>、
<a href="#For语句">for</a>、或 <a href="#Switch语句">switch</a> 语句时，
它们可用来声明局部临时变量。
</p>

<div class="english">
<h3 id="Function_declarations">Function declarations</h3>
</div>

<h3 id="函数声明">函数声明</h3>

<div class="english">
<p>
A function declaration binds an identifier, the <i>function name</i>,
to a function.
</p>

<pre class="ebnf">
FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
FunctionName = identifier .
FunctionBody = Block .
</pre>
</div>

<p>
函数声明将标识符，即<b>函数名</b>绑定至函数。
</p>

<pre class="ebnf">
函数声明 = "func" 函数名 ( 函数 | 签名 ) .
函数名  = 标识符 .
函数    = 签名 函数体 .
函数体  = 块 .

</pre>

<div class="english">
<p>
If the function's <a href="#Function_types">signature</a> declares
result parameters, the function body's statement list must end in
a <a href="#Terminating_statements">terminating statement</a>.
</p>

<pre>
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// invalid: missing return statement
}
</pre>
</div>

<p>
若函数的<a href="#函数类型">签名</a>声明了结果参数，那么函数体的语句列表必须以
<a href="#终止语句">终止语句</a>结束。
</p>

<pre>
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// 无效：缺少返回语句
}
</pre>

<div class="english">
<p>
A function declaration may omit the body. Such a declaration provides the
signature for a function implemented outside Go, such as an assembly routine.
</p>

<pre>
func min(x int, y int) int {
	if x &lt; y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // implemented externally
</pre>
</div>

<p>
函数声明可省略函数体。这样的标识符为 Go 外部实现的函数提供签名，例如汇编例程。
</p>

<pre>
func min(x int, y int) int {
	if x &lt; y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // 外部实现
</pre>

<div class="english">
<h3 id="Method_declarations">Method declarations</h3>
</div>

<h3 id="方法声明">方法声明</h3>

<div class="english">
<p>
A method is a <a href="#Function_declarations">function</a> with a <i>receiver</i>.
A method declaration binds an identifier, the <i>method name</i>, to a method,
and associates the method with the receiver's <i>base type</i>.
</p>

<pre class="ebnf">
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
Receiver   = Parameters .
</pre>
</div>

<p>
方法为带<b>接收者</b>的<a href="#函数声明">函数</a>。方法声明将标识符，即<b>方法名</b>绑定至方法，
并将该接收者的<b>基础类型</b>关联至该方法。
</p>

<pre class="ebnf">
方法声明 = "func" 接收者 方法名 签名 [ 函数体 ] .
接收者   = 形参 .
</pre>

<div class="english">
<p>
The receiver is specified via an extra parameter section preceding the method
name. That parameter section must declare a single non-variadic parameter, the receiver.
Its type must be a <a href="#Type_definitions">defined</a> type <code>T</code> or a
pointer to a defined type <code>T</code>. <code>T</code> is called the receiver
<i>base type</i>. A receiver base type cannot be a pointer or interface type and
it must be defined in the same package as the method.
The method is said to be <i>bound</i> to its receiver base type and the method name
is visible only within <a href="#Selectors">selectors</a> for type <code>T</code>
or <code>*T</code>.
</p>
</div>

<p>
接收者通过方法名之前额外的形参部分指定。该形参部分必须声明为单个非可变形参，即接收者。
其类型形式必须为 <code>T</code> 或 <code>*T</code>（可能使用括号），其中 <code>T</code> 为类型名。
由 <code>T</code> 表示的类型称为接收者的<b>基础类型</b>；
它不能为指针或接口类型且必须在同一包中声明为方法。
也就是说，该方法被<b>绑定</b>至基础类型，且该方法名只对类型 <code>T</code>
或 <code>*T</code> 的<a href="#选择器">选择器</a>可见。
</p>

<div class="english">
<p>
A non-<a href="#Blank_identifier">blank</a> receiver identifier must be
<a href="#Uniqueness_of_identifiers">unique</a> in the method signature.
If the receiver's value is not referenced inside the body of the method,
its identifier may be omitted in the declaration. The same applies in
general to parameters of functions and methods.
</p>

<p>
For a base type, the non-blank names of methods bound to it must be unique.
If the base type is a <a href="#Struct_types">struct type</a>,
the non-blank method and field names must be distinct.
</p>
</div>

<p>
非<a href="#空白标识符">空白</a>接收器的标识符在该方法签名中必须是唯一的。
若该接收器的值并未在该方法体中引用，其标识符可在声明中省略。这同样适用于一般函数或方法的形参。
</p>

<p>
对于基础类型，方法绑定至该类型的非空白名称必须唯一。
若其基础类型为<a href="#结构体类型">结构体类型</a>，则非空白方法与字段名不能相同。
</p>

<div class="english">
<p>
Given defined type <code>Point</code>, the declarations
</p>
</div>

<p>
给定定义的类型 <code>Point</code>，声明
</p>

<pre>
func (p *Point) Length() float64 {
	return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
	p.x *= factor
	p.y *= factor
}
</pre>

<div class="english">
<p>
bind the methods <code>Length</code> and <code>Scale</code>,
with receiver type <code>*Point</code>,
to the base type <code>Point</code>.
</p>
</div>

<p>
将接收者类型为 <code>*Point</code> 的方法 <code>Length</code>
和 <code>Scale</code> 绑定至基础类型 <code>Point</code>。
</p>

<div class="english">
<p>
The type of a method is the type of a function with the receiver as first
argument.  For instance, the method <code>Scale</code> has type
</p>
</div>

<p>
方法的类型就是将接收者作为第一个实参的函数类型。例如，方法 <code>Scale</code> 拥有类型
</p>

<pre>
func(p *Point, factor float64)
</pre>

<div class="english">
<p>
However, a function declared this way is not a method.
</p>
</div>

<p>
然而，通过这种方式声明的函数不是方法。
</p>


<div class="english">
<h2 id="Expressions">Expressions</h2>
</div>

<h2 id="表达式">表达式</h2>

<div class="english">
<p>
An expression specifies the computation of a value by applying
operators and functions to operands.
</p>
</div>

<p>
表达式通过将运算符和函数应用至操作数来指定值的计算。
</p>

<div class="english">
<h3 id="Operands">Operands</h3>
</div>

<h3 id="操作数">操作数</h3>

<div class="english">
<p>
Operands denote the elementary values in an expression. An operand may be a
literal, a (possibly <a href="#Qualified_identifiers">qualified</a>)
non-<a href="#Blank_identifier">blank</a> identifier denoting a
<a href="#Constant_declarations">constant</a>,
<a href="#Variable_declarations">variable</a>, or
<a href="#Function_declarations">function</a>,
or a parenthesized expression.
</p>

<p>
The <a href="#Blank_identifier">blank identifier</a> may appear as an
operand only on the left-hand side of an <a href="#Assignments">assignment</a>.
</p>

<pre class="ebnf">
Operand     = Literal | OperandName | "(" Expression ")" .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent.
</pre>
</div>

<p>
操作数表示表达式中的基本值。操作数可为字面，（可能为<a href="#限定标识符">限定的</a>）
非<a href="#空白标识符">空白</a>标识符可表示一个<a href="#常量声明">常量</a>、<a href="#变量声明">变量</a>或<a href="#函数声明">函数</a>，
<a href="#方法表达式">方法表达式</a>可产生函数或者括号表达式。
</p>

<p>
The <a href="#空白标识符">空白标识符</a>作为操作数时仅能出现在<a href="#赋值">赋值</a>的左边。
</p>

<pre class="ebnf">
操作数   = 字面 | 操作数名 | 方法表达式 | "(" 表达式 ")" .
字面     = 基本字面 | 复合字面 | 函数字面 .
基本字面 = 整数字面 | 浮点数字面 | 虚数字面 | 符文字面 | 字符串字面 .
操作数名 = 标识符 | 限定标识符.
</pre>


<div class="english">
<h3 id="Qualified_identifiers">Qualified identifiers</h3>
</div>

<h3 id="限定标识符">限定标识符</h3>

<div class="english">
<p>
A qualified identifier is an identifier qualified with a package name prefix.
Both the package name and the identifier must not be
<a href="#Blank_identifier">blank</a>.
</p>

<pre class="ebnf">
QualifiedIdent = PackageName "." identifier .
</pre>
</div>

<p>

限定标识符为使用包名前缀限定的标识符。包名与标识符均不能为<a href="#空白标识符">空白的</a>。
</p>

<pre class="ebnf">
限定标识符 = 包名 "." 标识符 .
</pre>

<div class="english">
<p>
A qualified identifier accesses an identifier in a different package, which
must be <a href="#Import_declarations">imported</a>.
The identifier must be <a href="#Exported_identifiers">exported</a> and
declared in the <a href="#Blocks">package block</a> of that package.
</p>

<pre>
math.Sin	// denotes the Sin function in package math
</pre>
</div>

<p>
限定标识符用于访问另一个包中的标识符，它必须被<a href="#导入声明">导入</a>。
标识符必须是已<a href="#可导出标识符">导出</a>且在该包的<a href="#块">包块</a>中声明。
</p>

<pre>
math.Sin	// 表示 math 包中的 Sin 函数
</pre>

<div class="english">
<h3 id="Composite_literals">Composite literals</h3>
</div>

<h3 id="复合字面">复合字面</h3>

<div class="english">
<p>
Composite literals construct values for structs, arrays, slices, and maps
and create a new value each time they are evaluated.
They consist of the type of the literal followed by a brace-bound list of elements.
Each element may optionally be preceded by a corresponding key.
</p>

<pre class="ebnf">
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = KeyedElement { "," KeyedElement } .
KeyedElement  = [ Key ":" ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
</pre>
</div>

<p>
复合字面每当为结构体、数组、切片、映射构造值，或创建一个新值时，它们都会被求值。
它们由字面的类型后跟一个大括号括住的元素列表组成。每个元素前面可选一个对应的键。
</p>

<pre class="ebnf">
复合字面 = 字面类型 字面值 .
字面类型 = 结构体类型 | 数组类型 | "[" "..." "]" 元素类型 |
          切片类型 | 映射类型 | 类型名 .
字面值   = "{" [ 元素列表 [ "," ] ] "}" .
元素列表 = 带键元素 { "," 带键元素 } .
带键元素 = [ 键 ":" ] 元素 .
键       = 字段名 | 表达式 | 字面值 .
字段名   = 标识符 .
元素     = 表达式 | 字面值 .
</pre>

<div class="english">
<p>
The LiteralType's underlying type must be a struct, array, slice, or map type
(the grammar enforces this constraint except when the type is given
as a TypeName).
The types of the elements and keys must be <a href="#Assignability">assignable</a>
to the respective field, element, and key types of the literal type;
there is no additional conversion.
The key is interpreted as a field name for struct literals,
an index for array and slice literals, and a key for map literals.
For map literals, all elements must have a key. It is an error
to specify multiple elements with the same field name or
constant key value. For non-constant map keys, see the section on
<a href="#Order_of_evaluation">evaluation order</a>.
</p>
</div>

<p>
字面类型的底层类型必须为结构体、数组、切片或映射类型（语法规则强制实施此约束，除非该类型作为类型名给定）。
元素和键的类型对于其各自的字段、元素以及该字面类型的键类型必须为<a href="#可赋值性">可赋值</a>的，
它们没有附加的转换。作为结构体字面的字段名，即数组和切片的下标以及映射字面的键，其键是可解译的。
对于映射字面，所有元素都必须有键。指定多个具有相同字段名或常量键值的元素会产生一个错误。对于非常量映射键，见<a href="#求值顺序">求值顺序</a>一节。
</p>

<div class="english">
<p>
For struct literals the following rules apply:
</p>
<ul>
	<li>A key must be a field name declared in the struct type.
	</li>
	<li>An element list that does not contain any keys must
	    list an element for each struct field in the
	    order in which the fields are declared.
	</li>
	<li>If any element has a key, every element must have a key.
	</li>
	<li>An element list that contains keys does not need to
	    have an element for each struct field. Omitted fields
	    get the zero value for that field.
	</li>
	<li>A literal may omit the element list; such a literal evaluates
	    to the zero value for its type.
	</li>
	<li>It is an error to specify an element for a non-exported
	    field of a struct belonging to a different package.
	</li>
</ul>
</div>

<p>
以下规则适用于结构体字面：
</p>

<ul>
	<li>键必须为结构体类型中声明的字段名。</li>

	<li>不包含任何键的元素列表必须按字段的声明顺序列出每个结构体字段的元素。</li>

	<li>若其中任何一个元素有键，那么每个元素都必须有键。</li>

	<li>包含键的元素列表无需每个结构体字段都有元素。被忽略的字段会获得零值</li>

	<li>字面可忽略元素列表；这样的字面对其类型求值为零值。</li>

	<li>为属于不同包的结构体的未导出字段指定一个元素会产生一个错误。</li>
</ul>

<div class="english">
<p>
Given the declarations
</p>
</div>

<p>
给定声明
</p>

<pre>
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
</pre>

<div class="english">
<p>
one may write
</p>

<pre>
origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
</pre>
</div>

<p>
可写为
</p>

<pre>
origin := Point3D{}                            // Point3D 为零值
line := Line{origin, Point3D{y: -4, z: 12.3}}  // line.q.x 为零值
</pre>

<div class="english">
<p>
For array and slice literals the following rules apply:
</p>
<ul>
	<li>Each element has an associated integer index marking
	    its position in the array.
	</li>
	<li>An element with a key uses the key as its index. The
	    key must be a non-negative constant
	    <a href="#Representability">representable</a> by
	    a value of type <code>int</code>; and if it is typed
	    it must be of integer type.
	</li>
	<li>An element without a key uses the previous element's index plus one.
	    If the first element has no key, its index is zero.
	</li>
</ul>
</div>

<p>
以下规则适用于数组和切片字面：
</p>

<ul>
	<li>在数组中每个元素都有与之对应的整数下标来标明它的位置。</li>

	<li>带键的元素使用该键作为它的下标；键必须为常量整数表达式。</li>

	<li>无键的元素使用上一个元素的下标加一。若第一个元素无键，则它的下标为零。</li>
</ul>

<div class="english">
<p>
Taking the address of a composite literal (§<a href="#Address_operators">Address operators</a>)
generates a pointer to a unique instance of the literal's value.
</p>

<p>
<a href="#Address_operators">Taking the address</a> of a composite literal
generates a pointer to a unique <a href="#Variables">variable</a> initialized
with the literal's value.
</p>
</div>

<p>
对复合字面<a href="#地址操作符">取址</a>会得到唯一的，以该字面值初始化的变量的指针。
</p>

<pre>
var pointer *Point3D = &amp;Point3D{y: 1000}
</pre>

<div class="english">
<p>
Note that the <a href="#The_zero_value">zero value</a> for a slice or map
type is not the same as an initialized but empty value of the same type.
Consequently, taking the address of an empty slice or map composite literal
does not have the same effect as allocating a new slice or map value with
<a href="#Allocation">new</a>.
</p>

<pre>
p1 := &[]int{}    // p1 points to an initialized, empty slice with value []int{} and length 0
p2 := new([]int)  // p2 points to an uninitialized slice with value nil and length 0
</pre>

<p>
The length of an array literal is the length specified in the literal type.
If fewer elements than the length are provided in the literal, the missing
elements are set to the zero value for the array element type.
It is an error to provide elements with index values outside the index range
of the array. The notation <code>...</code> specifies an array length equal
to the maximum element index plus one.
</p>
</div>

<p>
数组字面的长度为字面类型指定的长度。
若元素少于字面提供的长度，则缺失的元素会置为该数组元素类型的零值。
向超出数组下标范围的下标值提供元素会产生一个错误。
记法 <code>...</code> 指定一个数组，其长度等于最大元素下标加一。
</p>

<pre>
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
</pre>

<div class="english">
<p>
A slice literal describes the entire underlying array literal.
Thus the length and capacity of a slice literal are the maximum
element index plus one. A slice literal has the form
</p>
</div>

<p>
切片字面描述全部的底层数组字面。因此，切片字面的长度和容量为其最大元素下标加一。切片字面具有形式
</p>

<pre>
[]T{x1, x2, … xn}
</pre>

<div class="english">
<p>
and is shorthand for a slice operation applied to an array:
</p>
</div>

<p>
它是切片操作应用到数组的捷径。
</p>

<pre>
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]
</pre>

<div class="english">
<p>
Within a composite literal of array, slice, or map type <code>T</code>,
elements or map keys that are themselves composite literals may elide the respective
literal type if it is identical to the element or key type of <code>T</code>.
Similarly, elements or keys that are addresses of composite literals may elide
the <code>&amp;T</code> when the element or key type is <code>*T</code>.
</p>

<pre>
[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&amp;Point{1.5, -3.5}, &amp;Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&amp;Point{1.5, -3.5}), PPoint(&amp;Point{})}
</pre>
</div>

<p>
在数组、切片或映射类型 <code>T</code> 的复合字面中，若其元素或键本身亦为复合字面，
且该复合字面的元素类型与 <code>T</code> 的相同，则可省略其各自的元素或映射类型。
类似地，当元素或键类型为 <code>*T</code> 时，若其元素或键为复合字面的地址，则可省略 <code>&amp;T</code>。
</p>

<pre>
[...]Point{{1.5, -3.5}, {0, 0}}   // 等价于 [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}        // 等价于 [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}       // 等价于 [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}  // 等价于 map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}  // 等价于 map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}        // 等价于 [2]*Point{&amp;Point{1.5, -3.5}, &amp;Point{}}
[2]PPoint{{1.5, -3.5}, {}}        // 等价于 [2]PPoint{PPoint(&amp;Point{1.5, -3.5}), PPoint(&amp;Point{})}
</pre>

<div class="english">
<p>
A parsing ambiguity arises when a composite literal using the
TypeName form of the LiteralType appears as an operand between the
<a href="#Keywords">keyword</a> and the opening brace of the block
of an "if", "for", or "switch" statement, and the composite literal
is not enclosed in parentheses, square brackets, or curly braces.
In this rare case, the opening brace of the literal is erroneously parsed
as the one introducing the block of statements. To resolve the ambiguity,
the composite literal must appear within parentheses.
</p>
</div>

<p>
当复合字面使用字面类型的类型名形式时，若它作为操作数出现在<a href="#关键字">关键字</a>
"if"、"for" 或 "switch" 语句及其对应块的开大括号之间，且该复合字面未在小括号、中括号或大括号内，
那么就会产生解析歧义。在这种罕见情况下，该字面的开大括号会被错误地解析为引入语句块的符号。
为解决这种歧义，该复合字面必须出现在小括号中。
</p>

<pre>
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
</pre>

<div class="english">
<p>
Examples of valid array, slice, and map literals:
</p>

<pre>
// list of prime numbers
primes := []int{2, 3, 5, 7, 9, 2147483647}

// vowels[ch] is true if ch is a vowel
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// frequencies in Hz for equal-tempered scale (A4 = 440Hz)
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
</pre>
</div>

<p>
有效的数组、切片和映射字面的例子：
</p>

<pre>
// 素数列表
primes := []int{2, 3, 5, 7, 9, 2147483647}

// 若 ch 为元音则 vowels[ch] 为 true
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// 数组 [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// 平均律以 Hz 为单位的频率（A4 = 440Hz）
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
</pre>


<div class="english">
<h3 id="Function_literals">Function literals</h3>
</div>

<h3 id="函数字面">函数字面</h3>

<div class="english">
<p>
A function literal represents an anonymous <a href="#Function_declarations">function</a>.
</p>

<pre class="ebnf">
FunctionLit = "func" Signature FunctionBody .
</pre>
</div>

<p>
函数字面表示一个匿名<a href="#函数声明">函数</a>。
</p>

<pre class="ebnf">
函数字面 =  "func" 函数 .
</pre>

<pre>
func(a, b int, z float64) bool { return a*b &lt; int(z) }
</pre>

<div class="english">
<p>
A function literal can be assigned to a variable or invoked directly.
</p>
</div>

<p>
函数字面可赋予一个变量或直接调用。
</p>

<pre>
f := func(x, y int) int { return x + y }
func(ch chan int) { ch &lt;- ACK }(replyChan)
</pre>

<div class="english">
<p>
Function literals are <i>closures</i>: they may refer to variables
defined in a surrounding function. Those variables are then shared between
the surrounding function and the function literal, and they survive as long
as they are accessible.
</p>
</div>

<p>
<b>闭包</b>的函数字面：它们可引用定义在外围函数中的变量。
那些变量共享于外围函数与函数字面之间，并且只要它们可访问就会继续存在。
</p>


<div class="english">
<h3 id="Primary_expressions">Primary expressions</h3>
</div>

<h3 id="主表达式">主表达式</h3>

<div class="english">
<p>
Primary expressions are the operands for unary and binary expressions.
</p>

<pre class="ebnf">
PrimaryExpr =
	Operand |
	Conversion |
	MethodExpr |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Arguments .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
                 "[" [ Expression ] ":" Expression ":" Expression "]" .
TypeAssertion  = "." "(" Type ")" .
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
</pre>
</div>

<p>
主表达式为一元和二元表达式的操作数。
</p>

<pre class="ebnf">
主表达式 =
	操作数 |
	类型转换 |
	主表达式 选择器 |
	主表达式 下标 |
	主表达式 切片 |
	主表达式 类型断言 |
	主表达式 实参 .

选择器   = "." 标识符 .
下标     = "[" 表达式 "]" .
切片     = "[" [ 表达式 ] ":" [ 表达式 ] "]" |
           "[" [ 表达式 ] ":" 表达式 ":" 表达式 "]" .
类型断言 = "." "(" 类型 ")" .
实参     = "(" [ ( 表达式列表 | 类型 [ "," 表达式列表 ] ) [ "..." ] [ "," ] ] ")" .
</pre>

<pre>
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()
</pre>


<div class="english">
<h3 id="Selectors">Selectors</h3>
</div>

<h3 id="选择器">选择器</h3>

<div class="english">
<p>
For a <a href="#Primary_expressions">primary expression</a> <code>x</code>
that is not a <a href="#Package_clause">package name</a>, the
<i>selector expression</i>
</p>
</div>

<p>
对于不为<a href="#包子句">包名</a>的<a href="#主表达式">主表达式</a> <code>x</code>，
<b>选择其表达式</b>
</p>

<pre>
x.f
</pre>

<div class="english">
<p>
denotes the field or method <code>f</code> of the value <code>x</code>
(or sometimes <code>*x</code>; see below).
The identifier <code>f</code> is called the (field or method) <i>selector</i>;
it must not be the <a href="#Blank_identifier">blank identifier</a>.
The type of the selector expression is the type of <code>f</code>.
If <code>x</code> is a package name, see the section on
<a href="#Qualified_identifiers">qualified identifiers</a>.
</p>
</div>

<p>
表示值 <code>x</code>（有时为 <code>*x</code>，见下）的字段或方法 <code>f</code>。
标识符 <code>f</code> 称为（字段或方法）<b>选择器</b>，它不能为<a href="#空白标识符">空白标识符</a>。
该选择器表达式的类型即为 <code>f</code> 的类型。若 <code>x</code> 为包名，
见<a href="#限定标识符">限定标识符</a>的相关章节。
</p>

<div class="english">
<p>
A selector <code>f</code> may denote a field or method <code>f</code> of
a type <code>T</code>, or it may refer
to a field or method <code>f</code> of a nested
<a href="#Struct_types">embedded field</a> of <code>T</code>.
The number of embedded fields traversed
to reach <code>f</code> is called its <i>depth</i> in <code>T</code>.
The depth of a field or method <code>f</code>
declared in <code>T</code> is zero.
The depth of a field or method <code>f</code> declared in
an embedded field <code>A</code> in <code>T</code> is the
depth of <code>f</code> in <code>A</code> plus one.
</p>
</div>

<p>
选择器 <code>f</code> 可代表类型为 <code>T</code> 的字段或方法 <code>f</code>，
或引用 <code>T</code> 中嵌套<a href="#结构体类型">匿名字段</a>的字段或方法 <code>f</code>。
在 <code>T</code> 中遍历区域 <code>f</code> 的匿名字段所得的数量称为它的<b>深度</b>。
以 <code>T</code> 声明的字段或方法 <code>f</code> 的深度为 0。
在 <code>T</code> 中以匿名字段 <code>A</code> 声明的字段或方法 <code>f</code> 的深度
为 <code>f</code> 在 <code>A</code> 中的深度加 1。
</p>

<div class="english">
<p>
The following rules apply to selectors:
</p>

<ol>
<li>
For a value <code>x</code> of type <code>T</code> or <code>*T</code>
where <code>T</code> is not a pointer or interface type,
<code>x.f</code> denotes the field or method at the shallowest depth
in <code>T</code> where there
is such an <code>f</code>.
If there is not exactly <a href="#Uniqueness_of_identifiers">one <code>f</code></a>
with shallowest depth, the selector expression is illegal.
</li>

<li>
For a value <code>x</code> of type <code>I</code> where <code>I</code>
is an interface type, <code>x.f</code> denotes the actual method with name
<code>f</code> of the dynamic value of <code>x</code>.
If there is no method with name <code>f</code> in the
<a href="#Method_sets">method set</a> of <code>I</code>, the selector
expression is illegal.
</li>

<li>
As an exception, if the type of <code>x</code> is a <a href="#Type_definitions">defined</a>
pointer type and <code>(*x).f</code> is a valid selector expression denoting a field
(but not a method), <code>x.f</code> is shorthand for <code>(*x).f</code>.
</li>

<li>
In all other cases, <code>x.f</code> is illegal.
</li>

<li>
If <code>x</code> is of pointer type and has the value
<code>nil</code> and <code>x.f</code> denotes a struct field,
assigning to or evaluating <code>x.f</code>
causes a <a href="#Run_time_panics">run-time panic</a>.
</li>

<li>
If <code>x</code> is of interface type and has the value
<code>nil</code>, <a href="#Calls">calling</a> or
<a href="#Method_values">evaluating</a> the method <code>x.f</code>
causes a <a href="#Run_time_panics">run-time panic</a>.
</li>
</ol>
</div>

<p>
以下规则适用于选择器：
</p>

<ol>
<li>
当 <code>T</code> 为非指针或接口类型时，对于类型 <code>T</code> 或 <code>*T</code>
的值 <code>x</code>，<code>x.f</code> 中的 <code>f</code> 表示在 <code>T</code>
中最浅深度的字段或方法。若<code>f</code>并非<a href="#标识符的唯一性">只有一个</a>，
该选择器表达式即为非法的。
</li>
<li>
对于接口类型 <code>I</code> 的值 <code>x</code>，<code>x.f</code> 表示
<code>x</code> 的动态值的名为 <code>f</code> 的真实方法。若在 <code>I</code>
的<a href="#方法集">方法集</a>中没有名为 <code>f</code> 的方法，该选择器即为非法的。
</li>
<li>
As an exception, if the type of <code>x</code> is a named pointer type
and <code>(*x).f</code> is a valid selector expression denoting a field
(but not a method), <code>x.f</code> is shorthand for <code>(*x).f</code>.
</li>
<li>
其它情况下，所有 <code>x.f</code> 均为非法的。
</li>
<li>
若 <code>x</code> 为指针类型且值为 <code>nil</code> 且 <code>x.f</code>
表示一个结构体字段，对 <code>x.f</code> 进行赋值或求值会产生<a href="#运行时恐慌">运行时恐慌</a>。
</li>
<li>
If <code>x</code> is of interface type and has the value
<code>nil</code>, <a href="#Calls">calling</a> or
<a href="#Method_values">evaluating</a> the method <code>x.f</code>
causes a <a href="#Run_time_panics">run-time panic</a>.
</li>
</ol>

<div class="english">
<p>
For example, given the declarations:
</p>

<pre>
type T0 struct {
	x int
}

func (*T0) M0()

type T1 struct {
	y int
}

func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (*T2) M2()

type Q *T2

var t T2     // with t.T0 != nil
var p *T2    // with p != nil and (*p).T0 != nil
var q Q = p
</pre>
</div>

<p>
例如，给定声明：
</p>

<pre>
type T0 struct {
	x int
}

func (*T0) M0()

type T1 struct {
	y int
}

func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (*T2) M2()

type Q *T2

var t T2     // 其中 t.T0 != nil
var p *T2    // 其中 p != nil 且 (*p).T0 != nil
var q Q = p
</pre>

<div class="english">
<p>
one may write:
</p>

<pre>
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x is a valid field selector

p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver
p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver
p.M2()       // p.M2()              M2 expects *T2 receiver
t.M2()       // (&amp;t).M2()           M2 expects *T2 receiver, see section on Calls
</pre>
</div>

<p>
可以写：
</p>

<pre>
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x 是有效的字段选择器

p.M0()       // ((*p).T0).M0()      M0 期望 *T0 接收者
p.M1()       // ((*p).T1).M1()      M1 期望 T1 接收者
p.M2()       // p.M2()              M2 期望 *T2 接收者
t.M2()       // (&amp;t).M2()           M2 期望 *T2 接收者，见“调用”一节
</pre>

<div class="english">
<p>
but the following is invalid:
</p>

<pre>
q.M0()       // (*q).M0 is valid but not a field selector
</pre>
</div>

<p>
但以下是无效的：
</p>

<pre>
q.M0()       // (*q).M0 有效但并非字段选择器
</pre>


<div class="english">
<h3 id="Method_expressions">Method expressions</h3>
</div>

<h3 id="方法表达式">方法表达式</h3>

<div class="english">
<p>
If <code>M</code> is in the <a href="#Method_sets">method set</a> of type <code>T</code>,
<code>T.M</code> is a function that is callable as a regular function
with the same arguments as <code>M</code> prefixed by an additional
argument that is the receiver of the method.
</p>

<pre class="ebnf">
MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = Type .
</pre>
</div>

<p>
若方法 <code>M</code> 在类型 <code>T</code> 的<a href="#方法集">方法集</a>中，
那么 <code>T.M</code> 是可以像常规函数一样调用的函数，它通过与 <code>M</code>
前缀的附加实参相同的实参调用，该实参即为该方法的接收者。
</p>

<pre class="ebnf">
方法表达式  = 接收者类型 "." 方法名 .
接收者类型  = 类型名 | "(" "*" 类型名 ")" | "(" 接收者类型 ")" .
</pre>

<div class="english">
<p>
Consider a struct type <code>T</code> with two methods,
<code>Mv</code>, whose receiver is of type <code>T</code>, and
<code>Mp</code>, whose receiver is of type <code>*T</code>.
</p>

<pre>
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
</pre>
</div>

<p>
考虑结构体类型 <code>T</code>，它带有两个方法：<code>Mv</code> 的接收者类型为
<code>T</code>，以及 <code>Mp</code> 的接收者类型为 <code>*T</code>。
</p>

<pre>
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // 值接收者
func (tp *T) Mp(f float32) float32 { return 1 }  // 指针接收者

var t T
</pre>

<div class="english">
<p>
The expression
</p>

<pre>
T.Mv
</pre>

<p>
yields a function equivalent to <code>Mv</code> but
with an explicit receiver as its first argument; it has signature
</p>

<pre>
func(tv T, a int) int
</pre>

<p>
That function may be called normally with an explicit receiver, so
these five invocations are equivalent:
</p>

<pre>
t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
</pre>
</div>

<p>
表达式
</p>

<pre>
T.Mv
</pre>

<p>
会产生一个等价于 <code>Mv</code> 的方法，不过它带有显式的接收者作为其第一个实参。
它的签名为
</p>

<pre>
func(tv T, a int) int
</pre>

<p>
该函数可通过显式的接收者正常调用，因此以下五种调用法是等价的：
</p>

<pre>
t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
</pre>

<div class="english">
<p>
Similarly, the expression
</p>

<pre>
(*T).Mp
</pre>

<p>
yields a function value representing <code>Mp</code> with signature
</p>

<pre>
func(tp *T, f float32) float32
</pre>
</div>

<p>
同样，表达式
</p>

<pre>
(*T).Mp
</pre>

<p>
会产生一个表示 <code>Mp</code>的函数值，其签名为
</p>

<pre>
func(tp *T, f float32) float32
</pre>

<div class="english">
<p>
For a method with a value receiver, one can derive a function
with an explicit pointer receiver, so
</p>

<pre>
(*T).Mv
</pre>

<p>
yields a function value representing <code>Mv</code> with signature
</p>

<pre>
func(tv *T, a int) int
</pre>
</div>

<p>
对于带有值接收者的方法，它可导出一个带显式指针接收者的函数，因此
</p>

<pre>
(*T).Mv
</pre>

<p>
会产生一个表示 <code>Mv</code>的函数值，其签名为
</p>

<pre>
func(tv *T, a int) int
</pre>

<div class="english">
<p>
Such a function indirects through the receiver to create a value
to pass as the receiver to the underlying method;
the method does not overwrite the value whose address is passed in
the function call.
</p>
</div>

<p>
这样的函数通过接收者间接创建了一个值来通过接收者传给底层方法；
该方法并不会覆盖在函数调用中传递地址的值。
</p>

<div class="english">
<p>
The final case, a value-receiver function for a pointer-receiver method,
is illegal because pointer-receiver methods are not in the method set
of the value type.
</p>
</div>

<p>
最后一种情况，“值-接收者”函数对于“指针-接收者”方法来说是非法的，
因为“指针-接收者”方法并不在值类型的方法集中。
</p>

<div class="english">
<p>
Function values derived from methods are called with function call syntax;
the receiver is provided as the first argument to the call.
That is, given <code>f := T.Mv</code>, <code>f</code> is invoked
as <code>f(t, 7)</code> not <code>t.f(7)</code>.
To construct a function that binds the receiver, use a
<a href="#Function_literals">function literal</a> or
<a href="#Method_values">method value</a>.
</p>
</div>

<p>
由方法导出的函数值通过函数调用方法调用，接收者作为该调用的第一个实参。
即，给定 <code>f := T.Mv</code>，<code>f</code> 会作为 <code>f(t, 7)</code>
而非 <code>t.f(7)</code> 调用。要构造一个绑定了接收者的函数，应使用
<a href="#函数字面">函数字面</a>或<a href="#方法值">方法值</a>。
</p>

<div class="english">
<p>
It is legal to derive a function value from a method of an interface type.
The resulting function takes an explicit receiver of that interface type.
</p>
</div>

<p>
从一个接口类型的方法导出函数值是合法的，其结果函数接受一个显式的该接口类型的接收者。
</p>

<div class="english">
<h3 id="Method_values">Method values</h3>
</div>

<h3 id="方法值">方法值</h3>

<div class="english">
<p>
If the expression <code>x</code> has static type <code>T</code> and
<code>M</code> is in the <a href="#Method_sets">method set</a> of type <code>T</code>,
<code>x.M</code> is called a <i>method value</i>.
The method value <code>x.M</code> is a function value that is callable
with the same arguments as a method call of <code>x.M</code>.
The expression <code>x</code> is evaluated and saved during the evaluation of the
method value; the saved copy is then used as the receiver in any calls,
which may be executed later.
</p>
</div>

<p>
若表达式 <code>x</code> 拥有静态类型 <code>T</code> 且 <code>M</code>
在类型 <code>T</code> 的<a href="#方法集">方法集</a>中，那么 <code>x.M</code>
就称作<b>方法值</b>。方法值 <code>x.M</code> 是一个函数值，它能够以 <code>x.M</code>
方法调用的参数作为实参调用。表达式 <code>x</code> 在方法值求值时被调用并保存。
之后保存的副本可在任何调用中被用作接收者，它可以之后再执行。
</p>

<div class="english">
<p>
The type <code>T</code> may be an interface or non-interface type.
</p>
</div>

<p>
类型 <code>T</code> 可为接口或非接口类型。
</p>

<div class="english">
<p>
As in the discussion of <a href="#Method_expressions">method expressions</a> above,
consider a struct type <code>T</code> with two methods,
<code>Mv</code>, whose receiver is of type <code>T</code>, and
<code>Mp</code>, whose receiver is of type <code>*T</code>.
</p>
</div>

<p>
如之前<a href="#方法表达式">方法表达式</a>的讨论中那样，考虑一个结构体类型
<code>T</code>，它有两个方法：<code>Mv</code> 接收者类型为 <code>T</code>，以及
<code>Mp</code> 接收者类型为 <code>*T</code>。
</p>

<div class="english">
<pre>
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
var pt *T
func makeT() T
</pre>
</div>

<pre>
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // 值接收者
func (tp *T) Mp(f float32) float32 { return 1 }  // 指针接收者

var t T
var pt *T
func makeT() T
</pre>

<div class="english">
<p>
The expression
</p>
</div>

<p>
表达式
</p>

<pre>
t.Mv
</pre>

<div class="english">
<p>
yields a function value of type
</p>
</div>

<p>
产生一个类型为
</p>

<pre>
func(int) int
</pre>

<div class="english">
<p>
These two invocations are equivalent:
</p>
</div>

<p>
的函数值。
</p>

<p>
以下两个调用是等价的：
</p>

<pre>
t.Mv(7)
f := t.Mv; f(7)
</pre>

<div class="english">
<p>
Similarly, the expression
</p>
</div>

<p>
同样，表达式
</p>

<pre>
pt.Mp
</pre>

<div class="english">
<p>
yields a function value of type
</p>
</div>

<p>
会产生一个类型为
</p>

<pre>
func(float32) float32
</pre>

<p>
的函数值。
</p>

<div class="english">
<p>
As with <a href="#Selectors">selectors</a>, a reference to a non-interface method with a value receiver
using a pointer will automatically dereference that pointer: <code>pt.Mv</code> is equivalent to <code>(*pt).Mv</code>.
</p>
</div>

<p>
对于<a href="#选择器">选择器</a>，通过指针引用非接口方法的的值接收者将自动解引用该指针：
<code>pt.Mv</code> 等价于 <code>(*pt).Mv</code>。
</p>

<div class="english">
<p>
As with <a href="#Calls">method calls</a>, a reference to a non-interface method with a pointer receiver
using an addressable value will automatically take the address of that value: <code>t.Mp</code> is equivalent to <code>(&amp;t).Mp</code>.
</p>
</div>

<p>
对于<a href="#调用">方法调用</a>，通过可寻址值引用非接口方法的指针接收者将自动获取该值的地址：
<code>t.Mp</code> 等价于 <code>(&amp;t).Mp</code>。
</p>

<div class="english">
<pre>
f := t.Mv; f(7)   // like t.Mv(7)
f := pt.Mp; f(7)  // like pt.Mp(7)
f := pt.Mv; f(7)  // like (*pt).Mv(7)
f := t.Mp; f(7)   // like (&amp;t).Mp(7)
f := makeT().Mp   // invalid: result of makeT() is not addressable
</pre>
</div>

<pre>
f := t.Mv; f(7)   // 如同 个  t.Mv(7)
f := pt.Mp; f(7)  // 如同 pt.Mp(7)
f := pt.Mv; f(7)  // 如同 (*pt).Mv(7)
f := t.Mp; f(7)   // 如同 (&amp;t).Mp(7)
f := makeT().Mp   // 无效：makeT() 的结果不可寻址
</pre>

<div class="english">
<p>
Although the examples above use non-interface types, it is also legal to create a method value
from a value of interface type.
</p>
</div>

<p>
上面的示例使用了非接口类型，然而从接口类型的值创建方法值也是合法的。
</p>

<div class="english">
<pre>
var i interface { M(int) } = myVal
f := i.M; f(7)  // like i.M(7)
</pre>
</div>

<pre>
var i interface { M(int) } = myVal
f := i.M; f(7)  // 如同 i.M(7)
</pre>

<div class="english">
<h3 id="Index_expressions">Index expressions</h3>
</div>

<h3 id="下标表达式">下标表达式</h3>

<div class="english">
<p>
A primary expression of the form
</p>
</div>

<p>
形式为
</p>

<pre>
a[x]
</pre>

<div class="english">
<p>
denotes the element of the array, pointer to array, slice, string or map <code>a</code> indexed by <code>x</code>.
The value <code>x</code> is called the <i>index</i> or <i>map key</i>, respectively.
The following rules apply:
</p>
</div>

<p>
的主表达式表示数组、数组指针、切片、字符串或映射 <code>a</code> 的元素通过 <code>x</code> 检索。
值 <code>x</code> 称为 <b>下标</b> 或 <b>映射键</b>。以下规则适用于其对应的类型：
</p>

<div class="english">
<p>
If <code>a</code> is not a map:
</p>
<ul>
	<li>the index <code>x</code> must be of integer type or an untyped constant</li>
	<li>a constant index must be non-negative and
	    <a href="#Representability">representable</a> by a value of type <code>int</code></li>
	<li>a constant index that is untyped is given type <code>int</code></li>
	<li>the index <code>x</code> is <i>in range</i> if <code>0 &lt;= x &lt; len(a)</code>,
	    otherwise it is <i>out of range</i></li>
</ul>
</div>

<p>
若 <code>a</code> 并非一个映射：
</p>
<ul>
	<li>下标 <code>x</code> 必须为整数类型或无类型化的；若 <code>0 &lt;= x &lt; len(a)</code>
		则该下标在<b>界内</b>，否则即为<b>越界</b></li>
	<li>a <a href="#常量">常量</a>下标必须为可表示成 <code>int</code> 类型的值</li>
</ul>

<div class="english">
<p>
For <code>a</code> of <a href="#Array_types">array type</a> <code>A</code>:
</p>
<ul>
	<li>a <a href="#Constants">constant</a> index must be in range</li>
	<li>if <code>x</code> is out of range at run time,
	    a <a href="#Run_time_panics">run-time panic</a> occurs</li>
	<li><code>a[x]</code> is the array element at index <code>x</code> and the type of
	    <code>a[x]</code> is the element type of <code>A</code></li>
</ul>
</div>

<p>
对于<a href="#数组类型">数组类型</a> <code>A</code> 的 <code>a</code>：
</p>
<ul>
	<li><a href="#常量">常量</a>下标必在界内</li>
	<li>若 <code>x</code> 在运行时越界，
		就会引发一个<a href="#运行时恐慌">运行时恐慌</a></li>
	<li><code>a[x]</code> 是下标为 <code>x</code> 的数组元素，且 <code>a[x]</code>
		的类型即为 <code>A</code> 的元素类型</li>
</ul>

<div class="english">
<p>
For <code>a</code> of <a href="#Pointer_types">pointer</a> to array type:
</p>
<ul>
	<li><code>a[x]</code> is shorthand for <code>(*a)[x]</code></li>
</ul>
</div>

<p>
对于数组<a href="#指针类型">指针</a>类型的 <code>a</code>：
</p>
<ul>
	<li><code>a[x]</code> 为 <code>(*a)[x]</code> 的简写</li>
</ul>

<div class="english">
<p>
For <code>a</code> of <a href="#Slice_types">slice type</a> <code>S</code>:
</p>
<ul>
	<li>if <code>x</code> is out of range at run time,
	    a <a href="#Run_time_panics">run-time panic</a> occurs</li>
	<li><code>a[x]</code> is the slice element at index <code>x</code> and the type of
	    <code>a[x]</code> is the element type of <code>S</code></li>
</ul>
</div>

<p>
对于<a href="#切片类型">切片类型</a> <code>S</code> 的 <code>a</code>：
</p>
<ul>
	<li>若 <code>x</code> 在运行时越界，
		就会引发一个<a href="#运行时恐慌">运行时恐慌</a></li>
	<li><code>a[x]</code> 是下标为 <code>x</code> 的切片元素且
		<code>a[x]</code> 的类型为 <code>S</code> 的元素类型</li>
</ul>

<div class="english">
<p>
For <code>a</code> of <a href="#String_types">string type</a>:
</p>
<ul>
	<li>a <a href="#Constants">constant</a> index must be in range
	    if the string <code>a</code> is also constant</li>
	<li>if <code>x</code> is out of range at run time,
	    a <a href="#Run_time_panics">run-time panic</a> occurs</li>
	<li><code>a[x]</code> is the non-constant byte value at index <code>x</code> and the type of
	    <code>a[x]</code> is <code>byte</code></li>
	<li><code>a[x]</code> may not be assigned to</li>
</ul>
</div>

<p>
对于<a href="#字符串类型">字符串类型</a> 的 <code>a</code>：
</p>
<ul>
	<li>若字符串 <code>a</code> 也为常量，<a href="#常量">常量</a>下标必在界内。</li>
	<li>若 <code>x</code> 超出范围，就会出现一个<a href="#运行时恐慌">运行时恐慌</a></li>
	<li><code>a[x]</code> 为下标 <code>x</code> 的非常量字节值且 <code>a[x]</code> 的类型为 <code>byte</code></li>
	<li><code>a[x]</code> 不可赋值</li>
</ul>

<div class="english">
<p>
For <code>a</code> of <a href="#Map_types">map type</a> <code>M</code>:
</p>
<ul>
	<li><code>x</code>'s type must be
	    <a href="#Assignability">assignable</a>
	    to the key type of <code>M</code></li>
	<li>if the map contains an entry with key <code>x</code>,
	    <code>a[x]</code> is the map element with key <code>x</code>
	    and the type of <code>a[x]</code> is the element type of <code>M</code></li>
	<li>if the map is <code>nil</code> or does not contain such an entry,
	    <code>a[x]</code> is the <a href="#The_zero_value">zero value</a>
	    for the element type of <code>M</code></li>
</ul>
</div>

<p>
对于<a href="#映射类型">映射类型</a> <code>M</code> 的 <code>a</code>：
</p>
<ul>
	<li><code>x</code> 的类型必须<a href="#可赋值性">可赋值</a>至 <code>M</code> 的键类型</li>
	<li>若映射包含键为 <code>x</code> 的项，则 <code>a[x]</code> 为键 <code>x</code> 的映射值，
		且 <code>a[x]</code> 的类型为 <code>M</code> 的值类型</li>
	<li>若映射为 <code>nil</code> 或不包含这样的项，
		<code>a[x]</code> 为 <code>M</code> 值类型的<a href="#零值">零值</a></li>
</ul>

<div class="english">
<p>
Otherwise <code>a[x]</code> is illegal.
</p>
</div>

<p>
否则 <code>a[x]</code> 即为非法的。
</p>

<div class="english">
<p>
An index expression on a map <code>a</code> of type <code>map[K]V</code>
used in an <a href="#Assignments">assignment</a> or initialization of the special form
</p>
</div>

<p>
在类型为 <code>map[K]V</code> 的映射 <code>a</code> 中，
下标表达式可在<a href="#赋值">赋值</a>或初始化中通过特殊形式
</p>

<pre>
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
</pre>

<div class="english">
<p>
yields an additional untyped boolean value. The value of <code>ok</code> is
<code>true</code> if the key <code>x</code> is present in the map, and
<code>false</code> otherwise.
</p>
</div>

<p>
产生一个附加的无类型化布尔值。若键 <code>x</code> 存在于映射中，则
<code>ok</code> 的值为 <code>true</code>，否则即为 <code>false</code>。
</p>

<div class="english">
<p>
Assigning to an element of a <code>nil</code> map causes a
<a href="#Run_time_panics">run-time panic</a>.
</p>
</div>

<div class="english">
<h3 id="Slice_expressions">Slice expressions</h3>
</div>

<h3 id="切片表达式">切片表达式</h3>

<div class="english">
<p>
Slice expressions construct a substring or slice from a string, array, pointer
to array, or slice. There are two variants: a simple form that specifies a low
and high bound, and a full form that also specifies a bound on the capacity.
</p>
</div>

<p>
切片表达式从一个字符串、数组、数组指针或切片中构造一个子串或切片。切片有两种变体：
简单形式指定了一个上界和下界，完整形式还指定了容量的边界。
</p>

<div class="english">
<h4>Simple slice expressions</h4>
</div>

<h4>简单切片表达式</h4>

<div class="english">
<p>
For a string, array, pointer to array, or slice <code>a</code>, the primary expression
</p>
</div>

<p>
对于字符串，数组，数组指针或切片 <code>a</code>，主表达式
</p>

<pre>
a[low : high]
</pre>

<div class="english">
<p>
constructs a substring or slice. The <i>indices</i> <code>low</code> and
<code>high</code> select which elements of operand <code>a</code> appear
in the result. The result has indices starting at 0 and length equal to
<code>high</code>&nbsp;-&nbsp;<code>low</code>.
After slicing the array <code>a</code>
</p>
</div>

<p>
会构造一个字串或切片。<b>下标</b> <code>low</code> 和 <code>high</code> 则选出操作数
<code>a</code> 中哪些元素出现在结果中。该结果的下标起始于 0 且长度等于
<code>high</code>&nbsp;-&nbsp;<code>low</code>。
在切下数组 <code>a</code>
</p>

<pre>
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
</pre>

<div class="english">
<p>
the slice <code>s</code> has type <code>[]int</code>, length 3, capacity 4, and elements
</p>
</div>

<p>
之后，切片 <code>s</code> 的类型为 <code>[]int</code>，长度为 3，容量为 4，且元素
</p>

<pre>
s[0] == 2
s[1] == 3
s[2] == 4
</pre>

<div class="english">
<p>
For convenience, any of the indices may be omitted. A missing <code>low</code>
index defaults to zero; a missing <code>high</code> index defaults to the length of the
sliced operand:
</p>

<pre>
a[2:]  // same as a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]
</pre>
</div>

<p>
为方便起见，任何下标都可省略。略去的 <code>low</code> 下标默认为零；
略去的 <code>high</code> 下标默认为已切下的操作数的长度：
</p>

<pre>
a[2:]  // 等价于 a[2 : len(a)]
a[:3]  // 等价于 a[0 : 3]
a[:]   // 等价于 a[0 : len(a)]
</pre>

<div class="english">
<p>
For arrays or strings, the indices are <i>in range</i> if
<code>0</code> &lt;= <code>low</code> &lt;= <code>high</code> &lt;= <code>len(a)</code>,
otherwise they are <i>out of range</i>.
For slices, the upper index bound is the slice capacity <code>cap(a)</code> rather than the length.
A <a href="#Constants">constant</a> index must be non-negative and
<a href="#Representability">representable</a> by a value of type
<code>int</code>; for arrays or constant strings, constant indices must also be in range.
If both indices are constant, they must satisfy <code>low &lt;= high</code>.
If the indices are out of range at run time, a <a href="#Run_time_panics">run-time panic</a> occurs.
</p>
</div>

<p>
对于数组或字符串，若 <code>0</code> &lt;= <code>low</code> &lt;= <code>high</code> &lt;= <code>len(a)</code>，
下标即在<b>界内</b>，否则即在<code>界外</code>。
对于切片，其上界为该切片的容量 <code>cap(a)</code> 而非长度。<a href="#常量">常量</a>下标必为非负值，
且可表示为 <code>int</code> 类型的值；对于数组或常量字符串，常量下标必须也在界内。若二者下标均为常量，它们必定满足
<code>low &lt;= high</code>。若 <code>a</code> 为 <code>nil</code>
或其下标在运行时越界，就会引发一个<a href="#运行时恐慌">运行时恐慌</a>。
</p>

<div class="english">
<p>
Except for <a href="#Constants">untyped strings</a>, if the sliced operand is a string or slice,
the result of the slice operation is a non-constant value of the same type as the operand.
For untyped string operands the result is a non-constant value of type <code>string</code>.
If the sliced operand is an array, it must be <a href="#Address_operators">addressable</a>
and the result of the slice operation is a slice with the same element type as the array.
</p>
</div>

<p>
除<a href="#常量">无类型化字符串</a>外，若已切下的操作数为字符串或切片，
该切片操作的结果即为与操作数类型相同的非常量值。
对于无类型化的字符串操作数，其结果为 <code>string</code> 类型的非常量值。
若已切下操作数为数组，它必须为<a href="#地址操作符">可寻址的</a>，
且该切片操作的结果为以相同元素类型作为数组的切片。
</p>

<div class="english">
<p>
If the sliced operand of a valid slice expression is a <code>nil</code> slice, the result
is a <code>nil</code> slice. Otherwise, if the result is a slice, it shares its underlying
array with the operand.
</p>
</div>

<p>
若一个有效切片表达式的被切操作数为 <code>nil</code> 切片，则其结果为
<code>nil</code> 切片。否则其结果与其操作数共享底层数组。
</p>

<div class="english">
<pre>
var a [10]int
s1 := a[3:7]   // underlying array of s1 is array a; &s1[2] == &a[5]
s2 := s1[1:4]  // underlying array of s2 is underlying array of s1 which is array a; &s2[1] == &a[5]
s2[1] = 42     // s2[1] == s1[2] == a[5] == 42; they all refer to the same underlying array element
</pre>
</div>

<pre>
var a [10]int
s1 := a[3:7]   // s1 的底层数组为数组 a，&s1[2] == &a[5]
s2 := s1[1:4]  // s2 与 s1 的底层数组同为 a，&s2[1] == &a[5]
s2[1] = 42     // s2[1] == s1[2] == a[5] == 42，它们均引用了相同的底层数组元素
</pre>


<div class="english">
<h4>Full slice expressions</h4>
</div>

<h4>完整切片表达式</h4>

<div class="english">
<p>
For an array, pointer to array, or slice <code>a</code> (but not a string), the primary expression
</p>
</div>

<p>
对于数组、数组指针或切片 <code>a</code>（除了字符串），主表达式
</p>

<pre>
a[low : high : max]
</pre>

<div class="english">
<p>
constructs a slice of the same type, and with the same length and elements as the simple slice
expression <code>a[low : high]</code>. Additionally, it controls the resulting slice's capacity
by setting it to <code>max - low</code>. Only the first index may be omitted; it defaults to 0.
After slicing the array <code>a</code>
</p>
</div>

<p>
构造一个同类型的切片，它与简单切片 <code>a[low : high]</code> 的长度和元素相同。
此外，它能通过将其设置为 <code>max - low</code> 来控制结果切片的容量。
只有第一个下标可被忽略，它默认为 0。在对数组 <code>a</code> 进行切片后
</p>

<pre>
a := [5]int{1, 2, 3, 4, 5}
t := a[1:3:5]
</pre>

<div class="english">
<p>
the slice <code>t</code> has type <code>[]int</code>, length 2, capacity 4, and elements
</p>
</div>

<p>
切片 <code>t</code> 拥有类型 <code>[]int</code>，长度为 2，容量为 4，且元素
</p>

<pre>
t[0] == 2
t[1] == 3
</pre>

<div class="english">
<p>
As for simple slice expressions, if <code>a</code> is a pointer to an array,
<code>a[low : high : max]</code> is shorthand for <code>(*a)[low : high : max]</code>.
If the sliced operand is an array, it must be <a href="#Address_operators">addressable</a>.
</p>
</div>

<p>
对于简单切片表达式，若 <code>a</code> 为数组指针，则 <code>a[low : high : max]</code>
为 <code>(*a)[low : high : max]</code> 的简写。若被切操作数为数组，它必须是<a href="#地址操作符">可寻址的</a>。
</p>

<div class="english">
<p>
The indices are <i>in range</i> if <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>,
otherwise they are <i>out of range</i>.
A <a href="#Constants">constant</a> index must be non-negative and
<a href="#Representability">representable</a> by a value of type
<code>int</code>; for arrays, constant indices must also be in range.
If multiple indices are constant, the constants that are present must be in range relative to each
other.
If the indices are out of range at run time, a <a href="#Run_time_panics">run-time panic</a> occurs.
</p>
</div>

<p>
若 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，则下标在<b>界内</b>，
否则在<b>界外</b>。<a href="#常量">常量</a> 下标必须为非负值且可被表示为
<code>int</code> 类型的值；对于数组，常量下标也必须在界内。若多个下标为常量，
则存在的常量必须在彼此的界内。若下标在运行时越界，就会引发一个<a href="#运行时恐慌">运行时恐慌</a>。
</p>

<div class="english">
<h3 id="Type_assertions">Type assertions</h3>
</div>

<h3 id="类型断言">类型断言</h3>

<div class="english">
<p>
For an expression <code>x</code> of <a href="#Interface_types">interface type</a>
and a type <code>T</code>, the primary expression
</p>
</div>

<p>
对于<a href="#接口类型">接口类型</a>的表达式 <code>x</code> 与类型 <code>T</code>，主表达式
</p>

<pre>
x.(T)
</pre>

<div class="english">
<p>
asserts that <code>x</code> is not <code>nil</code>
and that the value stored in <code>x</code> is of type <code>T</code>.
The notation <code>x.(T)</code> is called a <i>type assertion</i>.
</p>
</div>

<p>
断言 <code>x</code> 不为 <code>nil</code> 且存储于 <code>x</code> 中的值其类型为 <code>T</code>。
记法 <code>x.(T)</code> 称为<b>类型断言</b>。
</p>

<div class="english">
<p>
More precisely, if <code>T</code> is not an interface type, <code>x.(T)</code> asserts
that the dynamic type of <code>x</code> is <a href="#Type_identity">identical</a>
to the type <code>T</code>.
In this case, <code>T</code> must <a href="#Method_sets">implement</a> the (interface) type of <code>x</code>;
otherwise the type assertion is invalid since it is not possible for <code>x</code>
to store a value of type <code>T</code>.
If <code>T</code> is an interface type, <code>x.(T)</code> asserts that the dynamic type
of <code>x</code> implements the interface <code>T</code>.
</p>
</div>

<p>
更确切地说，若 <code>T</code> 为非接口类型，<code>x.(T)</code> 断言 <code>x</code> 的动态类型
与 <code>T</code><a href="#类型标识">相同</a>。在此情况下，<code>T</code>
必须<a href="#方法集">实现</a> <code>x</code> 的（接口）类型，除非其类型断言由于无法为
<code>x</code> 存储类型为 <code>T</code> 的值而无效。若 <code>T</code> 为接口类型，
<code>x.(T)</code> 则断言 <code>x</code> 的动态类型实现了接口 <code>T</code>。
</p>

<div class="english">
<p>
If the type assertion holds, the value of the expression is the value
stored in <code>x</code> and its type is <code>T</code>. If the type assertion is false,
a <a href="#Run_time_panics">run-time panic</a> occurs.
In other words, even though the dynamic type of <code>x</code>
is known only at run time, the type of <code>x.(T)</code> is
known to be <code>T</code> in a correct program.
</p>

<pre>
var x interface{} = 7          // x has dynamic type int and value 7
i := x.(int)                   // i has type int and value 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // illegal: string does not implement I (missing method m)
	r := y.(io.Reader)     // r has type io.Reader and the dynamic type of y must implement both I and io.Reader
	…
}
</pre>
</div>

<p>
若该类型断言成立，该表达式的值即为存储于 <code>x</code> 中的值，且其类型为 <code>T</code>。若该类型断言不成立，
就会出现一个<a href="#运行时恐慌">运行时恐慌</a>。换句话说，即使 <code>x</code>
的动态类型只能在运行时可知，在正确的程序中，<code>x.(T)</code> 的类型也可知为 <code>T</code>。
</p>

<pre>
var x interface{} = 7  // x 拥有动态类型 int 与值 7
i := x.(int)           // i 拥有类型 int 与值 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // 非法：string 没有实现 I（缺少方法 m）
	r := y.(io.Reader)     // r 拥有 类型 io.Reader 且 y 必须同时实现了 I 和 io.Reader
	…
}
</pre>

<div class="english">
<p>
A type assertion used in an <a href="#Assignments">assignment</a> or initialization of the special form
</p>
</div>

<p>
类型断言在<a href="#赋值">赋值</a>或初始化中通过特殊形式
</p>

<pre>
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
var v, ok T1 = x.(T)
</pre>

<div class="english">
<p>
yields an additional untyped boolean value. The value of <code>ok</code> is <code>true</code>
if the assertion holds. Otherwise it is <code>false</code> and the value of <code>v</code> is
the <a href="#The_zero_value">zero value</a> for type <code>T</code>.
No <a href="#Run_time_panics">run-time panic</a> occurs in this case.
</p>
</div>

<p>
产生一个附加的无类型化布尔值。若该断言成立，<code>ok</code> 的值为 <code>true</code>，否则即为
<code>false</code>，且 <code>v</code> 的值为类型为 <code>T</code> 的<a href="#零值">零值</a>。
此种情况不会触发<a href="#运行时恐慌">运行时恐慌</a>。
</p>


<div class="english">
<h3 id="Calls">Calls</h3>
</div>

<h3 id="调用">调用</h3>

<div class="english">
<p>
Given an expression <code>f</code> of function type
<code>F</code>,
</p>
</div>

<p>
给定函数类型为 <code>F</code> 的表达式 <code>f</code>，
</p>

<pre>
f(a1, a2, … an)
</pre>

<div class="english">
<p>
calls <code>f</code> with arguments <code>a1, a2, … an</code>.
Except for one special case, arguments must be single-valued expressions
<a href="#Assignability">assignable</a> to the parameter types of
<code>F</code> and are evaluated before the function is called.
The type of the expression is the result type
of <code>F</code>.
A method invocation is similar but the method itself
is specified as a selector upon a value of the receiver type for
the method.
</p>

<pre>
math.Atan2(x, y)  // function call
var pt *Point
pt.Scale(3.5)     // method call with receiver pt
</pre>
</div>

<p>
以实参 <code>a1, a2, … an</code> 调用 <code>f</code>。
除一种特殊情况外，实参必须为 <a href="#可赋值性">可赋予</a>
<code>F</code> 的形参类型的单值表达式，且在该函数被调用前求值。
该表达式的类型为 <code>F</code> 的返回类型。
方法调用也类似，只不过使用接收者类型值的选择器操作来指定方法。
</p>

<pre>
math.Atan2(x, y)  // 函数调用
var pt *Point
pt.Scale(3.5)     // 带接收者 pt 的方法调用
</pre>

<div class="english">
<p>
In a function call, the function value and arguments are evaluated in
<a href="#Order_of_evaluation">the usual order</a>.
After they are evaluated, the parameters of the call are passed by value to the function
and the called function begins execution.
The return parameters of the function are passed by value
back to the calling function when the function returns.
</p>
</div>

<p>
在函数调用中，函数值与实参按<a href="#求值顺序">一般顺序</a>求值。
在它们求值后，该调用的形参传值至该函数，被调用函数开始执行。
当函数返回时，该函数的返回形参将值传回调用函数。
</p>

<div class="english">
<p>
Calling a <code>nil</code> function value
causes a <a href="#Run_time_panics">run-time panic</a>.
</p>
</div>

<p>
调用 <code>nil</code> 函数值会引发 <a href="#运行时恐慌">运行时恐慌</a>。
</p>

<div class="english">
<p>
As a special case, if the return values of a function or method
<code>g</code> are equal in number and individually
assignable to the parameters of another function or method
<code>f</code>, then the call <code>f(g(<i>parameters_of_g</i>))</code>
will invoke <code>f</code> after binding the return values of
<code>g</code> to the parameters of <code>f</code> in order.  The call
of <code>f</code> must contain no parameters other than the call of <code>g</code>,
and <code>g</code> must have at least one return value.
If <code>f</code> has a final <code>...</code> parameter, it is
assigned the return values of <code>g</code> that remain after
assignment of regular parameters.
</p>
</div>

<p>
作为一种特殊情况，若函数或方法 <code>g</code> 的返回值在数量上等于函数或方法 <code>f</code> 的形参，
且分别可赋予它，那么调用 <code>f(g(<i>g 的形参</i>))</code> 将在依序绑定 <code>g</code>
的返回值至 <code>f</code> 的形参后引用 <code>f</code>。除 <code>g</code> 的调用外，
<code>f</code> 的调用必须不包含任何形参。若 <code>f</code> 的最后有 <code>...</code> 形参，
它在常规的形参赋值后，可被赋予 <code>g</code> 余下的返回值。
</p>

<pre>
func Split(s string, pos int) (string, string) {
	return s[0:pos], s[pos:]
}

func Join(s, t string) string {
	return s + t
}

if Join(Split(value, len(value)/2)) != value {
	log.Panic("test fails")
}
</pre>

<div class="english">
<p>
A method call <code>x.m()</code> is valid if the <a href="#Method_sets">method set</a>
of (the type of) <code>x</code> contains <code>m</code> and the
argument list can be assigned to the parameter list of <code>m</code>.
If <code>x</code> is <a href="#Address_operators">addressable</a> and <code>&amp;x</code>'s method
set contains <code>m</code>, <code>x.m()</code> is shorthand
for <code>(&amp;x).m()</code>:
</p>
</div>

<p>
若 <code>x</code>（的类型）的<a href="#方法集">方法集</a>包含 <code>m</code>，
且其实参列表可赋予 <code>m</code> 的形参列表，方法调用 <code>x.m()</code> 即为有效的。
若 <code>x</code> 为 <a href="#地址操作符">可寻址</a>的且 <code>&amp;x</code> 的方法集包含 <code>m</code>，
<code>x.m()</code> 即为 <code>(&amp;x).m()</code> 的简写：
</p>

<pre>
var p Point
p.Scale(3.5)
</pre>

<div class="english">
<p>
There is no distinct method type and there are no method literals.
</p>
</div>

<p>
其中即没有明显的方法类型，也没有方法字面。
</p>


<div class="english">
<h3 id="Passing_arguments_to_..._parameters">Passing arguments to <code>...</code> parameters</h3>
</div>

<h3 id="传递实参至...形参">传递实参至...形参</h3>

<div class="english">
<p>
If <code>f</code> is <a href="#Function_types">variadic</a> with a final
parameter <code>p</code> of type <code>...T</code>, then within <code>f</code>
the type of <code>p</code> is equivalent to type <code>[]T</code>.
If <code>f</code> is invoked with no actual arguments for <code>p</code>,
the value passed to <code>p</code> is <code>nil</code>.
Otherwise, the value passed is a new slice
of type <code>[]T</code> with a new underlying array whose successive elements
are the actual arguments, which all must be <a href="#Assignability">assignable</a>
to <code>T</code>. The length and capacity of the slice is therefore
the number of arguments bound to <code>p</code> and may differ for each
call site.
</p>
</div>

<p>
若函数 <code>f</code> 最后一个形参 <code>p</code> 的类型为 <code>...T</code>，
那么它就是<a href="#函数类型">变参函数</a>，在 <code>f</code> 中，<code>p</code>
的类型等价于 <code>[]T</code>。若 <code>f</code> 在调用时 <code>p</code> 没有实参，
那么传给 <code>p</code> 的值为 <code>nil</code>，否则传入的值为 <code>[]T</code>
类型的新切片，其新的底层数组中连续的元素即为实际的实参，它们必须都<a href="#可赋值性">可赋予</a>类型
<code>T</code>。因此，该切片的长度和容量为绑定至 <code>p</code> 的实参的个数，
且对于每一个调用位置可能都不同。
</p>

<div class="english">
<p>
Given the function and calls
</p>
</div>

<p>
给定函数和调用
</p>

<pre>
func Greeting(prefix string, who ...string)
Greeting("nobody")
Greeting("hello:", "Joe", "Anna", "Eileen")
</pre>

<div class="english">
<p>
within <code>Greeting</code>, <code>who</code> will have the value
<code>nil</code> in the first call, and
<code>[]string{"Joe", "Anna", "Eileen"}</code> in the second.
</p>
</div>

<p>
在 <code>Greeting</code> 中，<code>who</code> 在第一次调用将拥有值
<code>nil</code>，而在第二次调用中则拥有值
<code>[]string{"Joe", "Anna", "Eileen"}</code>。
</p>

<div class="english">
<p>
If the final argument is assignable to a slice type <code>[]T</code>, it is
passed unchanged as the value for a <code>...T</code> parameter if the argument
is followed by <code>...</code>. In this case no new slice is created.
</p>
</div>

<p>
若最后的实参可赋予类型为 <code>[]T</code> 的切片且后跟着 <code>...</code>，
它可能作为 <code>...T</code> 形参的值不变而被传入。
</p>

<div class="english">
<p>
Given the slice <code>s</code> and call
</p>
</div>

<p>
给定切片 <code>s</code> 与调用
</p>

<pre>
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
</pre>

<div class="english">
<p>
within <code>Greeting</code>, <code>who</code> will have the same value as <code>s</code>
with the same underlying array.
</p>
</div>

<p>
在 <code>Greeting</code> 中，<code>who</code> 将作为与 <code>s</code> 一样的值拥有与其相同的底层数组。
</p>


<div class="english">
<h3 id="Operators">Operators</h3>
</div>

<h3 id="操作符">操作符</h3>

<div class="english">
<p>
Operators combine operands into expressions.
</p>

<pre class="ebnf">
Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&amp;&amp;" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "&lt;" | "&lt;=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .
</pre>
</div>

<p>
操作符与操作数结合成为表达式。
</p>

<pre class="ebnf">
表达式     = 一元表达式 | 表达式 二元操作符 一元表达式 .
一元表达式 = 主表达式 | 一元操作符 一元表达式 .

二元操作符 = "||" | "&amp;&amp;" | 关系操作符 | 加法操作符 | 乘法操作符 .
关系操作符 = "==" | "!=" | "&lt;" | "&lt;=" | ">" | ">=" .
加法操作符 = "+" | "-" | "|" | "^" .
乘法操作符 = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .

一元操作符 = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .
</pre>

<div class="english">
<p>
Comparisons are discussed <a href="#Comparison_operators">elsewhere</a>.
For other binary operators, the operand types must be <a href="#Type_identity">identical</a>
unless the operation involves shifts or untyped <a href="#Constants">constants</a>.
For operations involving constants only, see the section on
<a href="#Constant_expressions">constant expressions</a>.
</p>
</div>

<p>
比较操作将在<a href="#比较操作符">别处</a>讨论。
对于其它二元操作符，操作数的类型必须<a href="#类型标识">相同</a>，
除非该操作包含移位或无类型化<a href="#常量">常量</a>。
</p>

<div class="english">
<p>
Except for shift operations, if one operand is an untyped <a href="#Constants">constant</a>
and the other operand is not, the constant is implicitly <a href="#Conversions">converted</a>
to the type of the other operand.
</p>
</div>

<p>
除移位操作外，若其中一个操作数为无类型化<a href="#常量">常量</a>而另一个不是，
该常量会隐式地<a href="#类型转换">类型转换</a>为另一个操作数的类型。
</p>

<div class="english">
<p>
The right operand in a shift expression must have integer type
or be an untyped constant <a href="#Representability">representable</a> by a
value of type <code>uint</code>.
If the left operand of a non-constant shift expression is an untyped constant,
it is first implicitly converted to the type it would assume if the shift expression were
replaced by its left operand alone.
</p>

<pre>
var s uint = 33
var i = 1&lt;&lt;s                  // 1 has type int
var j int32 = 1&lt;&lt;s            // 1 has type int32; j == 0
var k = uint64(1&lt;&lt;s)          // 1 has type uint64; k == 1&lt;&lt;33
var m int = 1.0&lt;&lt;s            // 1.0 has type int; m == 0 if ints are 32bits in size
var n = 1.0&lt;&lt;s == j           // 1.0 has type int32; n == true
var o = 1&lt;&lt;s == 2&lt;&lt;s          // 1 and 2 have type int; o == true if ints are 32bits in size
var p = 1&lt;&lt;s == 1&lt;&lt;33         // illegal if ints are 32bits in size: 1 has type int, but 1&lt;&lt;33 overflows int
var u = 1.0&lt;&lt;s                // illegal: 1.0 has type float64, cannot shift
var u1 = 1.0&lt;&lt;s != 0          // illegal: 1.0 has type float64, cannot shift
var u2 = 1&lt;&lt;s != 1.0          // illegal: 1 has type float64, cannot shift
var v float32 = 1&lt;&lt;s          // illegal: 1 has type float32, cannot shift
var w int64 = 1.0&lt;&lt;33         // 1.0&lt;&lt;33 is a constant shift expression
var x = a[1.0&lt;&lt;s]             // 1.0 has type int; x == a[0] if ints are 32bits in size
var a = make([]byte, 1.0&lt;&lt;s)  // 1.0 has type int; len(a) == 0 if ints are 32bits in size
</pre>
</div>

<p>
移位表达式中的右操作数必须为无符号整数，或可转换为无符号整数的无类型化常量。
若非常量移位表达式的左操作数为无类型化常量，且该移位表达式已被其左操作数独自取代，
它首先会转换为其假定的类型。
</p>

<pre>
var s uint = 33
var i = 1&lt;&lt;s           // 1 的类型为 int
var j int32 = 1&lt;&lt;s     // 1 的类型为 int32；j == 0
var k = uint64(1&lt;&lt;s)   // 1 的类型为 uint64；k == 1&lt;&lt;33
var m int = 1.0&lt;&lt;s     // 1.0 的类型为 int；若 int 的大小为 32 位，则 m == 0
var n = 1.0&lt;&lt;s == j    // 1.0 的类型为 int32；n == true
var o = 1&lt;&lt;s == 2&lt;&lt;s   // 1 与 2 的类型为 int；若 int 的大小为 32 位，则 o == true
var p = 1&lt;&lt;s == 1&lt;&lt;33  // 若 int 的大小为 32 位即为非法：虽然 1 的类型为 int，但 1&lt;&lt;33 溢出了 int
var u = 1.0&lt;&lt;s         // 非法: 1.0 的类型为 float64，不能移位
var u1 = 1.0&lt;&lt;s != 0   // 非法: 1.0 的类型为 float64，不能移位
var u2 = 1&lt;&lt;s != 1.0   // 非法: 1 的类型为 float64，不能移位
var v float32 = 1&lt;&lt;s   // 非法: 1 的类型为 float32，不能移位
var w int64 = 1.0&lt;&lt;33  // 1.0&lt;&lt;33 为常量移位表达式
</pre>


<div class="english">
<h4 id="Operator_precedence">Operator precedence</h4>
</div>

<h4 id="操作符优先级">操作符优先级</h4>

<div class="english">
<p>
Unary operators have the highest precedence.
As the  <code>++</code> and <code>--</code> operators form
statements, not expressions, they fall
outside the operator hierarchy.
As a consequence, statement <code>*p++</code> is the same as <code>(*p)++</code>.
</p>
</div>

<p>
一元操作符拥有最高优先级。
<code>++</code> 和 <code>--</code> 操作符是语句，而非表达式，它们不属于运算符一级。
因此，语句 <code>*p++</code> 等价于 <code>(*p)++</code>。
</p>

<div class="english">
<p>
There are five precedence levels for binary operators.
Multiplication operators bind strongest, followed by addition
operators, comparison operators, <code>&amp;&amp;</code> (logical AND),
and finally <code>||</code> (logical OR):
</p>

<pre class="grammar">
Precedence    Operator
    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^
    4             +  -  |  ^
    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=
    2             &amp;&amp;
    1             ||
</pre>
</div>

<p>
二元操作符有五种优先级。
乘法操作符结合性最强，其次为加法操作符、比较操作符、<code>&amp;&amp;</code>（逻辑与），
最后为 <code>||</code>（逻辑或）：
</p>

<pre class="grammar">
  优先级        操作符
    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^
    4             +  -  |  ^
    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=
    2             &amp;&amp;
    1             ||
</pre>

<div class="english">
<p>
Binary operators of the same precedence associate from left to right.
For instance, <code>x / y * z</code> is the same as <code>(x / y) * z</code>.
</p>
</div>

<p>
相同优先级的二元操作符从左到右结合。
例如，<code>x / y * z</code> 等价于 <code>(x / y) * z</code>。
</p>

<pre>
+x
23 + 3*x[i]
x &lt;= f()
^a &gt;&gt; b
f() || g()
x == y+1 &amp;&amp; &lt;-chanPtr &gt; 0
</pre>


<div class="english">
<h3 id="Arithmetic_operators">Arithmetic operators</h3>
</div>

<h3 id="算数操作符">算数操作符</h3>

<div class="english">
<p>
Arithmetic operators apply to numeric values and yield a result of the same
type as the first operand. The four standard arithmetic operators (<code>+</code>,
<code>-</code>, <code>*</code>, <code>/</code>) apply to integer,
floating-point, and complex types; <code>+</code> also applies to strings.
The bitwise logical and shift operators apply to integers only.
</p>

<pre class="grammar">
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&amp;    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&amp;^   bit clear (AND NOT)    integers

&lt;&lt;   left shift             integer &lt;&lt; unsigned integer
&gt;&gt;   right shift            integer &gt;&gt; unsigned integer
</pre>
</div>

<p>
算数操作符适用于数值，并产生相同类型的结果作为第一个操作数。四个基本算数操作符
（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>）适用于整数、浮点数和复数类型；
<code>+</code> 也适用于字符串。按位逻辑和移位运算符仅适用于整数。
</p>

<pre class="grammar">
+    和              integers, floats, complex values, strings
-    差              integers, floats, complex values
*    积              integers, floats, complex values
/    商              integers, floats, complex values
%    余              integers

&amp;    按位与          integers
|    按位或          integers
^    按位异或        integers
&amp;^   位清除（与非）  integers

&lt;&lt;   向左移位        integer &lt;&lt; unsigned integer
&gt;&gt;   向右移位        integer &gt;&gt; unsigned integer
</pre>

<div class="english">
<p>
Strings can be concatenated using the <code>+</code> operator
or the <code>+=</code> assignment operator:
</p>
</div>

<p>
字符串可使用 <code>+</code> 操作符连结或 <code>+=</code> 赋值操作符：
</p>

<div class="english">
<p>
For two integer values <code>x</code> and <code>y</code>, the integer quotient
<code>q = x / y</code> and remainder <code>r = x % y</code> satisfy the following
relationships:
</p>

<pre>
x = q*y + r  and  |r| &lt; |y|
</pre>

<p>
with <code>x / y</code> truncated towards zero
(<a href="https://en.wikipedia.org/wiki/Modulo_operation">"truncated division"</a>).
</p>
</div>

<p>
对于两个整数值 <code>x</code> 与 <code>y</code>，整数除法 <code>q = x / y</code>
和取余 <code>r = x % y</code> 满足以下关系：
</p>

<pre>
x = q*y + r  且  |r| &lt; |y|
</pre>

<p>
将 <code>x / y</code> 向零截断（“<a href="https://en.wikipedia.org/wiki/Modulo_operation">除法截断</a>”）。
</p>

<pre>
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
</pre>

<div class="english">
<p>
The one exception to this rule is that if the dividend <code>x</code> is
the most negative value for the int type of <code>x</code>, the quotient
<code>q = x / -1</code> is equal to <code>x</code> (and <code>r = 0</code>)
due to two's-complement <a href="#Integer_overflow">integer overflow</a>:
</p>
</div>

<p>
作为该规则的一个例外，若被除数 <code>x</code> 为 <code>x</code> 的 int 类型的最小负值，商
<code>q = x / -1</code> 等于 <code>x</code>（且 <code>r = 0</code>）。
</p>

<pre>
			 x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
</pre>

<div class="english">
<p>
If the divisor is a <a href="#Constants">constant</a>, it must not be zero.
If the divisor is zero at run time, a <a href="#Run_time_panics">run-time panic</a> occurs.
If the dividend is non-negative and the divisor is a constant power of 2,
the division may be replaced by a right shift, and computing the remainder may
be replaced by a bitwise AND operation:
</p>
</div>

<p>
若被除数为<a href="#常量">常量</a>，则它必不为零。若被除数在运行时为零，
就会出现一个<a href="#运行时恐慌">运行时恐慌</a>。若被除数为非负数，且除数为 2 的常量次幂，
则该除法可被向右移位取代，且计算其余数可被按位“与”操作取代：
</p>

<pre>
 x     x / 4     x % 4     x &gt;&gt; 2     x &amp; 3
 11      2         3         2          3
-11     -2        -3        -3          1
</pre>

<div class="english">
<p>
The shift operators shift the left operand by the shift count specified by the
right operand, which must be non-negative. If the shift count is negative at run time,
a <a href="#Run_time_panics">run-time panic</a> occurs.
The shift operators implement arithmetic shifts if the left operand is a signed
integer and logical shifts if it is an unsigned integer.
There is no upper limit on the shift count. Shifts behave
as if the left operand is shifted <code>n</code> times by 1 for a shift
count of <code>n</code>.
As a result, <code>x &lt;&lt; 1</code> is the same as <code>x*2</code>
and <code>x &gt;&gt; 1</code> is the same as
<code>x/2</code> but truncated towards negative infinity.
</p>
</div>

<p>
移位操作符通过右操作数指定的移位计数来移位左操作数。若左操作数为带符号整数，它们就执行算术移位；
若左操作数为无符号整数，它们则执行逻辑移位。移位计数没有上界。
若左操作数移 <code>n</code> 位，其行为如同移 1 位 <code>n</code> 次。
按照其结果，<code>x &lt;&lt; 1</code> 等价于 <code>x*2</code>，而 <code>x &gt;&gt; 1</code>
等价于 <code>x/2</code> 但向负无穷大截断。
</p>

<div class="english">
<p>
For integer operands, the unary operators
<code>+</code>, <code>-</code>, and <code>^</code> are defined as
follows:
</p>

<pre class="grammar">
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
</pre>
</div>

<p>
对于整数操作数，一元操作符 <code>+</code>、<code>-</code> 和 <code>^</code> 的定义如下：
</p>

<pre class="grammar">
+x                  即为 0 + x
-x    相反数        即为 0 - x
^x    按位补码      即为 m ^ x  对于无符号的 x，m = "所有位置为 1"
                                对于带符号的 x，m = -1
</pre>

<div class="english">
<p>
For floating-point and complex numbers,
<code>+x</code> is the same as <code>x</code>,
while <code>-x</code> is the negation of <code>x</code>.
The result of a floating-point or complex division by zero is not specified beyond the
IEEE-754 standard; whether a <a href="#Run_time_panics">run-time panic</a>
occurs is implementation-specific.
</p>
</div>

<p>
对于浮点数与复数来说，<code>+x</code> 等价于 <code>x</code>，而 <code>-x</code> 则为 <code>x</code> 的相反数。
浮点数或复数除以零的结果仅满足 IEEE-754 标准而无额外保证；是否会出现<a href="#运行时恐慌">运行时恐慌</a>取决于具体实现。
</p>

<div class="english">
<h3 id="Integer_overflow">Integer overflow</h3>
</div>

<h3 id="整数溢出">整数溢出</h3>

<div class="english">
<p>
For unsigned integer values, the operations <code>+</code>,
<code>-</code>, <code>*</code>, and <code>&lt;&lt;</code> are
computed modulo 2<sup><i>n</i></sup>, where <i>n</i> is the bit width of
the <a href="#Numeric_types">unsigned integer</a>'s type.
Loosely speaking, these unsigned integer operations
discard high bits upon overflow, and programs may rely on "wrap around".
</p>
</div>

<p>
对于无符号整数值，操作 <code>+</code>、<code>-</code>、<code>*</code> 和 <code>&lt;&lt;</code>
均被计算为取模 2<sup><i>n</i></sup>，其中 <i>n</i> 为该<a href="#数值类型">无符号整数</a>类型的位宽。
不严格地说，这些无符号整数操作抛弃高位向上溢出，程序可依赖这种形式的“回卷”。
</p>

<div class="english">
<p>
For signed integers, the operations <code>+</code>,
<code>-</code>, <code>*</code>, <code>/</code>, and <code>&lt;&lt;</code> may legally
overflow and the resulting value exists and is deterministically defined
by the signed integer representation, the operation, and its operands.
Overflow does not cause a <a href="#Run_time_panics">run-time panic</a>.
A compiler may not optimize code under the assumption that overflow does
not occur. For instance, it may not assume that <code>x &lt; x + 1</code> is always true.
</p>
</div>

<p>
对于带符号整数，操作 <code>+</code>、<code>-</code>、<code>*</code> 和 <code>&lt;&lt;</code> 可合法溢出，
而由此产生的值会继续存在，并由该带符号整数表现、操作、与其操作数决定性地定义。
除溢出外没有例外会导致此情况。在溢出不会发生的假定情况下编译器可能不会优化代码。
例如，我们无法假定 <code>x &lt; x + 1</code> 总为真。
</p>


<div class="english">
<h4 id="Floating_point_operators">Floating-point operators</h4>
</div>

<h4 id="浮点数运算符">浮点数运算符</h4>

<div class="english">
<p>
For floating-point and complex numbers,
<code>+x</code> is the same as <code>x</code>,
while <code>-x</code> is the negation of <code>x</code>.
The result of a floating-point or complex division by zero is not specified beyond the
IEEE-754 standard; whether a <a href="#Run_time_panics">run-time panic</a>
occurs is implementation-specific.
</p>
</div>

<p>
对于浮点数和复数，<code>+x</code> 与 <code>x</code> 相同，而 <code>-x</code>
为 <code>x</code> 的相反数。浮点数或复数被零除的结果在 IEEE-754 标准中并未指定，
是否引发 <a href="#运行时恐慌">运行时恐慌</a> 取决于具体实现。
</p>

<p>
An implementation may combine multiple floating-point operations into a single
fused operation, possibly across statements, and produce a result that differs
from the value obtained by executing and rounding the instructions individually.
An explicit floating-point type <a href="#Conversions">conversion</a> rounds to
the precision of the target type, preventing fusion that would discard that rounding.
</p>

<p>
For instance, some architectures provide a "fused multiply and add" (FMA) instruction
that computes <code>x*y + z</code> without rounding the intermediate result <code>x*y</code>.
These examples show when a Go implementation can use that instruction:
</p>

<pre>
// FMA allowed for computing r, because x*y is not explicitly rounded:
r  = x*y + z
r  = z;   r += x*y
t  = x*y; r = t + z
*p = x*y; r = *p + z
r  = x*y + float64(z)

// FMA disallowed for computing r, because it would omit rounding of x*y:
r  = float64(x*y) + z
r  = z; r += float64(x*y)
t  = float64(x*y); r = t + z
</pre>

<div class="english">
<h4 id="String_concatenation">String concatenation</h4>
</div>

<h4 id="字符串连接">字符串连接</h4>

<div class="english">
<p>
Strings can be concatenated using the <code>+</code> operator
or the <code>+=</code> assignment operator:
</p>
</div>

<p>
字符串可使用 <code>+</code> 操作符或 <code>+=</code> 赋值操作符：
</p>

<pre>
s := "hi" + string(c)
s += " and good bye"
</pre>

<div class="english">
<p>
String addition creates a new string by concatenating the operands.
</p>
</div>

<p>
字符串加法会通过连接操作数创建一个新的字符串。
</p>


<div class="english">
<h3 id="Comparison_operators">Comparison operators</h3>
</div>

<h3 id="比较操作符">比较操作符</h3>

<div class="english">
<p>
Comparison operators compare two operands and yield an untyped boolean value.
</p>

<pre class="grammar">
==    equal
!=    not equal
&lt;     less
&lt;=    less or equal
&gt;     greater
&gt;=    greater or equal
</pre>
</div>

<p>
比较操作符比较两个操作数并产生一个无类型化的布尔值。
</p>

<pre class="grammar">
==    等于
!=    不等于
&lt;     小于
&lt;=    小于等于
&gt;     大于
&gt;=    大于等于
</pre>

<div class="english">
<p>
In any comparison, the first operand
must be <a href="#Assignability">assignable</a>
to the type of the second operand, or vice versa.
</p>
</div>

<p>
在任何比较中，第一个操作数必须为<a href="#可赋值性">可赋予</a>第二个操作数的类型，反之亦然。
</p>

<div class="english">
<p>
The equality operators <code>==</code> and <code>!=</code> apply
to operands that are <i>comparable</i>.
The ordering operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>
apply to operands that are <i>ordered</i>.
These terms and the result of the comparisons are defined as follows:
</p>

<ul>
	<li>
	Boolean values are comparable.
	Two boolean values are equal if they are either both
	<code>true</code> or both <code>false</code>.
	</li>

	<li>
	Integer values are comparable and ordered, in the usual way.
	</li>

	<li>
	Floating-point values are comparable and ordered,
	as defined by the IEEE-754 standard.
	</li>

	<li>
	Complex values are comparable.
	Two complex values <code>u</code> and <code>v</code> are
	equal if both <code>real(u) == real(v)</code> and
	<code>imag(u) == imag(v)</code>.
	</li>

	<li>
	String values are comparable and ordered, lexically byte-wise.
	</li>

	<li>
	Pointer values are comparable.
	Two pointer values are equal if they point to the same variable or if both have value <code>nil</code>.
	Pointers to distinct <a href="#Size_and_alignment_guarantees">zero-size</a> variables may or may not be equal.
	</li>

	<li>
	Channel values are comparable.
	Two channel values are equal if they were created by the same call to
	<a href="#Making_slices_maps_and_channels"><code>make</code></a>
	or if both have value <code>nil</code>.
	</li>

	<li>
	Interface values are comparable.
	Two interface values are equal if they have <a href="#Type_identity">identical</a> dynamic types
	and equal dynamic values or if both have value <code>nil</code>.
	</li>

	<li>
	A value <code>x</code> of non-interface type <code>X</code> and
	a value <code>t</code> of interface type <code>T</code> are comparable when values
	of type <code>X</code> are comparable and
	<code>X</code> implements <code>T</code>.
	They are equal if <code>t</code>'s dynamic type is identical to <code>X</code>
	and <code>t</code>'s dynamic value is equal to <code>x</code>.
	</li>

	<li>
	Struct values are comparable if all their fields are comparable.
	Two struct values are equal if their corresponding
	non-<a href="#Blank_identifier">blank</a> fields are equal.
	</li>

	<li>
	Array values are comparable if values of the array element type are comparable.
	Two array values are equal if their corresponding elements are equal.
	</li>
</ul>
</div>

<p>
相等性操作符 <code>==</code> 和 <code>!=</code> 适用于<b>可比较</b>操作数。
顺序操作符 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code>
适用于<b>有序的</b>操作数。这些比较操作的关系和值定义如下：
</p>

<ul>
	<li>
	布尔值之间可比较。若两个布尔值同为 <code>true</code> 或同为 <code>false</code>，它们即为相等。
	</li>

	<li>
	通常情况下，整数值之间可比较或排序。
	</li>

	<li>
	根据 IEEE-754 标准的定义，浮点数值之间可比较或排序。
	</li>

	<li>
	复数值之间可比较。对于两个复数值 <code>u</code> 与 <code>v</code>，
	若 <code>real(u) == real(v)</code> 且 <code>imag(u) == imag(v)</code>，它们即为相等。
	</li>

	<li>
	根据按字节词法，字符串值之间可比较或排序。
	</li>

	<li>
	指针值之间可比较。若两个指针指向相同的值或其值同为 <code>nil</code>，它们即为相等。
	指向明显为<a href="#大小与对齐保证">零大小</a>变量的指针可能相等也可能不相等。
	</li>

	<li>
	信道值可比较。若两个信道值通过相同的 <a href="#创建切片、映射和信道"><code>make</code></a>
	调用创建或同为 <code>nil</code> 值，它们即为相等。
	</li>

	<li>
	接口值可比较。若两个接口值拥有<a href="#类型标识">相同</a>的动态类型与相等的动态值，或同为
	<code>nil</code> 值，它们即为相等。
	</li>

	<li>
	当非接口类型 <code>X</code> 的值可比较且 <code>X</code> 实现了 <code>T</code> 时，
	非接口类型 <code>X</code> 的值 <code>x</code> 与接口类型 <code>T</code> 的值 <code>t</code> 则可比较。
	若 <code>t</code> 的动态类型与 <code>X</code> 相同且 <code>t</code> 动态值等于 <code>x</code>，它们即为相等。
	</li>

	<li>
	若两个结构体值的所有字段可比较，它们即可比较。若其相应的非<a href="#空白标识符">空白</a>字段相等，它们即为相等。
	</li>

	<li>
	若两个数组元素类型的值可比较，则数组值可比较。若其相应的元素相等，它们即为相等。
	</li>
</ul>

<div class="english">
<p>
A comparison of two interface values with identical dynamic types
causes a <a href="#Run_time_panics">run-time panic</a> if values
of that type are not comparable.  This behavior applies not only to direct interface
value comparisons but also when comparing arrays of interface values
or structs with interface-valued fields.
</p>
</div>

<p>
两个动态类型相同的接口值进行比较，若该动态类型的值不可比较，将引发一个<a href="#运行时恐慌">运行时恐慌</a>。
此行为不仅适用于直接的接口值比较，当比较接口值的数组或接口值作为字段的结构体时也适用。
</p>

<div class="english">
<p>
Slice, map, and function values are not comparable.
However, as a special case, a slice, map, or function value may
be compared to the predeclared identifier <code>nil</code>.
Comparison of pointer, channel, and interface values to <code>nil</code>
is also allowed and follows from the general rules above.
</p>
</div>

<p>
切片、映射和函数值同类型之间不可比较。然而，作为一种特殊情况，切片、映射或函数值可与预声明标识符 <code>nil</code>
进行比较。指针、信道和接口值与 <code>nil</code> 之间的比较也允许并遵循上面的一般规则。
</p>

<div class="english">
<pre>
const c = 3 &lt; 4            // c is the untyped boolean constant true

type MyBool bool
var x, y int
var (
	// The result of a comparison is an untyped boolean.
	// The usual assignment rules apply.
	b3        = x == y // b3 has type bool
	b4 bool   = x == y // b4 has type bool
	b5 MyBool = x == y // b5 has type MyBool
)
</pre>
</div>

<pre>
const c = 3 &lt; 4            // c 为无类型化常量 true

type MyBool bool
var x, y int
var (
	// 比较的结果为无类型化布尔值。
	// 通常的复制规则也适用。
	b3        = x == y // b3 的类型为 bool
	b4 bool   = x == y // b4 的类型为 bool
	b5 MyBool = x == y // b5 的类型为 MyBool
)
</pre>

<div class="english">
<h3 id="Logical_operators">Logical operators</h3>
</div>

<h3 id="逻辑操作符">逻辑操作符</h3>

<div class="english">
<p>
Logical operators apply to <a href="#Boolean_types">boolean</a> values
and yield a result of the same type as the operands.
The right operand is evaluated conditionally.
</p>

<pre class="grammar">
&amp;&amp;    conditional AND    p &amp;&amp; q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
</pre>
</div>

<p>
逻辑操作符适用于<a href="#布尔类型">布尔</a>值并根据操作数产生一个相同类型的结果。右操作数有条件地求值。
</p>

<pre class="grammar">
&amp;&amp;    条件与    p &amp;&amp; q  即  “若 p 成立则判断 q 否则返回 false”
||    条件或    p || q  即  “若 p 成立则返回 true 否则判断 q”
!     非        !p      即  “非 p”
</pre>


<div class="english">
<h3 id="Address_operators">Address operators</h3>
</div>

<h3 id="地址操作符">地址操作符</h3>

<div class="english">
<p>
For an operand <code>x</code> of type <code>T</code>, the address operation
<code>&amp;x</code> generates a pointer of type <code>*T</code> to <code>x</code>.
The operand must be <i>addressable</i>,
that is, either a variable, pointer indirection, or slice indexing
operation; or a field selector of an addressable struct operand;
or an array indexing operation of an addressable array.
As an exception to the addressability requirement, <code>x</code> may also be a
(possibly parenthesized)
<a href="#Composite_literals">composite literal</a>.
If the evaluation of <code>x</code> would cause a <a href="#Run_time_panics">run-time panic</a>,
then the evaluation of <code>&amp;x</code> does too.
</p>
</div>

<p>
对于类型为 <code>T</code> 的操作数 <code>x</code>，地址操作符 <code>&amp;x</code> 将生成一个类型为
<code>*T</code> 的指针指向 <code>x</code>。操作数必须<b>可寻址</b>，即，变量、间接指针、切片索引操作，
或可寻址结构体操作数的字段选择器，或可寻址数组的数组索引操作均不可寻址。作为可寻址性需求的例外，
<code>x</code> 也可为（可能带有括号的）<a href="#复合字面">复合字面</a>.
<code>x</code> 的求值会引发一个<a href="#运行时恐慌">运行时恐慌</a>，那么
<code>&amp;x</code> 的求值也会。
</p>

<div class="english">
<p>
For an operand <code>x</code> of pointer type <code>*T</code>, the pointer
indirection <code>*x</code> denotes the <a href="#Variables">variable</a> of type <code>T</code> pointed
to by <code>x</code>.
If <code>x</code> is <code>nil</code>, an attempt to evaluate <code>*x</code>
will cause a <a href="#Run_time_panics">run-time panic</a>.
</p>
</div>

<p>
对于指针类型为 <code>*T</code> 的操作数 <code>x</code>，间接指针 <code>*x</code>
表示类型为 <code>T</code> 的<a href="#变量">变量</a>指向 <code>x</code>。若 <code>x</code> 为 <code>nil</code>，
尝试求值 <code>*x</code> 将会引发<a href="#运行时恐慌">运行时恐慌</a>。
</p>

<div class="english">
<pre>
&amp;x
&amp;a[f(2)]
&amp;Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // causes a run-time panic
&amp;*x  // causes a run-time panic
</pre>
</div>

<pre>
&amp;x
&amp;a[f(2)]
&amp;Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // 引发运行时恐慌
&amp;*x  // 引发运行时恐慌
</pre>


<div class="english">
<h3 id="Receive_operator">Receive operator</h3>
</div>

<h3 id="接收操作符">接收操作符</h3>

<div class="english">
<p>
For an operand <code>ch</code> of <a href="#Channel_types">channel type</a>,
the value of the receive operation <code>&lt;-ch</code> is the value received
from the channel <code>ch</code>. The channel direction must permit receive operations,
and the type of the receive operation is the element type of the channel.
The expression blocks until a value is available.
Receiving from a <code>nil</code> channel blocks forever.
A receive operation on a <a href="#Close">closed</a> channel can always proceed
immediately, yielding the element type's <a href="#The_zero_value">zero value</a>
after any previously sent values have been received.
</p>

<pre>
v1 := &lt;-ch
v2 = &lt;-ch
f(&lt;-ch)
&lt;-strobe  // wait until clock pulse and discard received value
</pre>
</div>

<p>
对于<a href="#信道类型">信道类型</a>的操作数 <code>ch</code>，接收操作符
<code>&lt;-ch</code> 的值即为从信道 <code>ch</code> 接收的值。该信道的方向必须允许接收操作，
且该接收操作的类型即为该信道的元素类型。该值前的表达式块是有效的。
从 <code>nil</code> 信道接收将永远阻塞。从<a href="#关闭">已关闭</a>的信道接收能够总是立即进行，
在之前发送的任何值均被接收后，它会产生其元素类型的<a href="#零值">零值</a>
</p>

<pre>
v1 := &lt;-ch
v2 = &lt;-ch
f(&lt;-ch)
&lt;-strobe  // 在时钟脉冲和丢弃接收值之前等待
</pre>

<div class="english">
<p>
A receive expression used in an <a href="#Assignments">assignment</a> or initialization of the special form
</p>
</div>

<p>
接收表达式在<a href="#赋值">赋值</a>或初始化中通过特殊形式
</p>

<pre>
x, ok = &lt;-ch
x, ok := &lt;-ch
var x, ok = &lt;-ch
var x, ok T = &lt;-ch
</pre>

<div class="english">
<p>
yields an additional untyped boolean result reporting whether the
communication succeeded. The value of <code>ok</code> is <code>true</code>
if the value received was delivered by a successful send operation to the
channel, or <code>false</code> if it is a zero value generated because the
channel is closed and empty.
</p>
</div>

<p>
产生一个附加的为类型化布尔值来报告通信是否成功。
若接收的值由一次成功向信道发送的操作发出的，则 <code>ok</code> 的值为 <code>true</code>；
若接收的值是由于信道被关闭或为空而产生的零值，则为 <code>false</code>。
</p>


<div class="english">
<h3 id="Conversions">Conversions</h3>
</div>

<h3 id="类型转换">类型转换</h3>

<div class="english">
<p>
A conversion changes the <a href="#Types">type</a> of an expression
to the type specified by the conversion.
A conversion may appear literally in the source, or it may be <i>implied</i>
by the context in which an expression appears.
</p>

<p>
An <i>explicit</i> conversion is an expression of the form <code>T(x)</code>
where <code>T</code> is a type and <code>x</code> is an expression
that can be converted to type <code>T</code>.
</p>

<pre class="ebnf">
Conversion = Type "(" Expression [ "," ] ")" .
</pre>
</div>

<p>
类型转换用于将表达式的<a href="#类型">类型</a>更改为指定的类型。类型转换可直接出现在源码中，
或者<b>隐含</b>在表达式出现的上下文中。
</p>

<p>
<b>显式</b>类型转换是形式为 <code>T(x)</code> 的表达式，其中 <code>T</code> 为类型，而
<code>x</code> 是可转换为类型 <code>T</code> 的表达式。
</p>

<pre class="ebnf">
类型转换 = 类型 "(" 表达式 [ "," ] ")" .
</pre>

<div class="english">
<p>
If the type starts with the operator <code>*</code> or <code>&lt;-</code>,
or if the type starts with the keyword <code>func</code>
and has no result list, it must be parenthesized when
necessary to avoid ambiguity:
</p>
</div>

<pre>
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to *Point
&lt;-chan int(c)    // same as &lt;-(chan int(c))
(&lt;-chan int)(c)  // c is converted to &lt;-chan int
func()(x)        // function signature func() x
(func())(x)      // x is converted to func()
(func() int)(x)  // x is converted to func() int
func() int(x)    // x is converted to func() int (unambiguous)
</pre>

<p>
若类型以操作符 <code>*</code>、<code>&lt;-</code> 或关键字 <code>func</code>
开始则必须加上括号：
</p>

<pre>
*Point(p)        // 等价于 *(Point(p))
(*Point)(p)      // p 被转换为 (*Point)
&lt;-chan int(c)    // 等价于 &lt;-(chan int(c))
(&lt;-chan int)(c)  // c 被转换为 (&lt;-chan int)
func()(x)        // 函数签名 func() x
(func())(x)      // x 被转换为 (func())
</pre>

<div class="english">
<p>
A <a href="#Constants">constant</a> value <code>x</code> can be converted to
type <code>T</code> if <code>x</code> is <a href="#Representability">representable</a>
by a value of <code>T</code>.
As a special case, an integer constant <code>x</code> can be explicitly converted to a
<a href="#String_types">string type</a> using the
<a href="#Conversions_to_and_from_a_string_type">same rule</a>
as for non-constant <code>x</code>.
</p>
</div>

<p>
当<a href="#常量">常量</a>值 <code>x</code> <a href="#可表示性">可表示</a>为一个
<code>T</code> 类型的值时，<code>x</code> 可转换为类型 <code>T</code>。
作为一种特例，整数常量 <code>x</code> 可作为非常量 <code>x</code> 使用
<a href="#字符串类型的转换">同一规则</a>被显式转换为<a href="#字符串类型">字符串类型</a>。
</p>

<div class="english">
<p>
Converting a constant yields a typed constant as result.
</p>

<pre>
uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
float32(0.49999999)      // 0.5 of type float32
float64(-1e-1000)        // 0.0 of type float64
string('x')              // "x" of type string
string(0x266c)           // "♬" of type string
MyString("foo" + "bar")  // "foobar" of type MyString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type
int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant
</pre>
</div>

<p>
转换一个常量将产生一个类型化的常量作为结果。
</p>

<pre>
uint(iota)               // 类型为 uint 的 iota 值
float32(2.718281828)     // 类型为 float32 的 2.718281828
complex128(1)            // 类型为 complex128 的 1.0 + 0.0i
float32(0.49999999)      // 类型为 float32 的 0.5
float64(-1e-1000)        // 类型为 float64 的 0.0
string('x')              // 类型为 string 的 "x"
string(0x266c)           // 类型为 string 的 "♬"
MyString("foo" + "bar")  // 类型为 MyString 的 "foobar"
string([]byte{'a'})      // 非常量：[]byte{'a'} 不为常量
(*int)(nil)              // 非常量：nil 不为常量，*int 不为布尔、 数值或字符串类型
int(1.2)                 // 非法：1.2 不能表示为 int
string(65.0)             // 非法：65.0 不为整数常量
</pre>

<div class="english">
<p>
A non-constant value <code>x</code> can be converted to type <code>T</code>
in any of these cases:
</p>

<ul>
	<li>
	<code>x</code> is <a href="#Assignability">assignable</a>
	to <code>T</code>.
	</li>
	<li>
	ignoring struct tags (see below),
	<code>x</code>'s type and <code>T</code> have <a href="#Type_identity">identical</a>
	<a href="#Types">underlying types</a>.
	</li>
	<li>
	ignoring struct tags (see below),
	<code>x</code>'s type and <code>T</code> are pointer types
	that are not <a href="#Type_definitions">defined types</a>,
	and their pointer base types have identical underlying types.
	</li>
	<li>
	<code>x</code>'s type and <code>T</code> are both integer or floating
	point types.
	</li>
	<li>
	<code>x</code>'s type and <code>T</code> are both complex types.
	</li>
	<li>
	<code>x</code> is an integer or a slice of bytes or runes
	and <code>T</code> is a string type.
	</li>
	<li>
	<code>x</code> is a string and <code>T</code> is a slice of bytes or runes.
	</li>
</ul>
</div>

<p>
非常量值 <code>x</code> 在这些情况下可转换为类型 <code>T</code>：
</p>

<ul>
	<li>
	当 <code>x</code> <a href="#可赋值性">可赋予</a> <code>T</code>时。
	</li>
	<li>
	当 <code>x</code> 的类型与 <code>T</code> 拥有相同的<a href="#类型">基本类型</a>时。
	</li>
	<li>
	当 <code>x</code> 的类型与 <code>T</code> 为未命名指针类型，且它们的指针基础类型拥有相同的基本类型时。
	</li>
	<li>
	当 <code>x</code> 的类型与 <code>T</code> 同为整数或浮点数类型时。
	</li>
	<li>
	当 <code>x</code> 的类型与 <code>T</code> 同为复数类型时。
	</li>
	<li>
	当 <code>x</code> 为整数、字节切片或符文切片且 <code>T</code> 为字符串类型时。
	</li>
	<li>
	当 <code>x</code> 为字符串且 <code>T</code> 为字节切片或符文切片时。
	</li>
</ul>

<div class="english">
<p>
<a href="#Struct_types">Struct tags</a> are ignored when comparing struct types
for identity for the purpose of conversion:
</p>
</div>

<p>
在为了转换而通过比较识别结构体类型时，<a href="#结构体类型">结构体标注</a> 会被忽略：
</p>

<pre>
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}

var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}

var person = (*Person)(data)  // ignoring tags, the underlying types are identical
</pre>

<div class="english">
<p>
Specific rules apply to (non-constant) conversions between numeric types or
to and from a string type.
These conversions may change the representation of <code>x</code>
and incur a run-time cost.
All other conversions only change the type but not the representation
of <code>x</code>.
</p>
</div>

<p>
具体规则应用于（非常量）与数值类型之间，或在字符串类型之间转换。
这些类型转换会改变 <code>x</code> 的表示并引发运行时的代价。
其它转换只改变类型而不改变 <code>x</code> 的表示。
</p>

<div class="english">
<p>
There is no linguistic mechanism to convert between pointers and integers.
The package <a href="#Package_unsafe"><code>unsafe</code></a>
implements this functionality under
restricted circumstances.
</p>
</div>

<p>
没有语言机制能在指针和整数之间转换。包 <a href="#包 unsafe"><code>unsafe</code></a>
可在受限情况下实现此功能。
</p>


<div class="english">
<h4>Conversions between numeric types</h4>
</div>

<h4>数值类型间的转换</h4>

<div class="english">
<p>
For the conversion of non-constant numeric values, the following rules apply:
</p>

<ol>
<li>
When converting between integer types, if the value is a signed integer, it is
sign extended to implicit infinite precision; otherwise it is zero extended.
It is then truncated to fit in the result type's size.
For example, if <code>v := uint16(0x10F0)</code>, then <code>uint32(int8(v)) == 0xFFFFFFF0</code>.
The conversion always yields a valid value; there is no indication of overflow.
</li>
<li>
When converting a floating-point number to an integer, the fraction is discarded
(truncation towards zero).
</li>
<li>
When converting an integer or floating-point number to a floating-point type,
or a complex number to another complex type, the result value is rounded
to the precision specified by the destination type.
For instance, the value of a variable <code>x</code> of type <code>float32</code>
may be stored using additional precision beyond that of an IEEE-754 32-bit number,
but float32(x) represents the result of rounding <code>x</code>'s value to
32-bit precision. Similarly, <code>x + 0.1</code> may use more than 32 bits
of precision, but <code>float32(x + 0.1)</code> does not.
</li>
</ol>
</div>

<p>
对于非常量数值类型的类型转换，以下规则适用：
</p>

<ol>
<li>
当在整数类型间转换时，若该值为无符号整数，其符号将扩展为隐式无限精度，反之为零扩展。
然后截断以符合该返回类型的大小。例如，若 <code>v := uint16(0x10F0)</code>，则
<code>uint32(int8(v)) == 0xFFFFFFF0</code>。类型转换总产生有效值，且无溢出指示。
</li>
<li>
当转换浮点数为整数时，小数部分将被丢弃（向零截断）。
</li>
<li>
当转换整数或浮点数为浮点类型，或转换复数类型为另一个复数类型时，其返回值将舍入至目标类型指定的精度。
例如，类型为 <code>float32</code> 的变量 <code>x</code> 的值可能使用超出 IEEE-754
标准 32 位数的额外精度来存储，但 float32(x) 表示将 <code>x</code> 的值舍入为 32 位精度的结果。
同样，<code>x + 0.1</code> 会使用超过 32 位的精度，但 <code>float32(x + 0.1)</code> 却不会。
</li>
</ol>

<div class="english">
<p>
In all non-constant conversions involving floating-point or complex values,
if the result type cannot represent the value the conversion
succeeds but the result value is implementation-dependent.
</p>
</div>

<p>
在所有涉及非常量浮点数或复数值的类型转换中，若该返回类型不能表示该转换成功的值，则该返回值取决于具体实现。
</p>

<div class="english">
<h4 id="Conversions_to_and_from_a_string_type">Conversions to and from a string type</h4>
</div>

<h4 id="字符串类型的转换">字符串类型的转换</h4>

<div class="english">
<ol>
<li>
Converting a signed or unsigned integer value to a string type yields a
string containing the UTF-8 representation of the integer. Values outside
the range of valid Unicode code points are converted to <code>"\uFFFD"</code>.

<pre>
string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd"
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"
</pre>
</li>

<li>
Converting a slice of bytes to a string type yields
a string whose successive bytes are the elements of the slice.

<pre>
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"
string([]byte{})                                     // ""
string([]byte(nil))                                  // ""

type MyBytes []byte
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"
</pre>
</li>

<li>
Converting a slice of runes to a string type yields
a string that is the concatenation of the individual rune values
converted to strings.

<pre>
string([]rune{0x767d, 0x9d6c, 0x7fd4})   // "\u767d\u9d6c\u7fd4" == "白鵬翔"
string([]rune{})                         // ""
string([]rune(nil))                      // ""

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
</pre>
</li>

<li>
Converting a value of a string type to a slice of bytes type
yields a slice whose successive elements are the bytes of the string.

<pre>
[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
[]byte("")        // []byte{}

MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
</pre>
</li>

<li>
Converting a value of a string type to a slice of runes type
yields a slice containing the individual Unicode code points of the string.

<pre>
[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
[]rune("")                 // []rune{}

MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}
</pre>
</li>
</ol>
</div>

<ol>
<li>
将有符号或无符号整数值转换为字符串类型将产生一个包含 UTF-8 表示的该整数的字符串。
有效 Unicode 码点范围之外的值将转换为 <code>"\uFFFD"</code>。

<pre>
string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd "
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"
</pre>
</li>

<li>
将字节切片转换为字符串类型将产生一个连续字节为该切片元素的字符串。

<pre>
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"
string([]byte{})                                     // ""
string([]byte(nil))                                  // ""

type MyBytes []byte
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"
</pre>
</li>

<li>
将符文切片转换为字符串类型将产生一个已转换为字符串的单个符文值的串联字符串。

<pre>
string([]rune{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
string([]rune{})                         // ""
string([]rune(nil))                      // ""

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
</pre>
</li>

<li>
将字符串类型值转换为字节类型切片将产生一个连续元素为该字符串字节的切片。

<pre>
[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
[]byte("")        // []byte{}

MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
</pre>
</li>

<li>
将字符串类型的值转换为符文类型切片将产生一个包含该字符串单个 Unicode 码点的切片。

<pre>
[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
[]rune("")                 // []rune{}

MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}
</pre>
</li>
</ol>


<div class="english">
<h3 id="Constant_expressions">Constant expressions</h3>
</div>

<h3 id="常量表达式">常量表达式</h3>

<div class="english">
<p>
Constant expressions may contain only <a href="#Constants">constant</a>
operands and are evaluated at compile time.
</p>
</div>

<p>
常量表达式可只包含<a href="#常量">常量</a>操作数并在编译时求值。
</p>

<div class="english">
<p>
Untyped boolean, numeric, and string constants may be used as operands
wherever it is legal to use an operand of boolean, numeric, or string type,
respectively.
</p>
</div>

<p>
无类型化布尔、数值和字符串常量可被用作操作数，无论使用布尔、数值或字符串类型的操作数是否合法。
除移位操作外，若二元操作的操作数是不同种类的无类型化常量，对于非布尔操作，该操作与其结果使用出现在此列表中较后的种类：
整数、符文、浮点数、复数。例如，由无类型化复数常量分离的无类型化整数常量将产生一个无类型化复数常量。
</p>

<div class="english">
<p>
A constant <a href="#Comparison_operators">comparison</a> always yields
an untyped boolean constant.  If the left operand of a constant
<a href="#Operators">shift expression</a> is an untyped constant, the
result is an integer constant; otherwise it is a constant of the same
type as the left operand, which must be of
<a href="#Numeric_types">integer type</a>.
</p>

<p>
Any other operation on untyped constants results in an untyped constant of the
same kind; that is, a boolean, integer, floating-point, complex, or string
constant.
If the untyped operands of a binary operation (other than a shift) are of
different kinds, the result is of the operand's kind that appears later in this
list: integer, rune, floating-point, complex.
For example, an untyped integer constant divided by an
untyped complex constant yields an untyped complex constant.
</p>

<pre>
const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
const b = 15 / 4           // b == 3     (untyped integer constant)
const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)
const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)
const d = 1 &lt;&lt; 3.0         // d == 8     (untyped integer constant)
const e = 1.0 &lt;&lt; 3         // e == 8     (untyped integer constant)
const f = int32(1) &lt;&lt; 33   // illegal    (constant 8589934592 overflows int32)
const g = float64(2) &gt;&gt; 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" &gt; "bar"    // h == true  (untyped boolean constant)
const j = true             // j == true  (untyped boolean constant)
const k = 'w' + 1          // k == 'x'   (untyped rune constant)
const l = "hi"             // l == "hi"  (untyped string constant)
const m = string(k)        // m == "x"   (type string)
const Σ = 1 - 0.707i       //            (untyped complex constant)
const Δ = Σ + 2.0e-4       //            (untyped complex constant)
const Φ = iota*1i - 1/1i   //            (untyped complex constant)
</pre>
</div>

<p>
常量<a href="#比较操作符">比较</a>总是产生无类型化布尔常量。若常量<a href="#操作符">移位表达式</a>
的左操作数为无类型化常量，则该结果为整数常量；否则为与左操作数类型相同的常量，左操作数必须为<a href="#数值类型">整数类型</a>。
将其它所有操作符应用于同种类（即，布尔、整数、浮点数、复数或字符串常量）
无类型化常量的结果：
</p>

<pre>
const a = 2 + 3.0          // a == 5.0   （无类型化浮点数常量）
const b = 15 / 4           // b == 3     （无类型化整数常量）
const c = 15 / 4.0         // c == 3.75  （无类型化浮点数常量）
const Θ float64 = 3/2      // Θ == 1.0   （类型为 float64，3/2 是整数除法）
const Π float64 = 3/2.     // Π == 1.5   （类型为 float64，3/2. 是浮点数除法）
const d = 1 &lt;&lt; 3.0         // d == 8     （无类型化整数常量）
const e = 1.0 &lt;&lt; 3         // e == 8     （无类型化整数常量）
const f = int32(1) &lt;&lt; 33   // 非法    （常量 8589934592 溢出 int32）
const g = float64(2) &gt;&gt; 1  // 非法       （float64(2)为无类型化浮点数常量）
const h = "foo" &gt; "bar"    // h == true  （无类型化布尔常量）
const j = true             // j == true  （无类型化布尔常量）
const k = 'w' + 1          // k == 'x'   （无类型化符文常量）
const l = "hi"             // l == "hi"  （无类型化字符串常量）
const m = string(k)        // m == "x"   （类型为 string）
const Σ = 1 - 0.707i       //            （无类型化复数常量）
const Δ = Σ + 2.0e-4       //            （无类型化复数常量）
const Φ = iota*1i - 1/1i   //            （无类型化复数常量）
</pre>

<div class="english">
<p>
Applying the built-in function <code>complex</code> to untyped
integer, rune, or floating-point constants yields
an untyped complex constant.
</p>

<pre>
const ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)
const iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)
</pre>
</div>

<p>
将内建函数 <code>complex</code> 应用于无类型化整数、符文或浮点数常量将产生一个无类型化复数常量。
</p>

<pre>
const ic = complex(0, c)   // ic == 3.75i （无类型化复数常量）
const iΘ = complex(0, Θ)   // iΘ == 1i    （类型为 complex128）
</pre>

<div class="english">
<p>
Constant expressions are always evaluated exactly; intermediate values and the
constants themselves may require precision significantly larger than supported
by any predeclared type in the language. The following are legal declarations:
</p>
</div>

<p>
常量表达式总是精确地求值；中间值与该常量本身可能需要明显大于该语言中任何预声明类型所支持的精度。以下为合法声明：
</p>

<pre>
const Huge = 1 &lt;&lt; 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)
const Four int8 = Huge &gt;&gt; 98  // Four == 4                                (type int8)
</pre>

<div class="english">
<p>
The divisor of a constant division or remainder operation must not be zero:
</p>

<pre>
3.14 / 0.0   // illegal: division by zero
</pre>
</div>

<p>
常量除法或求余的除数必不能为零：
</p>

<pre>
3.14 / 0.0   // 非法：除以零
</pre>

<div class="english">
<p>
The values of <i>typed</i> constants must always be accurately
<a href="#Representability">representable</a> by values
of the constant type. The following constant expressions are illegal:
</p>

<pre>
uint(-1)     // -1 cannot be represented as a uint
int(3.14)    // 3.14 cannot be represented as an int
int64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64
Four * 300   // operand 300 cannot be represented as an int8 (type of Four)
Four * 100   // product 400 cannot be represented as an int8 (type of Four)
</pre>
</div>

<p>
<b>带类型</b>常量的值必须总是可被精确地<a href="#可表示性">表示</a>为该常量类型的值。
以下为非法常量表达式：
</p>

<pre>
uint(-1)     // -1 无法表示为 uint
int(3.14)    // 3.14 无法表示为 int
int64(Huge)  // 1267650600228229401496703205376 无法表示为 int64
Four * 300   // 操作数 300 无法表示为 int8（Four 的类型）
Four * 100   // 其结果 400 无法表示为 int8（Four 的类型）
</pre>

<div class="english">
<p>
The mask used by the unary bitwise complement operator <code>^</code> matches
the rule for non-constants: the mask is all 1s for unsigned constants
and -1 for signed and untyped constants.
</p>

<pre>
^1         // untyped integer constant, equal to -2
uint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8
^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // same as int8(-2)
^int8(1)   // same as -1 ^ int8(1) = -2
</pre>
</div>

<p>
用于一元按位补码操作符 <code>^</code> 的屏蔽与非常量相匹配的规则：对于无符号常量屏蔽全为 1，
而对于带符号或无类型化常量为 -1。
</p>

<pre>
^1         // 无类型化整数常量，等于 -2
uint8(^1)  // 非法，等价于 uint8(-2)，-2 无法表示为 uint8
^uint8(1)  // 类型化 uint8 常量，等价于 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // 等价于 int8(-2)
^int8(1)   // 等价于 -1 ^ int8(1) = -2
</pre>

<div class="english">
<p>
Implementation restriction: A compiler may use rounding while
computing untyped floating-point or complex constant expressions; see
the implementation restriction in the section
on <a href="#Constants">constants</a>.  This rounding may cause a
floating-point constant expression to be invalid in an integer
context, even if it would be integral when calculated using infinite
precision, and vice versa.
</p>
</div>

<p>
实现限制：在计算无类型化浮点数或复数常量表达式时，编译器可能使用舍入，参考章节<a href="#常量">常量</a>
的实现限制。次舍入可能会导致浮点常量表达式在整数上下文中无效，即使在它使用无限精度计算时会成为整体，反之亦然。
</p>


<div class="english">
<h3 id="Order_of_evaluation">Order of evaluation</h3>
</div>

<h3 id="求值顺序">求值顺序</h3>

<div class="english">
<p>
At package level, <a href="#Package_initialization">initialization dependencies</a>
determine the evaluation order of individual initialization expressions in
<a href="#Variable_declarations">variable declarations</a>.
Otherwise, when evaluating the <a href="#Operands">operands</a> of an
expression, assignment, or
<a href="#Return_statements">return statement</a>,
all function calls, method calls, and
communication operations are evaluated in lexical left-to-right
order.
</p>
</div>

<p>
在包级别内，<a href="#包初始化">初始化依赖</a>确定了
<a href="#变量声明">变量声明</a> 内独立初始化与局的求值顺序。
否则，当对一个表达式、赋值或<a href="#Return语句">返回语句</a>的
<a href="#操作数">操作数</a> 进行求值时，
所有函数调用、方法调用以及通信操作均按从左到右的词法顺序求值。
</p>

<div class="english">
<p>
For example, in the (function-local) assignment
</p>
</div>

<p>
例如，在（函数局部）赋值
</p>

<pre>
y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()
</pre>

<div class="english">
<p>
the function calls and communication happen in the order
<code>f()</code>, <code>h()</code>, <code>i()</code>, <code>j()</code>,
<code>&lt;-c</code>, <code>g()</code>, and <code>k()</code>.
However, the order of those events compared to the evaluation
and indexing of <code>x</code> and the evaluation
of <code>y</code> is not specified.
</p>

<pre>
a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified
m := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified
n := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified
</pre>
</div>

<p>
中，函数调用与通信按顺序 <code>f()</code>、<code>h()</code>、<code>i()</code>、<code>j()</code>、
<code>&lt;-c</code>、<code>g()</code> 和 <code>k()</code> 发生。然而，相较于这些事件的顺序，<code>x</code>
的求值与索引及 <code>y</code> 的求值并未指定。
</p>

<pre>
a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x 可能为 [1, 2] 或 [2, 2]：a 与 f() 之间的求值顺序并未指定
m := map[int]int{a: 1, a: 2}  // m 可能为 {2: 1} 或 {2: 2}：两个映射赋值之间的求值顺序并未指定
n := map[int]int{a: f()}      // n 可能为 {2: 3} 或 {3: 3}：键和值之间的求值顺序并未指定
</pre>

<div class="english">
<p>
At package level, initialization dependencies override the left-to-right rule
for individual initialization expressions, but not for operands within each
expression:
</p>
</div>

<p>
在包级别内，初始化依赖覆盖了独立初始化从左到右的规则，但不会影响到每个表达式中的操作数：
</p>

<div class="english">
<pre>
var a, b, c = f() + v(), g(), sqr(u()) + v()

func f() int        { return c }
func g() int        { return a }
func sqr(x int) int { return x*x }

// functions u and v are independent of all other variables and functions
</pre>
</div>

<pre>
var a, b, c = f() + v(), g(), sqr(u()) + v()

func f() int        { return c }
func g() int        { return a }
func sqr(x int) int { return x*x }

// 函数 u 和 v 独立于其它所有变量和函数
</pre>

<div class="english">
<p>
The function calls happen in the order
<code>u()</code>, <code>sqr()</code>, <code>v()</code>,
<code>f()</code>, <code>v()</code>, and <code>g()</code>.
</p>
</div>

<p>
函数调用按 <code>u()</code>、<code>sqr()</code>、<code>v()</code>、
<code>f()</code>、<code>v()</code>、<code>g()</code> 的顺序发生。
</p>

<div class="english">
<p>
Floating-point operations within a single expression are evaluated according to
the associativity of the operators.  Explicit parentheses affect the evaluation
by overriding the default associativity.
In the expression <code>x + (y + z)</code> the addition <code>y + z</code>
is performed before adding <code>x</code>.
</p>
</div>

<p>
单表达式中的浮点数操作根据该操作符的结合性求值。显式的圆括号通过覆盖默认结合性来影响求值。
在表达式 <code>x + (y + z)</code> 中，加法 <code>y + z</code> 会在与 <code>x</code> 相加前执行。
</p>

<div class="english">
<h2 id="Statements">Statements</h2>
</div>

<h2 id="语句">语句</h2>

<div class="english">
<p>
Statements control execution.
</p>

<pre class="ebnf">
Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</pre>
</div>

<p>
语句控制执行。
</p>

<pre class="ebnf">
语句 =
	声明 | 标签语句 | 简单语句 |
	Go语句 | Return语句 | Break语句 | Continue语句 | Goto语句 |
	Fallthrough语句 | 块 | If语句 | Switch语句 | Select语句 | For语句 |
	Defer语句 .

简单语句 = 空语句 | 表达式语句 | 发送语句 | 递增递减语句 | 赋值 | 短变量声明 .
</pre>

<div class="english">
<h3 id="Terminating_statements">Terminating statements</h3>
</div>

<h3 id="终止语句">终止语句</h3>

<div class="english">
<p>
A <i>terminating statement</i> prevents execution of all statements that lexically
appear after it in the same <a href="#Blocks">block</a>. The following statements
are terminating:
</p>

<ol>
<li>
	A <a href="#Return_statements">"return"</a> or
    	<a href="#Goto_statements">"goto"</a> statement.
	<!-- ul below only for regular layout -->
	<ul> </ul>
</li>

<li>
	A call to the built-in function
	<a href="#Handling_panics"><code>panic</code></a>.
	<!-- ul below only for regular layout -->
	<ul> </ul>
</li>

<li>
	A <a href="#Blocks">block</a> in which the statement list ends in a terminating statement.
	<!-- ul below only for regular layout -->
	<ul> </ul>
</li>

<li>
	An <a href="#If_statements">"if" statement</a> in which:
	<ul>
	<li>the "else" branch is present, and</li>
	<li>both branches are terminating statements.</li>
	</ul>
</li>

<li>
	A <a href="#For_statements">"for" statement</a> in which:
	<ul>
	<li>there are no "break" statements referring to the "for" statement, and</li>
	<li>the loop condition is absent.</li>
	</ul>
</li>

<li>
	A <a href="#Switch_statements">"switch" statement</a> in which:
	<ul>
	<li>there are no "break" statements referring to the "switch" statement,</li>
	<li>there is a default case, and</li>
	<li>the statement lists in each case, including the default, end in a terminating
	    statement, or a possibly labeled <a href="#Fallthrough_statements">"fallthrough"
	    statement</a>.</li>
	</ul>
</li>

<li>
	A <a href="#Select_statements">"select" statement</a> in which:
	<ul>
	<li>there are no "break" statements referring to the "select" statement, and</li>
	<li>the statement lists in each case, including the default if present,
	    end in a terminating statement.</li>
	</ul>
</li>

<li>
	A <a href="#Labeled_statements">labeled statement</a> labeling
	a terminating statement.
</li>
</ol>

<p>
All other statements are not terminating.
</p>
</div>

<p>
终止语句为以下之一：
</p>

<ol>
<li>
	一个<a href="#Return语句">"return"</a> 或
		<a href="#Goto语句">"goto"</a> 语句。
	<!-- 下面的 ul 用于规划布局 -->
	<ul> </ul>
</li>

<li>
	一个内建函数 <a href="#处理恐慌"><code>panic</code></a> 的调用。
	<!-- 下面的 ul 用于规划布局 -->
	<ul> </ul>
</li>

<li>
	一个语句列表以终止语句结束的<a href="#块">块</a>。
	<!-- 下面的 ul 用于规划布局 -->
	<ul> </ul>
</li>

<li>
	一个 <a href="#If_statements">"if" 语句</a>，其中：
	<ul>
	<li>存在 "else" 分支，且</li>
	<li>两个分支均以终止语句结束。</li>
	</ul>
</li>

<li>
	一个 <a href="#For语句">"for" 语句</a>，其中：
	<ul>
	<li>没有 "break" 语句引用到该 "for" 语句，且</li>
	<li>缺少循环条件。</li>
	</ul>
</li>

<li>
	一个 <a href="#Switch语句">"switch" 语句</a>，其中：
	<ul>
	<li>没有 "break" 语句引用到该 "switch" 语句，</li>
	<li>没有默认分支，且</li>
	<li>包括默认分支，每一个分支中的语句列表均以终止语句结束，或一个可能带标签的
	    <a href="#Fallthrough语句">"fallthrough" 语句</a>。</li>
	</ul>
</li>

<li>
	一个 <a href="#Select语句">"select" 语句</a>，其中：
	<ul>
	<li>没有 "break" 语句引用到该 "select" 语句，且</li>
	<li>包括默认分支（如果有的话），每一个分支中的语句列表均以终止语句结束。</li>
	</ul>
</li>

<li>
	一个标在终止语句上的<a href="#标签语句">标签语句</a>。
</li>
</ol>

<p>
其它所有语句均非终止语句。
</p>

<div class="english">
<p>
A <a href="#Blocks">statement list</a> ends in a terminating statement if the list
is not empty and its final non-empty statement is terminating.
</p>
</div>

<p>
若<a href="#块">语句列表</a>非空且其最后一个非空语句为终止语句，那么它以终止语句结束。
</p>

<div class="english">
<h3 id="Empty_statements">Empty statements</h3>
</div>

<h3 id="空语句">空语句</h3>

<div class="english">
<p>
The empty statement does nothing.
</p>

<pre class="ebnf">
EmptyStmt = .
</pre>
</div>

<p>
空语句不执行任何操作。
</p>

<pre class="ebnf">
空语句 = .
</pre>


<div class="english">
<h3 id="Labeled_statements">Labeled statements</h3>
</div>

<h3 id="标签语句">标签语句</h3>

<div class="english">
<p>
A labeled statement may be the target of a <code>goto</code>,
<code>break</code> or <code>continue</code> statement.
</p>

<pre class="ebnf">
LabeledStmt = Label ":" Statement .
Label       = identifier .
</pre>
</div>

<p>
标签语句可作为 <code>goto</code>、<code>break</code> 或 <code>continue</code> 语句的目标
</p>

<pre class="ebnf">
标签语句 = 标签 ":" 语句 .
标签     = 标识符 .
</pre>

<pre>
Error: log.Panic("error encountered")
</pre>


<div class="english">
<h3 id="Expression_statements">Expression statements</h3>
</div>

<h3 id="表达式语句">表达式语句</h3>

<div class="english">
<p>
With the exception of specific built-in functions,
function and method <a href="#Calls">calls</a> and
<a href="#Receive_operator">receive operations</a>
can appear in statement context. Such statements may be parenthesized.
</p>

<pre class="ebnf">
ExpressionStmt = Expression .
</pre>
</div>

<p>
除特殊的内建函数外，函数与方法的<a href="#调用">调用</a>及
<a href="#接收操作">接收操作</a>均可出现在语句上下文中。这样的语句可能需要加小括号。
</p>

<pre class="ebnf">
表达式语句 = 表达式 .
</pre>

<div class="english">
<p>
The following built-in functions are not permitted in statement context:
</p>
</div>

<p>
以下内建函数不允许出现在语句上下文中：
</p>

<pre>
append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
</pre>

<div class="english">
<pre>
h(x+y)
f.Close()
&lt;-ch
(&lt;-ch)
len("foo")  // illegal if len is the built-in function
</pre>
</div>

<pre>
h(x+y)
f.Close()
&lt;-ch
(&lt;-ch)
len("foo")  // 若 len 为内建函数即为非法
</pre>


<div class="english">
<h3 id="Send_statements">Send statements</h3>
</div>

<h3 id="发送语句">发送语句</h3>

<div class="english">
<p>
A send statement sends a value on a channel.
The channel expression must be of <a href="#Channel_types">channel type</a>,
the channel direction must permit send operations,
and the type of the value to be sent must be <a href="#Assignability">assignable</a>
to the channel's element type.
</p>

<pre class="ebnf">
SendStmt = Channel "&lt;-" Expression .
Channel  = Expression .
</pre>
</div>

<p>
发送语句在信道上发送值。信道表达式必须为<a href="#信道类型">信道类型</a>，
信道的方向必须允许发送操作，且被发送的值的类型必须<a href="#可赋值性">可赋予</a>该信道的元素类型。
</p>

<pre class="ebnf">
发送语句 = 信道 "&lt;-" 表达式 .
信道     = 表达式 .
</pre>

<div class="english">
<p>
Both the channel and the value expression are evaluated before communication
begins. Communication blocks until the send can proceed.
A send on an unbuffered channel can proceed if a receiver is ready.
A send on a buffered channel can proceed if there is room in the buffer.
A send on a closed channel proceeds by causing a <a href="#Run_time_panics">run-time panic</a>.
A send on a <code>nil</code> channel blocks forever.
</p>
</div>

<p>
信道与值表达式均在通信开始前求值。通信会阻塞，直到发送可继续进行。
若接收者已就绪，在无缓存信道上发送可继续进行。
若缓存中有空间，在有缓存信道上发送可继续进行。
在已关闭信道上进行发送会引发一个<a href="#运行时恐慌">运行时恐慌</a>。
在 <code>nil</code> 信道上进行发送将永远阻塞。
</p>

<div class="english">
<pre>
ch &lt;- 3  // send value 3 to channel ch
</pre>
</div>

<pre>
ch &lt;- 3  // 发送值 3 至信道 ch
</pre>


<div class="english">
<h3 id="IncDec_statements">IncDec statements</h3>
</div>

<h3 id="递增递减语句">递增递减语句</h3>

<div class="english">
<p>
The "++" and "--" statements increment or decrement their operands
by the untyped <a href="#Constants">constant</a> <code>1</code>.
As with an assignment, the operand must be <a href="#Address_operators">addressable</a>
or a map index expression.
</p>

<pre class="ebnf">
IncDecStmt = Expression ( "++" | "--" ) .
</pre>
</div>

<p>
"++" 与 "--" 语句会以无类型化<a href="#常量">常量</a> <code>1</code> 来递增或递减它们的操作数。
就赋值来说，操作数必须为<a href="#可寻址的">可寻址的</a>，或为映射的下标表达式。
</p>

<pre class="ebnf">
递增递减语句 = 表达式 ( "++" | "--" ) .
</pre>

<div class="english">
<p>
The following <a href="#Assignments">assignment statements</a> are semantically
equivalent:
</p>

<pre class="grammar">
IncDec statement    Assignment
x++                 x += 1
x--                 x -= 1
</pre>
</div>

<p>
以下<a href="#赋值">赋值语句</a>在语义上等价：
</p>

<pre class="grammar">
递增递减语句        赋值
x++                 x += 1
x--                 x -= 1
</pre>


<div class="english">
<h3 id="Assignments">Assignments</h3>
</div>

<h3 id="赋值">赋值</h3>

<div class="english">
<pre class="ebnf">
Assignment = ExpressionList assign_op ExpressionList .

assign_op = [ add_op | mul_op ] "=" .
</pre>
</div>

<pre class="ebnf">
赋值 = 表达式列表 赋值操作符 表达式列表 .

赋值操作符 = [ 加法操作符 | 乘法操作符 ] "=" .
</pre>

<div class="english">
<p>
Each left-hand side operand must be <a href="#Address_operators">addressable</a>,
a map index expression, or (for <code>=</code> assignments only) the
<a href="#Blank_identifier">blank identifier</a>.
Operands may be parenthesized.
</p>

<pre>
x = 1
*p = f()
a[i] = 23
(k) = &lt;-ch  // same as: k = &lt;-ch
</pre>
</div>

<p>
每个左操作数必须为<a href="#地址操作符">可寻址的</a>、映射下标表达式或（仅对于 <code>=</code>
赋值）<a href="#空白标识符">空白标识符</a>。操作数可加小括号。
</p>

<pre>
x = 1
*p = f()
a[i] = 23
(k) = &lt;-ch  // 等价于：k = &lt;-ch
</pre>

<div class="english">
<p>
An <i>assignment operation</i> <code>x</code> <i>op</i><code>=</code>
<code>y</code> where <i>op</i> is a binary <a href="#Arithmetic_operators">arithmetic operator</a>
is equivalent to <code>x</code> <code>=</code> <code>x</code> <i>op</i>
<code>(y)</code> but evaluates <code>x</code>
only once.  The <i>op</i><code>=</code> construct is a single token.
In assignment operations, both the left- and right-hand expression lists
must contain exactly one single-valued expression, and the left-hand
expression must not be the blank identifier.
</p>
</div>

<p>
<b>赋值操作</b> <code>x</code> <i>op</i><code>=</code> <code>y</code>，其中 <i>op</i> 为一个二元<a href="#算术操作符">算术操作符</a>，它等价于
<code>x</code> <code>=</code> <code>x</code> <i>op</i> <code>(y)</code>，但只对 <code>x</code> 求值一次。
<i>op</i><code>=</code> 为单个标记。在赋值操作中，左、右表达式列表必须均刚好包含一个单值表达式，
且左表达式必须不为空白标识符。
</p>

<pre>
a[i] &lt;&lt;= 2
i &amp;^= 1&lt;&lt;n
</pre>

<div class="english">
<p>
A tuple assignment assigns the individual elements of a multi-valued
operation to a list of variables.  There are two forms.  In the
first, the right hand operand is a single multi-valued expression
such as a function call, a <a href="#Channel_types">channel</a> or
<a href="#Map_types">map</a> operation, or a <a href="#Type_assertions">type assertion</a>.
The number of operands on the left
hand side must match the number of values.  For instance, if
<code>f</code> is a function returning two values,
</p>

<pre>
x, y = f()
</pre>

<p>
assigns the first value to <code>x</code> and the second to <code>y</code>.
In the second form, the number of operands on the left must equal the number
of expressions on the right, each of which must be single-valued, and the
<i>n</i>th expression on the right is assigned to the <i>n</i>th
operand on the left:
</p>

<pre>
one, two, three = '一', '二', '三'
</pre>
</div>

<p>
元组赋值将多值操作的个体元素赋予变量列表。它有两种形式。首先，右操作数为单个多值表达式，比如一个函数调用、
<a href="#信道类型">信道</a>、<a href="#映射类型">映射</a>操作或一个<a href="#类型断言">类型断言</a>。
左操作数的数量必须与值的数量相匹配。例如，若 <code>f</code> 为返回两个值的函数，则
</p>

<pre>
x, y = f()
</pre>

<p>
会将第一个值赋予 <code>x</code>，而第二个值则会赋予 <code>y</code>。
在第二种形式中，左侧操作数的数量必须等于右侧表达式的数量，其中每一个必须为单值，且右侧第
<i>n</i> 个表达式赋予左侧第 <i>n</i> 个操作数：
</p>

<pre>
one, two, three = '一', '二', '三'
</pre>

<div class="english">
<p>
The <a href="#Blank_identifier">blank identifier</a> provides a way to
ignore right-hand side values in an assignment:
</p>

<pre>
_ = x       // evaluate x but ignore it
x, _ = f()  // evaluate f() but ignore second result value
</pre>
</div>

<p>
<a href="#空白标识符">空白标识符</a> 提供了一种在赋值中忽略右侧值的方法：
</p>

<pre>
_ = x       // 求值 x 但忽略它
x, _ = f()  // 求值 f() 但忽略第二个结果值
</pre>

<div class="english">
<p>
The assignment proceeds in two phases.
First, the operands of <a href="#Index_expressions">index expressions</a>
and <a href="#Address_operators">pointer indirections</a>
(including implicit pointer indirections in <a href="#Selectors">selectors</a>)
on the left and the expressions on the right are all
<a href="#Order_of_evaluation">evaluated in the usual order</a>.
Second, the assignments are carried out in left-to-right order.
</p>

<pre>
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)

x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // set i, x[2] = 0, x[0]
	break
}
// after this loop, i == 0 and x == []int{3, 5, 3}
</pre>
</div>

<p>
赋值过程分为两个阶段。
首先，左边的<a href="#下标表达式">下标表达式</a>与<a href="#地址操作符">指针间接寻址</a>的操作数
（包括<a href="#选择器">选择器</a>中隐式的指针间接寻址）和右边的表达式都会<a href="#求值顺序">按通常顺序求值</a>。
其次，赋值会按照从左到右的顺序进行。
</p>

<pre>
a, b = b, a  // 交换 a 和 b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // 置 i = 1，x[0] = 2

i = 0
x[i], i = 2, 1  // 置 x[0] = 2，i = 1

x[0], x[0] = 1, 2  // 置 x[0] = 1，然后置 x[0] = 2（因此最后 x[0] == 2）

x[1], x[3] = 4, 5  // 置 x[1] = 4，然后恐慌置 x[3] = 5

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // 置 x[2] = 6，然后恐慌置 p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // 置 i, x[2] = 0, x[0]
	break
}
// 该循环结束之后，i == 0 且 x == []int{3, 5, 3}
</pre>

<div class="english">
<p>
In assignments, each value must be <a href="#Assignability">assignable</a>
to the type of the operand to which it is assigned, with the following special cases:
</p>

<ol>
<li>
	Any typed value may be assigned to the blank identifier.
</li>

<li>
	If an untyped constant
	is assigned to a variable of interface type or the blank identifier,
	the constant is first implicitly <a href="#Conversions">converted</a> to its
	 <a href="#Constants">default type</a>.
</li>

<li>
	If an untyped boolean value is assigned to a variable of interface type or
	the blank identifier, it is first implicitly converted to type <code>bool</code>.
</li>
</ol>
</div>

<p>
在赋值中，每个值必须<a href="#可赋值性">可赋予</a>被赋值操作数的类型，以下为特殊情况：
</p>

<ol>
<li>
	任何类型化值均可赋予空白标识符。
</li>

<li>
	若一个无类型化常量被赋予一个接口类型的变量或空白标识符，该常量首先会
	<a href="#转换">转换</a>为其<a href="#常量">默认类型</a>。
</li>

<li>
	若无类型化布尔值被赋予一个接口类型的变量或空白标识符，它首先会被隐式转换为布尔类型。
</li>
</ol>


<div class="english">
<h3 id="If_statements">If statements</h3>
</div>

<h3 id="If语句">If语句</h3>

<div class="english">
<p>
"If" statements specify the conditional execution of two branches
according to the value of a boolean expression.  If the expression
evaluates to true, the "if" branch is executed, otherwise, if
present, the "else" branch is executed.
</p>

<pre class="ebnf">
IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
</pre>
</div>

<p>
"If"语句根据一个布尔表达式的值指定两个分支的条件来执行。
若该表达式求值为 true，则执行"if"分支，否则执行"else"分支。
</p>

<pre class="ebnf">
If语句 = "if" [ 简单语句 ";" ] 表达式 块 [ "else" ( If语句 | 块 ) ] .
</pre>

<pre>
if x &gt; max {
	x = max
}
</pre>

<div class="english">
<p>
The expression may be preceded by a simple statement, which
executes before the expression is evaluated.
</p>
</div>

<p>
简单语句可能先于表达式，它将在表达式求值前执行。
</p>

<pre>
if x := f(); x &lt; y {
	return x
} else if x &gt; z {
	return z
} else {
	return y
}
</pre>


<div class="english">
<h3 id="Switch_statements">Switch statements</h3>
</div>

<h3 id="Switch语句">Switch语句</h3>

<div class="english">
<p>
"Switch" statements provide multi-way execution.
An expression or type specifier is compared to the "cases"
inside the "switch" to determine which branch
to execute.
</p>

<pre class="ebnf">
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
</pre>
</div>

<p>
"Switch"语句提供多路执行。表达式或类型说明符与"switch"中的"cases"相比较从而决定执行哪一分支。
</p>

<pre class="ebnf">
Switch语句 = 表达式选择语句 | 类型选择语句 .
</pre>

<div class="english">
<p>
There are two forms: expression switches and type switches.
In an expression switch, the cases contain expressions that are compared
against the value of the switch expression.
In a type switch, the cases contain types that are compared against the
type of a specially annotated switch expression.
The switch expression is evaluated exactly once in a switch statement.
</p>
</div>

<p>
它有两种形式：表达式选择与类型选择。在表达式选择中，case 包含的表达式针对 switch 表达式的值进行比较，
在类型选择中，case 包含的类型针对特别注明的 switch 表达式的类型进行比较。
switch 表达式在 switch 语句中刚好求值一次。
</p>

<div class="english">
<h4 id="Expression_switches">Expression switches</h4>
</div>

<h4 id="表达式选择">表达式选择</h4>

<div class="english">
<p>
In an expression switch,
the switch expression is evaluated and
the case expressions, which need not be constants,
are evaluated left-to-right and top-to-bottom; the first one that equals the
switch expression
triggers execution of the statements of the associated case;
the other cases are skipped.
If no case matches and there is a "default" case,
its statements are executed.
There can be at most one default case and it may appear anywhere in the
"switch" statement.
A missing switch expression is equivalent to the boolean value
<code>true</code>.
</p>

<pre class="ebnf">
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprCaseClause = ExprSwitchCase ":" StatementList .
ExprSwitchCase = "case" ExpressionList | "default" .
</pre>
</div>

<p>

在表达式选择中，switch 表达式会被求值，而 case 表达式无需为常量，它按从上到下，从左到右的顺序求值；
第一个等于 switch 表达式的 case 表达式将引发相应情况的语句的执行；其它的情况将被跳过。
若没有情况匹配且有"default"情况，则该语句将被执行。
最多只能有一个默认情况且它可以出现在"switch"语句的任何地方。
缺失的 switch 表达式等价于布尔值 <code>true</code>。
</p>

<pre class="ebnf">
表达时选择语句 = "switch" [ 简单语句 ";" ] [ 表达式 ] "{" { 表达式情况子句 } "}" .
表达式情况子句 = 表达式选择情况 ":" 语句列表 .
表达式选择情况 = "case" 表达式列表 | "default" .
</pre>

<div class="english">
<p>
If the switch expression evaluates to an untyped constant, it is first implicitly
<a href="#Conversions">converted</a> to its <a href="#Constants">default type</a>;
if it is an untyped boolean value, it is first implicitly converted to type <code>bool</code>.
The predeclared untyped value <code>nil</code> cannot be used as a switch expression.
</p>
</div>

<p>
若 switch 求值出一个无类型化的常量，它首先会隐式<a href="#类型转换">转换</a>为其<a href="#常量">默认类型</a>；
若它是无类型化的布尔值，它首先会转换为 <code>bool</code> 类型。
预声明的无类型化值 <code>nil</code> 无法用作 switch 表达式。
</p>

<div class="english">
<p>
If a case expression is untyped, it is first implicitly <a href="#Conversions">converted</a>
to the type of the switch expression.
For each (possibly converted) case expression <code>x</code> and the value <code>t</code>
of the switch expression, <code>x == t</code> must be a valid <a href="#Comparison_operators">comparison</a>.
</p>
</div>

<p>
若 case 表达式为无类型化的，它首先会隐式<a href="#类型转换">转换</a>为 switch 表达式的类型。
对于每个（可能已转换的）case 表达式 <code>x</code> 与 switch 表达式的值 <code>t</code>，
<code>x == t</code> 必须为有效的 <a href="#比较操作符">比较</a>。
</p>

<div class="english">
<p>
In other words, the switch expression is treated as if it were used to declare and
initialize a temporary variable <code>t</code> without explicit type; it is that
value of <code>t</code> against which each case expression <code>x</code> is tested
for equality.
</p>
</div>

<p>
换句话说，switch 表达式可视作用它来声明并初始化变量 <code>t</code> 而不显示指定类型，
并用 <code>t</code> 的值对每一个 case 表达式 <code>x</code> 测试是否相等。
</p>

<div class="english">
<p>
In a case or default clause, the last non-empty statement
may be a (possibly <a href="#Labeled_statements">labeled</a>)
<a href="#Fallthrough_statements">"fallthrough" statement</a> to
indicate that control should flow from the end of this clause to
the first statement of the next clause.
Otherwise control flows to the end of the "switch" statement.
A "fallthrough" statement may appear as the last statement of all
but the last clause of an expression switch.
</p>
</div>

<p>
在 case 或 default 子句中，最后一个非空语句可能为（可能<a href="#带标签语句">带标签</a>的）
<a href="#Fallthrough语句">"fallthrough" 语句</a>
它表明该控制流应从该子句的结尾转至下一个子句的第一个语句。
否则，控制流转至该"switch"语句的结尾。
"fallthrough" 语句可出现在 switch 表达式中除最后一个子句外所有子句的末尾。
</p>

<div class="english">
<p>
The switch expression may be preceded by a simple statement, which
executes before the expression is evaluated.
</p>

<pre>
switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // missing switch expression means "true"
case x &lt; 0: return -x
default: return x
}

switch {
case x &lt; y: f1()
case x &lt; z: f2()
case x == 4: f3()
}
</pre>
</div>

<p>
简单语句可能先于 switch 表达式，它将在表达式求值前执行。
</p>

<pre>
switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // 缺失的 switch 表达式意为"true"
case x &lt; 0: return -x
default: return x
}

switch {
case x &lt; y: f1()
case x &lt; z: f2()
case x == 4: f3()
}
</pre>

<div class="english">
<p>
Implementation restriction: A compiler may disallow multiple case
expressions evaluating to the same constant.
For instance, the current compilers disallow duplicate integer,
floating point, or string constants in case expressions.
</p>
</div>

<p>
实现限制：编译器可能不允许多个 case 表达式求值为同一个常量。
例如，当前的编译器不允许 case 表达式出现重复的整数、浮点数或字符串常量。
</p>


<div class="english">
<h4 id="Type_switches">Type switches</h4>
</div>

<h4 id="类型选择">类型选择</h4>

<div class="english">
<p>
A type switch compares types rather than values. It is otherwise similar
to an expression switch. It is marked by a special switch expression that
has the form of a <a href="#Type_assertions">type assertion</a>
using the reserved word <code>type</code> rather than an actual type:
</p>

<pre>
switch x.(type) {
// cases
}
</pre>

<p>
Cases then match actual types <code>T</code> against the dynamic type of the
expression <code>x</code>. As with type assertions, <code>x</code> must be of
<a href="#Interface_types">interface type</a>, and each non-interface type
<code>T</code> listed in a case must implement the type of <code>x</code>.
</p>

<pre class="ebnf">
TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeCaseClause  = TypeSwitchCase ":" StatementList .
TypeSwitchCase  = "case" TypeList | "default" .
TypeList        = Type { "," Type } .
</pre>
</div>

<p>
类型选择比较类型而非值。它与表达式选择并不相似。它被一个特殊的 switch 表达式标记，
该表达式为使用保留字 <code>type</code> 而非实际类型的<a href="#类型断言">类型断言</a>的形式：
</p>

<pre>
switch x.(type) {
// cases
}
</pre>

<p>
此时的 case 针对表达式 <code>x</code> 的动态类型匹配实际的类型 <code>T</code>。
就像类型断言一样，<code>x</code> 必须为<a href="#接口类型">接口类型</a>，
而每一个在 case 中列出的非接口类型 <code>T</code> 必须实现了 <code>x</code> 的类型。
</p>

<pre class="ebnf">
类型选择语句 = "switch" [ 简单语句 ";" ] 类型选择监视 "{" { 类型情况子句 } "}" .
类型选择监视 = [ 标识符 ":=" ] 主表达式 "." "(" "type" ")" .
类型情况子句 = 类型选择情况 ":" 语句列表 .
类型选择情况 = "case" 类型列表 | "default" .
类型列表     = 类型 { "," 类型 } .
</pre>

<div class="english">
<p>
The TypeSwitchGuard may include a
<a href="#Short_variable_declarations">short variable declaration</a>.
When that form is used, the variable is declared at the end of the
TypeSwitchCase in the <a href="#Blocks">implicit block</a> of each clause.
In clauses with a case listing exactly one type, the variable
has that type; otherwise, the variable has the type of the expression
in the TypeSwitchGuard.
</p>
</div>

<p>
类型选择监视可包含一个<a href="#短变量声明">短变量声明</a>。
当使用此形式时，变量会在每个子句的<a href="#块">隐式块</a>中类型选择情况的末尾处声明。
在 case 列表刚好只有一个类型的子句中，该变量即拥有此类型；否则，该变量拥有在类型选择监视中表达式的类型。
</p>

<div class="english">
<p>
Instead of a type, a case may use the predeclared identifier
<a href="#Predeclared_identifiers"><code>nil</code></a>;
that case is selected when the expression in the TypeSwitchGuard
is a <code>nil</code> interface value.
There may be at most one <code>nil</code> case.
</p>
</div>

<p>
除类型外，case 也可为 <a href="#预声明标识符"><code>nil</code></a>，
这种情况在类型选择监视中的表达式为 <code>nil</code> 接口值时使用。
此处最多有一种 <code>nil</code> 的情况。
</p>

<div class="english">
<p>
Given an expression <code>x</code> of type <code>interface{}</code>,
the following type switch:
</p>

<pre>
switch i := x.(type) {
case nil:
	printString("x is nil")                // type of i is type of x (interface{})
case int:
	printInt(i)                            // type of i is int
case float64:
	printFloat64(i)                        // type of i is float64
case func(int) float64:
	printFunction(i)                       // type of i is func(int) float64
case bool, string:
	printString("type is bool or string")  // type of i is type of x (interface{})
default:
	printString("don't know the type")     // type of i is type of x (interface{})
}
</pre>

<p>
could be rewritten:
</p>

<pre>
v := x  // x is evaluated exactly once
if v == nil {
	i := v                                 // type of i is type of x (interface{})
	printString("x is nil")
} else if i, isInt := v.(int); isInt {
	printInt(i)                            // type of i is int
} else if i, isFloat64 := v.(float64); isFloat64 {
	printFloat64(i)                        // type of i is float64
} else if i, isFunc := v.(func(int) float64); isFunc {
	printFunction(i)                       // type of i is func(int) float64
} else {
	_, isBool := v.(bool)
	_, isString := v.(string)
	if isBool || isString {
		i := v                         // type of i is type of x (interface{})
		printString("type is bool or string")
	} else {
		i := v                         // type of i is type of x (interface{})
		printString("don't know the type")
	}
}
</pre>
</div>

<p>
给定类型为 <code>interface{}</code> 的表达式 <code>x</code>，以下类型选择：
</p>

<pre>
switch i := x.(type) {
case nil:
	printString("x is nil")                // i 的类型为 x 的类型（interface{}）
case int:
	printInt(i)                            // i 的类型为 int
case float64:
	printFloat64(i)                        // i 的类型为 float64
case func(int) float64:
	printFunction(i)                       // i 的类型为 func(int) float64
case bool, string:
	printString("type is bool or string")  // i 的类型为 x 的类型（interface{}）
default:
	printString("don't know the type")     // i 的类型为 x 的类型（interface{}）
}
</pre>

<p>
可被重写为：
</p>

<pre>
v := x  // x 只被求值一次
if v == nil {
	i := v                                 // i 的类型为 x 的类型（interface{}）
	printString("x is nil")
} else if i, isInt := v.(int); isInt {
	printInt(i)                            // i 的类型为 int
} else if i, isFloat64 := v.(float64); isFloat64 {
	printFloat64(i)                        // i 的类型为 float64
} else if i, isFunc := v.(func(int) float64); isFunc {
	printFunction(i)                       // i 的类型为 func(int) float64
} else {
	_, isBool := v.(bool)
	_, isString := v.(string)
	if isBool || isString {
		i := v                         // i 的类型为 x 的类型（interface{}）
		printString("type is bool or string")
	} else {
		i := v                         // i 的类型为 x 的类型（interface{}）
		printString("don't know the type")
	}
}
</pre>

<div class="english">
<p>
The type switch guard may be preceded by a simple statement, which
executes before the guard is evaluated.
</p>
</div>

<p>
简单语句可能先于类型选择监视，它将在类型选择监视求值前执行。
</p>

<div class="english">
<p>
The "fallthrough" statement is not permitted in a type switch.
</p>
</div>

<p>
"fallthrough"语句在类型选择中不被允许。
</p>

<div class="english">
<h3 id="For_statements">For statements</h3>
</div>

<h3 id="For语句">For语句</h3>

<div class="english">
<p>
A "for" statement specifies repeated execution of a block. There are three forms:
The iteration may be controlled by a single condition, a "for" clause, or a "range" clause.
</p>

<pre class="ebnf">
ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
</pre>
</div>

<p>
"for"语句指定块的重复执行。它有三种形式：迭代通过条件、"for"子句或"range"子句控制。
</p>

<pre class="ebnf">
For语句 = "for" [ 条件 | For子句 | Range子句 ] 块 .
条件 = 表达式 .
</pre>

<div class="english">
<h4 id="For_condition">For statements with single condition</h4>
</div>

<h4 id="For条件">单条件 for 语句</h4>

<div class="english">
<p>
In its simplest form, a "for" statement specifies the repeated execution of
a block as long as a boolean condition evaluates to true.
The condition is evaluated before each iteration.
If the condition is absent, it is equivalent to the boolean value
<code>true</code>.
</p>
</div>

<p>
在最简单的形式中，只要布尔条件求值为真，"for"语句指定的块就重复执行。
条件会在每次迭代前求值。若缺少条件，则它等价于布尔值 <code>true</code>。
</p>

<pre>
for a &lt; b {
	a *= 2
}
</pre>

<div class="english">
<h4 id="For_clause">For statements with <code>for</code> clause</h4>
</div>

<h4 id="For从句">带 <code>for</code> 从句的 for 语句</h4>

<div class="english">
<p>
A "for" statement with a ForClause is also controlled by its condition, but
additionally it may specify an <i>init</i>
and a <i>post</i> statement, such as an assignment,
an increment or decrement statement. The init statement may be a
<a href="#Short_variable_declarations">short variable declaration</a>, but the post statement must not.
Variables declared by the init statement are re-used in each iteration.
</p>

<pre class="ebnf">
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .
</pre>
</div>

<p>
带 For 子句的"for"语句也通过其条件控制，此外，它也可指定一个<b>初始化</b>或<b>步进</b>语句，
例如一个赋值、一个递增或递减语句。初始化语句可为一个<a href="#短变量声明">短变量声明</a>，
而步进语句则不能。由 init 语句声明的变量会在每次迭代中重用。
</p>

<pre class="ebnf">
For子句    = [ 初始化语句 ] ";" [ 条件 ] ";" [ 步进语句 ] .
初始化语句 = 简单语句 .
步进语句   = 简单语句 .
</pre>

<pre>
for i := 0; i &lt; 10; i++ {
	f(i)
}
</pre>

<div class="english">
<p>
If non-empty, the init statement is executed once before evaluating the
condition for the first iteration;
the post statement is executed after each execution of the block (and
only if the block was executed).
Any element of the ForClause may be empty but the
<a href="#Semicolons">semicolons</a> are
required unless there is only a condition.
If the condition is absent, it is equivalent to the boolean value
<code>true</code>.
</p>

<pre>
for cond { S() }    is the same as    for ; cond ; { S() }
for      { S() }    is the same as    for true     { S() }
</pre>
</div>

<h4 id="For_range">For statements with <code>range</code> clause</h4>

<p>
若初始化语句非空，则只在第一次迭代的条件求值前执行一次。
步进语句会在块的每一次执行（且仅当块被执行）后执行。
任何 For 子句的元素都可为空，但除非只有一个条件，否则<a href="#分号">分号</a>是必须的。
若缺少条件，则它等价于布尔值 <code>true</code>。
</p>

<pre>
for cond { S() }    等价于    for ; cond ; { S() }
for      { S() }    等价于    for true     { S() }
</pre>

<div class="english">
<p>
A "for" statement with a "range" clause
iterates through all entries of an array, slice, string or map,
or values received on a channel. For each entry it assigns <i>iteration values</i>
to corresponding <i>iteration variables</i> if present and then executes the block.
</p>

<pre class="ebnf">
RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .
</pre>
</div>

<p>
带"range"子句的"for"语句通过遍历数组、切片、字符串或映射的所有项，以及从信道上接收的值来迭代。
对于每一项，它将<b>迭代值</b>（若存在）赋予其相应的<b>迭代变量</b>，然后执行该块。
</p>

<pre class="ebnf">
Range子句 = [ 表达式列表 "=" | 标识符列表 ":=" ] "range" 表达式 .
</pre>

<div class="english">
<p>
The expression on the right in the "range" clause is called the <i>range expression</i>,
which may be an array, pointer to an array, slice, string, map, or channel permitting
<a href="#Receive_operator">receive operations</a>.
As with an assignment, if present the operands on the left must be
<a href="#Address_operators">addressable</a> or map index expressions; they
denote the iteration variables. If the range expression is a channel, at most
one iteration variable is permitted, otherwise there may be up to two.
If the last iteration variable is the <a href="#Blank_identifier">blank identifier</a>,
the range clause is equivalent to the same clause without that identifier.
</p>
</div>

<p>
"range"子句右边的表达式称为<b>range 表达式</b>，它可以是一个允许<a href="#接收操作符">接受操作</a>
的数组、数组指针、切片、字符串、映射或信道。就赋值来说，若存在左边的操作数，则它必须为
<a href="#地址操作符">可寻址的</a>或映射下标表达式；它们表示迭代变量。若 range 表达式为信道，
则最多只允有一个迭代变量，否则可多于两个。若最后一个迭代变量为
<a href="#空白标识符">空白标识符</a>，则 range 子句等价于无该标识符的相同子句。
</p>

<div class="english">
<p>
The range expression <code>x</code> is evaluated once before beginning the loop,
with one exception: if at most one iteration variable is present and
<code>len(x)</code> is <a href="#Length_and_capacity">constant</a>,
the range expression is not evaluated.
</p>

<p>
Function calls on the left are evaluated once per iteration.
For each iteration, iteration values are produced as follows
if the respective iteration variables are present:
</p>

<pre class="grammar">
Range expression                          1st value          2nd value

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E, &lt;-chan E       element  e  E
</pre>

<ol>
<li>
For an array, pointer to array, or slice value <code>a</code>, the index iteration
values are produced in increasing order, starting at element index 0.
If at most one iteration variable is present, the range loop produces
iteration values from 0 up to <code>len(a)-1</code> and does not index into the array
or slice itself. For a <code>nil</code> slice, the number of iterations is 0.
</li>

<li>
For a string value, the "range" clause iterates over the Unicode code points
in the string starting at byte index 0.  On successive iterations, the index value will be the
index of the first byte of successive UTF-8-encoded code points in the string,
and the second value, of type <code>rune</code>, will be the value of
the corresponding code point.  If the iteration encounters an invalid
UTF-8 sequence, the second value will be <code>0xFFFD</code>,
the Unicode replacement character, and the next iteration will advance
a single byte in the string.
</li>

<li>
The iteration order over maps is not specified
and is not guaranteed to be the same from one iteration to the next.
If a map entry that has not yet been reached is removed during iteration,
the corresponding iteration value will not be produced. If a map entry is
created during iteration, that entry may be produced during the iteration or
may be skipped. The choice may vary for each entry created and from one
iteration to the next.
If the map is <code>nil</code>, the number of iterations is 0.
</li>

<li>
For channels, the iteration values produced are the successive values sent on
the channel until the channel is <a href="#Close">closed</a>. If the channel
is <code>nil</code>, the range expression blocks forever.
</li>
</ol>
</div>

<p>
range 表达式在循环前会求值一次，除了一种情况：若 range 表达式为数组或数组指针，
且最多存在一个迭代变量，此时只有 range 表达式的长度会被求值；若该长度为常量，
那么<a href="#长度与容量">根据定义</a>，range 表达式本身不会被求值。
</p>

<p>
左边的函数调用会在每次迭代时求值一次。对于每一次迭代，若各自的迭代变量存在，那么迭代值按照以下方式产生：
</p>

<pre class="grammar">
Range 表达式                           第一个值            第二个值

数组或切片  a  [n]E、*[n]E 或 []E     下标  i  int        a[i]   E
字符串      s  string type            下标  i  int        见下   rune
映射        m  map[K]V                键    k  K          m[k]   V
信道        c  chan E, &lt;-chan E    元素  e  E
</pre>

<ol>
<li>
对于数组、数组指针或切片值 <code>a</code>，下标迭代值按照递增顺序产生，从元素下标 0 开始。
作为一种特殊情况，若最多有一个迭代变量，则 range 循环提供从 0 到 <code>len(a)-1</code>
的迭代变量而非索引该数组或切片自身。对于 <code>nil</code> 切片，迭代次数为 0。
</li>

<li>
对于字符串值，"range"子句从字节下标 0 开始，遍历该字符串中的 Unicode 码点。在连续迭代中，
其下标值为该字符串中连续 UTF-8 编码码点第一个字节的下标。而类型为 <code>rune</code>
的第二个值为则其相应码点的值。若该迭代遇到无效的 UTF-8 序列，则第二个值将为 Unicode 占位字符
<code>0xFFD</code>，且下一次迭代将推进至此字符串中的单个字节。
</li>

<li>
映射的遍历顺序并不确定且从某一次迭代到下一次并不保证相同。若在迭代过程中移除的映射项尚未受到影响，
则相应的迭代值不会产生。若在迭代过程中创建映射项，则该项可能会在迭代中产生或被跳过。
这种选择可能会改变已经创建的每一个项，并从一次迭代进入到下一次迭代中。
若该映射为 <code>nil</code>，则迭代的次数为 0.
</li>

<li>
对于信道，其迭代值产生为在该信道上发送的连续值，直到该信道被<a href="#关闭">关闭</a>。若该信道为
<code>nil</code>，则 range 表达式将永远阻塞。
</li>
</ol>

<div class="english">
<p>
The iteration values are assigned to the respective
iteration variables as in an <a href="#Assignments">assignment statement</a>.
</p>
</div>

<p>
迭代值在<a href="#赋值">赋值语句</a>中将分别赋予其各自的迭代变量。
</p>

<div class="english">
<p>
The iteration variables may be declared by the "range" clause using a form of
<a href="#Short_variable_declarations">short variable declaration</a>
(<code>:=</code>).
In this case their types are set to the types of the respective iteration values
and their <a href="#Declarations_and_scope">scope</a> is the block of the "for"
statement; they are re-used in each iteration.
If the iteration variables are declared outside the "for" statement,
after execution their values will be those of the last iteration.
</p>

<pre>
var testdata *struct {
	a *[7]int
}
for i, _ := range testdata.a {
	// testdata.a is never evaluated; len(testdata.a) is constant
	// i ranges from 0 to 6
	f(i)
}

var a [10]string
for i, s := range a {
	// type of i is int
	// type of s is string
	// s == a[i]
	g(i, s)
}

var key string
var val interface {}  // element type of m is assignable to val
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for key, val = range m {
	h(key, val)
}
// key == last map key encountered in iteration
// val == map[key]

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}

// empty a channel
for range ch {}
</pre>
</div>

<p>
迭代变量可通过"range"子句使用<a href="#短变量声明">短变量声明</a>形式（<code>:=</code>）来声明。
在这种情况下，它们的类型将置为其各自的迭代值，且它们的<a href="#声明与作用域">作用域</a>
在"for"语句块内，它们将在每次迭代时被重用。若迭代变量在"for"语句之外声明，则在每次执行后，
它们的值为最后一次迭代的值。
</p>

<pre>
var testdata *struct {
	a *[7]int
}
for i, _ := range testdata.a {
	// testdata.a 永不会被求值，len(testdata.a)为常量
	// i 从 0 延伸到 6
	f(i)
}

var a [10]string
for i, s := range a {
	// i 的类型为 int
	// s 的类型为 string
	// s == a[i]
	g(i, s)
}

var key string
var val interface {}  // m 值的类型可赋予 val
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for key, val = range m {
	h(key, val)
}
// key == 在迭代中遇到的最后一个映射键
// val == map[key]

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}

// 清空一个信道
for range ch {}
</pre>


<div class="english">
<h3 id="Go_statements">Go statements</h3>
</div>

<h3 id="Go语句">Go 语句</h3>

<div class="english">
<p>
A "go" statement starts the execution of a function call
as an independent concurrent thread of control, or <i>goroutine</i>,
within the same address space.
</p>

<pre class="ebnf">
GoStmt = "go" Expression .
</pre>
</div>

<p>
"go"语句将函数调用的执行作为控制独立的并发线程或相同地址空间中的<b>Go程</b>来启动。
</p>

<pre class="ebnf">
Go语句 = "go" 表达式 .
</pre>

<div class="english">
<p>
The expression must be a function or method call; it cannot be parenthesized.
Calls of built-in functions are restricted as for
<a href="#Expression_statements">expression statements</a>.
</p>

<p>
表达式必须为一个函数或方法调用，它不能被括号括住。内建函数调用被限制为<a href="#表达式语句">表达式语句</a>。
</p>

<p>
The function value and parameters are
<a href="#Calls">evaluated as usual</a>
in the calling goroutine, but
unlike with a regular call, program execution does not wait
for the invoked function to complete.
Instead, the function begins executing independently
in a new goroutine.
When the function terminates, its goroutine also terminates.
If the function has any return values, they are discarded when the
function completes.
</p>
</div>

<p>
在调用 Go 程中，函数值与形参<a href="#函数与方法的调用">按照惯例求值</a>，
但不像一般的调用，程序的执行并不等待已被调用的函数完成。取而代之，该函数在一个新的 Go 程中独立执行。
当该函数终止后，其 Go 程也将终止。若该函数拥有任何返回值，它们将在该函数完成后被丢弃。
</p>

<pre>
go Server()
go func(ch chan&lt;- bool) { for { sleep(10); ch &lt;- true }} (c)
</pre>


<div class="english">
<h3 id="Select_statements">Select statements</h3>
</div>

<h3 id="Select语句">Select语句</h3>

<div class="english">
<p>
A "select" statement chooses which of a set of possible
<a href="#Send_statements">send</a> or
<a href="#Receive_operator">receive</a>
operations will proceed.
It looks similar to a
<a href="#Switch_statements">"switch"</a> statement but with the
cases all referring to communication operations.
</p>

<pre class="ebnf">
SelectStmt = "select" "{" { CommClause } "}" .
CommClause = CommCase ":" StatementList .
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .
RecvStmt   = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .
RecvExpr   = Expression .
</pre>
</div>

<p>
"select" 语句选择哪些可进行
<a href="#发送语句">发送</a>或<a href="#接收操作符">接收</a>的操作会被处理。
它看起来与<a href="#Switch语句">"switch"</a> 语句类似，但其 case 为所有涉及到通信的操作。
</p>

<pre class="ebnf">
Select语句 = "select" "{" { 通信子句 } "}" .
通信子句   = 通信情况 ":" 语句列表 .
通信情况   = "case" ( 发送语句 | 接收语句 ) | "default" .
接收语句   = [ 表达式列表 [ "," 标识符列表 ] ( "=" | ":=" ) ] 接收表达式 .
接收表达式 = 表达式 .
</pre>

<div class="english">
<p>
A case with a RecvStmt may assign the result of a RecvExpr to one or
two variables, which may be declared using a
<a href="#Short_variable_declarations">short variable declaration</a>.
The RecvExpr must be a (possibly parenthesized) receive operation.
There can be at most one default case and it may appear anywhere
in the list of cases.
</p>
</div>

<p>
带接收语句的 case 可将接收表达式的结果赋予一或两个变量，该变量可使用
<a href="#短变量声明">短变量声明</a>的形式声明。接收表达式必须为（可能带括号的）
接收操作。最多可以有一个默认 case 且可以出现在 case 列表中的任何地方。
</p>

<div class="english">
<p>
Execution of a "select" statement proceeds in several steps:
</p>
</div>

<p>
"select" 语句的执行过程分为以下几步：
</p>

<div class="english">
<ol>
<li>
For all the cases in the statement, the channel operands of receive operations
and the channel and right-hand-side expressions of send statements are
evaluated exactly once, in source order, upon entering the "select" statement.
The result is a set of channels to receive from or send to,
and the corresponding values to send.
Any side effects in that evaluation will occur irrespective of which (if any)
communication operation is selected to proceed.
Expressions on the left-hand side of a RecvStmt with a short variable declaration
or assignment are not yet evaluated.
</li>

<li>
If one or more of the communications can proceed,
a single one that can proceed is chosen via a uniform pseudo-random selection.
Otherwise, if there is a default case, that case is chosen.
If there is no default case, the "select" statement blocks until
at least one of the communications can proceed.
</li>

<li>
Unless the selected case is the default case, the respective communication
operation is executed.
</li>

<li>
If the selected case is a RecvStmt with a short variable declaration or
an assignment, the left-hand side expressions are evaluated and the
received value (or values) are assigned.
</li>

<li>
The statement list of the selected case is executed.
</li>
</ol>
</div>

<ol>
<li>
对于语句中的所有 case，接收操作的信道操作数和信道，以及右侧发送语句的表达式会在进入
"select" 语句时按照源码的顺序刚好执行一次。其结果为用于接收或发送的信道的集合，
以及对应的用于发送的值。该求值中的任何副作用都与已选择进行处理的通信操作无关
（如果存在的话）。接收语句左侧的短变量声明或赋值表达式尚未求值。
</li>

<li>
若一个或多个通信可以进行，就会按照均匀分布的伪随机数选择其中一个。否则，若存在一个默认
case，就会选择它。若没有默认 case，"select" 语句就会阻塞直到至少一个通信可以进行。
</li>

<li>
除非已选择的 case 为默认 case，否则对应的通信操作就会执行。
</li>

<li>
若选择的 case 为带短变量声明或赋值的接收语句，那么左边的表达式会被求值并被赋予接收的值。
</li>

<li>
已选择的 case 的语句列表会被执行。
</li>
</ol>

<div class="english">
<p>
Since communication on <code>nil</code> channels can never proceed,
a select with only <code>nil</code> channels and no default case blocks forever.
</p>

<pre>
var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
case i1 = &lt;-c1:
	print("received ", i1, " from c1\n")
case c2 &lt;- i2:
	print("sent ", i2, " to c2\n")
case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
	if ok {
		print("received ", i3, " from c3\n")
	} else {
		print("c3 is closed\n")
	}
case a[f()] = &lt;-c4:
	// same as:
	// case t := &lt;-c4
	//	a[f()] = t
default:
	print("no communication\n")
}

for {  // send random sequence of bits to c
	select {
	case c &lt;- 0:  // note: no statement, no fallthrough, no folding of cases
	case c &lt;- 1:
	}
}

select {}  // block forever
</pre>
</div>

<p>
由于在 <code>nil</code> 信道上的通信永远不会被处理，因此只带
<code>nil</code> 信道且无默认 case 的 select 会永远阻塞。
</p>

<pre>
var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
case i1 = &lt;-c1:
	print("received ", i1, " from c1\n")
case c2 &lt;- i2:
	print("sent ", i2, " to c2\n")
case i3, ok := (&lt;-c3):  // 等价于 i3, ok := &lt;-c3
	if ok {
		print("received ", i3, " from c3\n")
	} else {
		print("c3 is closed\n")
	}
case a[f()] = &lt;-c4:
	// same as:
	// case t := &lt;-c4
	//	a[f()] = t
default:
	print("no communication\n")
}

for {  // 向 c 发送位的随机序列
	select {
	case c &lt;- 0:  // 注意：没有语句，没有 fallthrough，也没有 case 折叠
	case c &lt;- 1:
	}
}

select {}  // 永远阻塞
</pre>


<div class="english">
<h3 id="Return_statements">Return statements</h3>
</div>

<h3 id="Return语句">Return语句</h3>

<div class="english">
<p>
A "return" statement in a function <code>F</code> terminates the execution
of <code>F</code>, and optionally provides one or more result values.
Any functions <a href="#Defer_statements">deferred</a> by <code>F</code>
are executed before <code>F</code> returns to its caller.
</p>

<pre class="ebnf">
ReturnStmt = "return" [ ExpressionList ] .
</pre>
</div>

<p>
函数 <code>F</code> 中的“return”语句终止 <code>F</code> 的执行，并可选地提供一个或多个返回值。
任何被 <code>F</code> <a href="#Defer语句">推迟</a>的函数会在 <code>F</code>
返回给其调用者前执行。
</p>

<pre class="ebnf">
Return语句 = "return" [ 表达式列表 ] .
</pre>

<div class="english">
<p>
In a function without a result type, a "return" statement must not
specify any result values.
</p>
</div>

<p>
在没有返回类型的函数中，"return"语句不能指定任何返回值。
</p>

<pre>
func noResult() {
	return
}
</pre>

<div class="english">
<p>
There are three ways to return values from a function with a result
type:
</p>

<ol>
	<li>The return value or values may be explicitly listed
		in the "return" statement. Each expression must be single-valued
		and <a href="#Assignability">assignable</a>
		to the corresponding element of the function's result type.
<pre>
func simpleF() int {
	return 2
}

func complexF1() (re float64, im float64) {
	return -7.0, -4.0
}
</pre>
	</li>
	<li>The expression list in the "return" statement may be a single
		call to a multi-valued function. The effect is as if each value
		returned from that function were assigned to a temporary
		variable with the type of the respective value, followed by a
		"return" statement listing these variables, at which point the
		rules of the previous case apply.
<pre>
func complexF2() (re float64, im float64) {
	return complexF1()
}
</pre>
	</li>
	<li>The expression list may be empty if the function's result
		type specifies names for its <a href="#Function_types">result parameters</a>.
		The result parameters act as ordinary local variables
		and the function may assign values to them as necessary.
		The "return" statement returns the values of these variables.
<pre>
func complexF3() (re float64, im float64) {
	re = 7.0
	im = 4.0
	return
}

func (devnull) Write(p []byte) (n int, _ error) {
	n = len(p)
	return
}
</pre>
	</li>
</ol>
</div>

<p>
从具有返回类型的函数返回值的三种方式：
</p>

<ol>
	<li>返回值可在"return"语句中显式地列出。每个表达式必须为单值，
		且<a href="#可赋予">可赋予</a>相应的函数返回类型的元素。
<pre>
func simpleF() int {
	return 2
}

func complexF1() (re float64, im float64) {
	return -7.0, -4.0
}
</pre>
	</li>
	<li>
		"return"语句中的表达式列表可为多值函数的单个调用。
		其效果相当于将该函数返回的每一个值赋予同类型的临时变量，
		并在"return"语句后面列出这些变量，在这点上与前面的情况规则相同。
<pre>
func complexF2() (re float64, im float64) {
	return complexF1()
}
</pre>
	</li>
	<li>
		若函数的返回类型为其<a href="#函数类型">返回形参</a>指定了名字，
		则表达式列表可为空。返回形参的行为如同一般的局部变量，且必要时该函数可向他们赋值。
		"return"语句返回这些变量的值。
<pre>
func complexF3() (re float64, im float64) {
	re = 7.0
	im = 4.0
	return
}

func (devnull) Write(p []byte) (n int, _ error) {
	n = len(p)
	return
}
</pre>
	</li>
</ol>

<div class="english">
<p>
Regardless of how they are declared, all the result values are initialized to
the <a href="#The_zero_value">zero values</a> for their type upon entry to the
function. A "return" statement that specifies results sets the result parameters before
any deferred functions are executed.
</p>
</div>

<p>
无论它们如何声明，在进入该函数时，所有的返回值都会被初始化为该类型的<a href="#零值">零值</a>。
指定了结果的“return”语句会在任何被推迟的函数执行前设置结果形参。
</p>

<div class="english">
<p>
Implementation restriction: A compiler may disallow an empty expression list
in a "return" statement if a different entity (constant, type, or variable)
with the same name as a result parameter is in
<a href="#Declarations_and_scope">scope</a> at the place of the return.
</p>

<pre>
func f(n int) (res int, err error) {
	if _, err := f(n-1); err != nil {
		return  // invalid return statement: err is shadowed
	}
	return
}
</pre>
</div>

<p>
实现限制：若不同的条目以相同的名字作为结果形参出现在返回的<a href="#声明与作用域">作用域</a>内，
那么编译器可能禁止空表达式列表出现在 "return" 语句中。
</p>

<pre>
func f(n int) (res int, err error) {
	if _, err := f(n-1); err != nil {
		return  // 无效的返回语句：err 被屏蔽
	}
	return
}
</pre>

<div class="english">
<h3 id="Break_statements">Break statements</h3>
</div>

<h3 id="Break语句">Break语句</h3>

<div class="english">
<p>
A "break" statement terminates execution of the innermost
<a href="#For_statements">"for"</a>,
<a href="#Switch_statements">"switch"</a>, or
<a href="#Select_statements">"select"</a> statement
within the same function.
</p>

<pre class="ebnf">
BreakStmt = "break" [ Label ] .
</pre>
</div>

<p>
"break"语句终止同函数内最内层的
<a href="#For_statements">"for"</a>、
<a href="#Switch_statements">"switch"</a> 或
<a href="#Select_statements">"select"</a> 语句的执行。
</p>

<pre class="ebnf">
Break语句 = "break" [ 标签 ] .
</pre>

<div class="english">
<p>
If there is a label, it must be that of an enclosing
"for", "switch", or "select" statement,
and that is the one whose execution terminates.
</p>
</div>

<p>
若存在标签，则它必须为闭合的"for"、"switch"或"select"语句，而此执行就会终止。
</p>

<pre>
OuterLoop:
	for i = 0; i &lt; n; i++ {
		for j = 0; j &lt; m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break OuterLoop
			case item:
				state = Found
				break OuterLoop
			}
		}
	}
</pre>

<div class="english">
<h3 id="Continue_statements">Continue statements</h3>
</div>

<h3 id="Continue语句">Continue语句</h3>

<div class="english">
<p>
A "continue" statement begins the next iteration of the
innermost <a href="#For_statements">"for" loop</a> at its post statement.
The "for" loop must be within the same function.
</p>

<pre class="ebnf">
ContinueStmt = "continue" [ Label ] .
</pre>
</div>

<p>
"continue"语句在最内层<a href="#For语句">"for" 循环</a>的步进语句处开始下一次迭代。
“for”循环必须在同一函数内。
</p>

<pre class="ebnf">
Continue语句 = "continue" [ 标签 ] .
</pre>

<div class="english">
<p>
If there is a label, it must be that of an enclosing
"for" statement, and that is the one whose execution
advances.
</p>
</div>

<p>
若存在标签，则它必须为闭合的"for"语句，而此执行就会前进。
</p>

<pre>
RowLoop:
	for y, row := range rows {
		for x, data := range row {
			if data == endOfRow {
				continue RowLoop
			}
			row[x] = data + bias(x, y)
		}
	}
</pre>


<div class="english">
<h3 id="Goto_statements">Goto statements</h3>
</div>

<h3 id="Goto语句">Goto语句</h3>

<div class="english">
<p>
A "goto" statement transfers control to the statement with the corresponding label
within the same function.
</p>

<pre class="ebnf">
GotoStmt = "goto" Label .
</pre>
</div>

<p>
"goto"语句用于将控制转移到同函数内与其标签相应的语句。
</p>

<pre class="ebnf">
Goto语句 = "goto" 标签 .
</pre>

<pre>
goto Error
</pre>

<div class="english">
<p>
Executing the "goto" statement must not cause any variables to come into
<a href="#Declarations_and_scope">scope</a> that were not already in scope at the point of the goto.
For instance, this example:
</p>
</div>

<div class="english">
<pre>
	goto L  // BAD
	v := 3
L:
</pre>
</div>

<p>
执行"goto"不能在跳转点处产生任何还未在作用域中的变量来使其进入<a href="#声明与作用域">作用域</a>。
比如，例子：
</p>

<pre>
	goto L  // 这样不好
	v := 3
L:
</pre>

<div class="english">
<p>
is erroneous because the jump to label <code>L</code> skips
the creation of <code>v</code>.
</p>
</div>

<p>
是错误的，因为跳转至标签 <code>L</code> 处将跳过 <code>v</code> 的创建。
</p>

<div class="english">
<p>
A "goto" statement outside a <a href="#Blocks">block</a> cannot jump to a label inside that block.
For instance, this example:
</p>
</div>

<p>
在<a href="#块">块</a>外的"goto"语句不能跳转至该块中的标签。
比如，例子：
</p>

<pre>
if n%2 == 1 {
	goto L1
}
for n &gt; 0 {
	f()
	n--
L1:
	f()
	n--
}
</pre>

<div class="english">
<p>
is erroneous because the label <code>L1</code> is inside
the "for" statement's block but the <code>goto</code> is not.
</p>
</div>

<p>
是错误的，因为标签 <code>L1</code> 在"for"语句的块中而 <code>goto</code> 则不在。
</p>

<div class="english">
<h3 id="Fallthrough_statements">Fallthrough statements</h3>
</div>

<h3 id="Fallthrough语句">Fallthrough语句</h3>

<div class="english">
<p>
A "fallthrough" statement transfers control to the first statement of the
next case clause in an <a href="#Expression_switches">expression "switch" statement</a>.
It may be used only as the final non-empty statement in such a clause.
</p>

<pre class="ebnf">
FallthroughStmt = "fallthrough" .
</pre>
</div>

<p>
"fallthrough"语句将控制转移到<a href="#表达式选择">表达式 "switch" 语句</a>
中下一个 case 子句的第一个语句。它可能只被用作这类子句里最后的非空语句。
</p>

<pre class="ebnf">
Fallthrough语句 = "fallthrough" .
</pre>


<div class="english">
<h3 id="Defer_statements">Defer statements</h3>
</div>

<h3 id="Defer语句">Defer语句</h3>

<div class="english">
<p>
A "defer" statement invokes a function whose execution is deferred
to the moment the surrounding function returns, either because the
surrounding function executed a <a href="#Return_statements">return statement</a>,
reached the end of its <a href="#Function_declarations">function body</a>,
or because the corresponding goroutine is <a href="#Handling_panics">panicking</a>.
</p>

<pre class="ebnf">
DeferStmt = "defer" Expression .
</pre>
</div>

<p>
"defer"语句调用的函数将被推迟到其外围函数返回时执行，不论是因为该外围函数执行了
<a href="#Return语句">return 语句</a>，到达了其<a href="#函数声明">函数体</a>的末尾，
还是因为其对应的 Go 程进入了<a href="#恐慌处理">恐慌过程</a>。
</p>

<pre class="ebnf">
Defer语句 = "defer" 表达式 .
</pre>

<div class="english">
<p>
The expression must be a function or method call; it cannot be parenthesized.
Calls of built-in functions are restricted as for
<a href="#Expression_statements">expression statements</a>.
</p>

<p>
Each time a "defer" statement
executes, the function value and parameters to the call are
<a href="#Calls">evaluated as usual</a>
and saved anew but the actual function is not invoked.
Instead, deferred functions are invoked immediately before
the surrounding function returns, in the reverse order
they were deferred. That is, if the surrounding function
returns through an explicit <a href="#Return_statements">return statement</a>,
deferred functions are executed <i>after</i> any result parameters are set
by that return statement but <i>before</i> the function returns to its caller.
If a deferred function value evaluates
to <code>nil</code>, execution <a href="#Handling_panics">panics</a>
when the function is invoked, not when the "defer" statement is executed.
</p>

<p>
For instance, if the deferred function is
a <a href="#Function_literals">function literal</a> and the surrounding
function has <a href="#Function_types">named result parameters</a> that
are in scope within the literal, the deferred function may access and modify
the result parameters before they are returned.
If the deferred function has any return values, they are discarded when
the function completes.
(See also the section on <a href="#Handling_panics">handling panics</a>.)
</p>

<pre>
lock(l)
defer unlock(l)  // unlocking happens before surrounding function returns

// prints 3 2 1 0 before surrounding function returns
for i := 0; i &lt;= 3; i++ {
	defer fmt.Print(i)
}

// f returns 42
func f() (result int) {
	defer func() {
		// result is accessed after it was set to 6 by the return statement
		result *= 7
	}()
	return 6
}
</pre>
</div>

<p>
该表达必须为一个函数或方法调用，它不能被括号括住。内建函数调用被限制为<a href="#表达式语句">表达式语句</a>。
</p>

<p>
"defer"语句每执行一次，它所调用的函数值与形参就会
<a href="#函数与方法的调用">像平时一样求值</a>并重新保存，但实际的函数并不会被调用。
取而代之的是，在外围的函数返回前，被推迟的函数会按照它们被推迟的相反顺序立即执行。
That is, if the surrounding function
returns through an explicit <a href="#Return_statements">return statement</a>,
deferred functions are executed <i>after</i> any result parameters are set
by that return statement but <i>before</i> the function returns to its caller.
If a deferred function value evaluates
to <code>nil</code>, execution <a href="#Handling_panics">panics</a>
when the function is invoked, not when the "defer" statement is executed.
若已推迟函数值求值为 <code>nil</code>，当该函数被调用而非在“defer”语句被执行时，
就会执行 <a href="#恐慌处理">panic</a>。
</p>

<p>
例如，若被推迟的函数为<a href="#函数字面">函数字面</a>，而其外围函数在其作用域中的函数字面内拥有
<a href="#函数类型">已命名结果形参</a>，则被推迟的函数可在该结果形参被返回前访问并更改。
若被推迟函数拥有任何返回值，则它们会在该函数完成时丢弃。
（另请参阅<a href="#恐慌处理">恐慌处理</a>）一节。
</p>

<pre>
lock(l)
defer unlock(l)  // 解锁在外围函数返回前发生

// 在外围函数返回前打印 3 2 1 0
for i := 0; i &lt;= 3; i++ {
	defer fmt.Print(i)
}

// f 返回 42
func f() (result int) {
	defer func() {
		// result 在它被 return 语句置为 6 后访问
		result *= 7
	}()
	return 6
}
</pre>

<div class="english">
<h2 id="Built-in_functions">Built-in functions</h2>
</div>

<h2 id="内建函数">内建函数</h2>

<div class="english">
<p>
Built-in functions are
<a href="#Predeclared_identifiers">predeclared</a>.
They are called like any other function but some of them
accept a type instead of an expression as the first argument.
</p>
</div>

<p>
内建函数是<a href="#预声明标识符">预声明的</a>。它们可以像其他任何函数一样被调用，
但其中某些函数则接受类型而非表达式来作为第一个实参。
</p>

<div class="english">
<p>
The built-in functions do not have standard Go types,
so they can only appear in <a href="#Calls">call expressions</a>;
they cannot be used as function values.
</p>

<pre class="ebnf">
BuiltinCall = identifier "(" [ BuiltinArgs [ "," ] ] ")" .
BuiltinArgs = Type [ "," ArgumentList ] | ArgumentList .
</pre>
</div>

<p>
内建函数并没有标准的 Go 类型，因此它们只能出现在<a href="#函数与方法的调用">调用表达式</a>中，而不能作为函数值被使用。
</p>

<pre class="ebnf">
内建调用 = 标识符 "(" [ 内建实参 [ "," ] ] ")" .
内建实参 = 类型 [ "," 实参列表 ] | 实参列表 .
</pre>

<div class="english">
<h3 id="Close">Close</h3>
</div>

<h3 id="关闭">关闭</h3>

<div class="english">
<p>
For a channel <code>c</code>, the built-in function <code>close(c)</code>
records that no more values will be sent on the channel.
It is an error if <code>c</code> is a receive-only channel.
Sending to or closing a closed channel causes a <a href="#Run_time_panics">run-time panic</a>.
Closing the nil channel also causes a <a href="#Run_time_panics">run-time panic</a>.
After calling <code>close</code>, and after any previously
sent values have been received, receive operations will return
the zero value for the channel's type without blocking.
The multi-valued <a href="#Receive_operator">receive operation</a>
returns a received value along with an indication of whether the channel is closed.
</p>
</div>

<p>
对于一个信道 <code>c</code>，内建函数 <code>close(c)</code> 标明不再有值会在该信道上发送。
若 <code>c</code> 为只接收信道，则会产生一个错误。向已关闭的信道发送信息或再次关闭它将引发
<a href="#运行时恐慌">运行时恐慌</a>。关闭 <code>nil</code> 信道也会引发<a href="#运行时恐慌">运行时恐慌</a>。
在调用 <code>close</code> 之后，任何以前发送的值都会被接收，接收操作将无阻塞地返回该信道类型的零值。
多值 <a href="#接收操作符">接收操作</a> 会随着一个该信道是否关闭的指示返回一个已接收的值。
</p>


<div class="english">
<h3 id="Length_and_capacity">Length and capacity</h3>
</div>

<h3 id="长度与容量">长度与容量</h3>

<div class="english">
<p>
The built-in functions <code>len</code> and <code>cap</code> take arguments
of various types and return a result of type <code>int</code>.
The implementation guarantees that the result always fits into an <code>int</code>.
</p>

<pre class="grammar">
Call      Argument type    Result

len(s)    string type      string length in bytes
          [n]T, *[n]T      array length (== n)
          []T              slice length
          map[K]T          map length (number of defined keys)
          chan T           number of elements queued in channel buffer

cap(s)    [n]T, *[n]T      array length (== n)
          []T              slice capacity
          chan T           channel buffer capacity
</pre>
</div>

<p>
内建函数 <code>len</code> 与 <code>cap</code> 接受各种类型的实参并返回 <code>int</code> 类型的结果。
该实现保证其结果总符合 <code>int</code> 类型。
</p>

<pre class="grammar">
调用      实参类型         结果

len(s)    string type      字符串的字节长度。
		  [n]T, *[n]T      数组长度（== n）
		  []T              切片长度
		  map[K]T          映射长度（已定义键的数量）
		  chan T           信道缓存中元素队列的长度

cap(s)    [n]T, *[n]T      数组长度（== n）
		  []T              切片容量
		  chan T           信道缓存容量
</pre>

<div class="english">
<p>
The capacity of a slice is the number of elements for which there is
space allocated in the underlying array.
At any time the following relationship holds:
</p>
</div>

<p>
切片的容量为其底层数组中已分配的空间元素的数量。以下关系在任何时候都成立：
</p>

<pre>
0 &lt;= len(s) &lt;= cap(s)
</pre>

<div class="english">
<p>
The length of a <code>nil</code> slice, map or channel is 0.
The capacity of a <code>nil</code> slice or channel is 0.
</p>
</div>

<p>
<code>nil</code> 切片、映射或信道的长度为 0。<code>nil</code> 切片或信道的容量为 0。
</p>

<div class="english">
<p>
The expression <code>len(s)</code> is <a href="#Constants">constant</a> if
<code>s</code> is a string constant. The expressions <code>len(s)</code> and
<code>cap(s)</code> are constants if the type of <code>s</code> is an array
or pointer to an array and the expression <code>s</code> does not contain
<a href="#Receive_operator">channel receives</a> or (non-constant)
<a href="#Calls">function calls</a>; in this case <code>s</code> is not evaluated.
Otherwise, invocations of <code>len</code> and <code>cap</code> are not
constant and <code>s</code> is evaluated.
</p>
</div>

<p>
若 <code>s</code> 为字符串常量，则表达式 <code>len(s)</code> 即为 <a href="#常量">常量</a>。
若 <code>s</code> 的类型为数组或数组指针，且表达式 <code>s</code> 不包含<a href="#接收操作符">信道接收</a>
或（非常量）<a href="#函数与方法的调用">函数调用</a>，则表达式 <code>len(s)</code> 与 <code>cap(s)</code> 即为常量，在这种用情况下，
<code>s</code> 不会被求值。否则，<code>len</code> 与 <code>cap</code> 的调用不为常量，且 <code>s</code> 会被求值。
</p>

<div class="english">
<pre>
const (
	c1 = imag(2i)                    // imag(2i) = 2.0 is a constant
	c2 = len([10]float64{2})         // [10]float64{2} contains no function calls
	c3 = len([10]float64{c1})        // [10]float64{c1} contains no function calls
	c4 = len([10]float64{imag(2i)})  // imag(2i) is a constant and no function call is issued
	c5 = len([10]float64{imag(z)})   // invalid: imag(z) is a (non-constant) function call
)
var z complex128
</pre>
</div>

<pre>
const (
	c1 = imag(2i)                    // imag(2i) = 2.0 为常量
	c2 = len([10]float64{2})         // [10]float64{2} 不包含函数调用
	c3 = len([10]float64{c1})        // [10]float64{c1} 不包含函数调用
	c4 = len([10]float64{imag(2i)})  // imag(2i) 为常量且无函数调用问题
	c5 = len([10]float64{imag(z)})   // 无效：imag(z) 为（非常量）函数调用
)
var z complex128
</pre>

<div class="english">
<h3 id="Allocation">Allocation</h3>
</div>

<h3 id="分配">分配</h3>

<div class="english">
<p>
The built-in function <code>new</code> takes a type <code>T</code>,
allocates storage for a <a href="#Variables">variable</a> of that type
at run time, and returns a value of type <code>*T</code>
<a href="#Pointer_types">pointing</a> to it.
The variable is initialized as described in the section on
<a href="#The_zero_value">initial values</a>.

</p>
</div>

<p>
内建函数 <code>new</code> 接受类型 <code>T</code>，在运行时为该类型的
<a href="#变量">变量</a> 分配空间并返回类型为 <code>*T</code>
的值<a href="#指针类型">指向</a>它。该变量根据§<a href="#零值">初始值</a>一节中的描述来初始化。
</p>

<pre class="grammar">
new(T)
</pre>

<div class="english">
<p>
For instance
</p>
</div>

<p>
例如
</p>

<pre>
type S struct { a int; b float64 }
new(S)
</pre>

<div class="english">
<p>
allocates storage for a variable of type <code>S</code>,
initializes it (<code>a=0</code>, <code>b=0.0</code>),
and returns a value of type <code>*S</code> containing the address
of the location.
</p>
</div>

<p>
将为类型为 <code>S</code> 的变量分配存储、初始化（<code>a=0</code>，<code>b=0.0</code>）并返回类型为
<code>*S</code> 的包含位置地址的值。
</p>

<div class="english">
<h3 id="Making_slices_maps_and_channels">Making slices, maps and channels</h3>
</div>

<h3 id="创建切片、映射与信道">创建切片、映射与信道</h3>

<div class="english">
<p>
The built-in function <code>make</code> takes a type <code>T</code>,
which must be a slice, map or channel type,
optionally followed by a type-specific list of expressions.
It returns a value of type <code>T</code> (not <code>*T</code>).
The memory is initialized as described in the section on
<a href="#The_zero_value">initial values</a>.
</p>

<pre class="grammar">
Call             Type T     Result

make(T, n)       slice      slice of type T with length n and capacity n
make(T, n, m)    slice      slice of type T with length n and capacity m

make(T)          map        map of type T
make(T, n)       map        map of type T with initial space for approximately n elements

make(T)          channel    unbuffered channel of type T
make(T, n)       channel    buffered channel of type T, buffer size n
</pre>
</div>

<p>
内建函数 <code>make</code> 接受的类型 <code>T</code> 必须为切片、映射或信道类型，
可选地跟着一个特殊类型的表达式列表。它返回类型为 <code>T</code>（而非 <code>*T</code>）的值。
其内存根据§<a href="#零值">初始值</a>一节中的描述来初始化。
</p>

<pre class="grammar">
调用             类型 T     结果

make(T, n)       slice      类型为 T，长度为 n，容量为 n 的切片
make(T, n, m)    slice      类型为 T，长度为 n，容量为 m 的切片

make(T)          map        类型为 T 的映射
make(T, n)       map        类型为 T，初始空间为 n 个元素的映射

make(T)          channel    类型为 T 的无缓冲信道
make(T, n)       channel    类型为 T，缓存大小为 n 的带缓冲信道
</pre>

<div class="english">
<p>
Each of the size arguments <code>n</code> and <code>m</code> must be of integer type
or an untyped <a href="#Constants">constant</a>.
A constant size argument must be non-negative and <a href="#Representability">representable</a>
by a value of type <code>int</code>; if it is an untyped constant it is given type <code>int</code>.
If both <code>n</code> and <code>m</code> are provided and are constant, then
<code>n</code> must be no larger than <code>m</code>.
If <code>n</code> is negative or larger than <code>m</code> at run time,
a <a href="#Run_time_panics">run-time panic</a> occurs.
</p>

<pre>
s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100
s := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000
s := make([]int, 1&lt;&lt;63)         // illegal: len(s) is not representable by a value of type int
s := make([]int, 10, 0)         // illegal: len(s) > cap(s)
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for approximately 100 elements
</pre>
</div>

<p>
用于指定大小的实参 <code>n</code> 与 <code>m</code> 必须为整数类型或无类型化的。
<a href="#常量">常量</a>大小的实参必须为非负值，且可表示为 <code>int</code> 类型的值。
若 <code>n</code> 和 <code>m</code> 已给定且为常量，则 <code>n</code> 必不大于
<code>m</code>。若 <code>n</code> 在运行时为负值或大于 <code>m</code>，
就会引发<a href="#运行时恐慌">运行时恐慌</a>。
</p>

<pre>
s := make([]int, 10, 100)       // len(s) == 10，cap(s) == 100 的切片
s := make([]int, 1e3)           // len(s) == cap(s) == 1000 的切片
s := make([]int, 1&lt;&lt;63)         // 非法：len(s) 不能表示为 int 类型的值
s := make([]int, 10, 0)         // 非法：len(s) > cap(s)
c := make(chan int, 10)         // 缓存大小为 10 的信道
m := make(map[string]int, 100)  // 初始空间约为 100 个元素的映射
</pre>

<p>
Calling <code>make</code> with a map type and size hint <code>n</code> will
create a map with initial space to hold <code>n</code> map elements.
The precise behavior is implementation-dependent.
</p>


<div class="english">
<h3 id="Appending_and_copying_slices">Appending to and copying slices</h3>
</div>

<h3 id="追加与复制切片">追加与复制切片</h3>

<div class="english">
<p>
The built-in functions <code>append</code> and <code>copy</code> assist in
common slice operations.
For both functions, the result is independent of whether the memory referenced
by the arguments overlaps.
</p>
</div>

<p>
内建函数 <code>append</code> 与 <code>copy</code> 协助一般的切片操作。对于这两个函数，
无论其内存引用是否与其实参重复，其结果都是独立的。
</p>

<div class="english">
<p>
The <a href="#Function_types">variadic</a> function <code>append</code>
appends zero or more values <code>x</code>
to <code>s</code> of type <code>S</code>, which must be a slice type, and
returns the resulting slice, also of type <code>S</code>.
The values <code>x</code> are passed to a parameter of type <code>...T</code>
where <code>T</code> is the <a href="#Slice_types">element type</a> of
<code>S</code> and the respective
<a href="#Passing_arguments_to_..._parameters">parameter passing rules</a> apply.
As a special case, <code>append</code> also accepts a first argument
assignable to type <code>[]byte</code> with a second argument of
string type followed by <code>...</code>. This form appends the
bytes of the string.
</p>

<pre class="grammar">
append(s S, x ...T) S  // T is the element type of S
</pre>
</div>

<p>
<a href="#函数类型">变参</a>函数 <code>append</code> 追加零个或更多值 <code>x</code> 至 类型为
<code>S</code> 的<code>s</code>，它必须为切片类型，且返回类型为 <code>S</code> 的结果切片，
值 <code>x</code> 被传至类型为 <code>...T</code> 的形参，其中 <code>T</code> 为 <code>S</code>
的<a href="#切片类型">元素类型</a>，且其各自的<a href="#传递实参至...形参">形参传递规则</a>均适用。
作为一个特例，<code>append</code> 也接受第一个实参可赋予类型 <code>[]byte</code>，
且第二个字符串类型的实参后跟 <code>...</code>。此形式追加字符串类型的字节。
</p>

<pre class="grammar">
append(s S, x ...T) S  // T 是类型为 S 的元素
</pre>

<div class="english">
<p>
If the capacity of <code>s</code> is not large enough to fit the additional
values, <code>append</code> allocates a new, sufficiently large underlying
array that fits both the existing slice elements and the additional values.
Otherwise, <code>append</code> re-uses the underlying array.
</p>

<pre>
s0 := []int{0, 0}
s1 := append(s0, 2)                // append a single element     s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)            // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")   //                             t == []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)            // append string contents      b == []byte{'b', 'a', 'r' }
</pre>
</div>

<p>
若 <code>s</code> 的容量不足够大以适应附加的值，<code>append</code> 会分配一个新的，
足够大的底层数组以适应现有切片元素与附加的值。否则，<code>append</code> 会重用底层数组。
</p>

<pre>
s0 := []int{0, 0}
s1 := append(s0, 2)                 // 追加单个元素    s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)           // 追加多个元素    s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)             // 追加一个切片    s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)    // 追加重复切片    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")    //                  t == []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)             // 追加字符串常量  b == []byte{'b', 'a', 'r' }
</pre>

<div class="english">
<p>
The function <code>copy</code> copies slice elements from
a source <code>src</code> to a destination <code>dst</code> and returns the
number of elements copied.
Both arguments must have <a href="#Type_identity">identical</a> element type <code>T</code> and must be
<a href="#Assignability">assignable</a> to a slice of type <code>[]T</code>.
The number of elements copied is the minimum of
<code>len(src)</code> and <code>len(dst)</code>.
As a special case, <code>copy</code> also accepts a destination argument assignable
to type <code>[]byte</code> with a source argument of a string type.
This form copies the bytes from the string into the byte slice.
</p>
</div>

<p>
函数 <code>copy</code> 将切片元素从来源 <code>src</code> 复制到目标 <code>dst</code>
并返回复制的元素数量。两个实参必须都拥有<a href="#类型标识">相同</a>的元素类型
<code>T</code>，且必须都<a href="#可赋值性">可赋予</a>类型为 <code>[]T</code> 的切片。
被复制的元素数量为 <code>len(src)</code> 与 <code>len(dst)</code> 中最小的那个。
作为一个特例，<code>copy</code> 也接受一个可赋予类型 <code>[]byte</code>
的目标实参以及一个字符串类型的来源实参。此形式从该字符串中复制字节到该字节切片。
</p>

<pre class="grammar">
copy(dst, src []T) int
copy(dst []byte, src string) int
</pre>

<div class="english">
<p>
Examples:
</p>
</div>

<p>
例如：
</p>

<pre>
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")
</pre>


<div class="english">
<h3 id="Deletion_of_map_elements">Deletion of map elements</h3>
</div>

<h3 id="映射元素的删除">映射元素的删除</h3>

<div class="english">
<p>
The built-in function <code>delete</code> removes the element with key
<code>k</code> from a <a href="#Map_types">map</a> <code>m</code>. The
type of <code>k</code> must be <a href="#Assignability">assignable</a>
to the key type of <code>m</code>.
</p>

<pre class="grammar">
delete(m, k)  // remove element m[k] from map m
</pre>
</div>

<p>
内建函数 <code>delete</code> 从<a href="#映射类型">映射</a> <code>m</code>中移除键为 <code>k</code>
的元素。<code>k</code>的类型必须<a href="#可赋值性">可赋予</a> <code>m</code>类型的键。
</p>

<pre class="grammar">
delete(m, k)  // 从映射 m 中移除元素 m[k]
</pre>

<div class="english">
<p>
If the map <code>m</code> is <code>nil</code> or the element <code>m[k]</code>
does not exist, <code>delete</code> is a no-op.
</p>
</div>

<p>
若映射 <code>m</code> 为 <code>nil</code> 或元素 <code>m[k]</code>不存在，则
<code>delete</code> 就是一个空操作。
</p>

<div class="english">
<h3 id="Complex_numbers">Manipulating complex numbers</h3>
</div>

<h3 id="复数操作">复数操作</h3>

<div class="english">
<p>
Three functions assemble and disassemble complex numbers.
The built-in function <code>complex</code> constructs a complex
value from a floating-point real and imaginary part, while
<code>real</code> and <code>imag</code>
extract the real and imaginary parts of a complex value.
</p>
</div>

<p>
三个函数用于组合并分解复数。内建函数 <code>complex</code> 从一个浮点数实部和虚部构造一个复数值。
而 <code>real</code> 和 <code>imag</code> 则提取一个复数值的实部和虚部。
</p>

<pre class="grammar">
complex(realPart, imaginaryPart floatT) complexT
real(complexT) floatT
imag(complexT) floatT
</pre>

<div class="english">
<p>
The type of the arguments and return value correspond.
For <code>complex</code>, the two arguments must be of the same
floating-point type and the return type is the complex type
with the corresponding floating-point constituents:
<code>complex64</code> for <code>float32</code> arguments, and
<code>complex128</code> for <code>float64</code> arguments.
If one of the arguments evaluates to an untyped constant, it is first implicitly
<a href="#Conversions">converted</a> to the type of the other argument.
If both arguments evaluate to untyped constants, they must be non-complex
numbers or their imaginary parts must be zero, and the return value of
the function is an untyped complex constant.
</p>

<p>
For <code>real</code> and <code>imag</code>, the argument must be
of complex type, and the return type is the corresponding floating-point
type: <code>float32</code> for a <code>complex64</code> argument, and
<code>float64</code> for a <code>complex128</code> argument.
If the argument evaluates to an untyped constant, it must be a number,
and the return value of the function is an untyped floating-point constant.
</p>
</div>

<p>
实参与返回值的类型一致。对于 <code>complex</code>，两实参必须为相同的浮点类型且其返回类型为
浮点数组成部分一致的复数类型：<code>complex64</code> 对应于 <code>float32</code> 实参，
<code>complex128</code> 对应于 <code>float64</code> 实参。
若其中一个实参求值为无类型化常量，它首先会<a href="#类型转换">转换</a>为其它实参的类型。
若两个实参均求值为无类型化常量，它们必须为非复数或它们的虚部必须为零，该函数的返回值为无类型化复数。
</p>

<p>
对于 <code>real</code> 和 <code>imag</code>，其实参必须为复数类型，
且返回类型为对应的浮点数类型：<code>float32</code> 对应于 <code>complex64</code> 实参，
<code>float64</code> 对应于 <code>complex128</code> 实参。
若该实参求值为无类型化常量，那么它必须为数值，该函数的返回值为无类型化浮点数。
</p>

<div class="english">
<p>
The <code>real</code> and <code>imag</code> functions together form the inverse of
<code>complex</code>, so for a value <code>z</code> of a complex type <code>Z</code>,
<code>z&nbsp;==&nbsp;Z(complex(real(z),&nbsp;imag(z)))</code>.
</p>
</div>

<p>
<code>real</code> 和 <code>imag</code> 函数一起组成了 <code>complex</code> 的反函数，
因此对于复数类型 <code>Z</code> 的值 <code>z</code>，有
<code>z&nbsp;==&nbsp;Z(complex(real(z),&nbsp;imag(z)))</code>。
</p>

<div class="english">
<p>
If the operands of these functions are all constants, the return
value is a constant.
</p>
</div>

<p>
若这些函数的操作数均为常量，则返回值亦为常量。
</p>

<div class="english">
<pre>
var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var s int = complex(1, 0)          // untyped complex constant 1 + 0i can be converted to int
_ = complex(1, 2&lt;&lt;s)               // illegal: 2 assumes floating-point type, cannot shift
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // untyped constant -1.4
_ = imag(3 &lt;&lt; s)                   // illegal: 3 assumes complex type, cannot shift
</pre>
</div>

<pre>
var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // 无类型化复数常量 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
const s uint = complex(1, 0)       // 无类型化复数常量 1 + 0i 可转换为 uint
_ = complex(1, 2&lt;&lt;s)               // 非法：2 为浮点数类型，无法移位
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // 无类型化常量 -1.4
_ = imag(3 &lt;&lt; s)                   // 非法：3 视为复数类型，无法移位
</pre>

<div class="english">
<h3 id="Handling_panics">Handling panics</h3>
</div>

<h3 id="恐慌处理">恐慌处理</h3>

<div class="english">
<p> Two built-in functions, <code>panic</code> and <code>recover</code>,
assist in reporting and handling <a href="#Run_time_panics">run-time panics</a>
and program-defined error conditions.
</p>
</div>

<p>
内建函数 <code>panic</code> 和 <code>recover</code>
用于协助报告并处理<a href="#运行时恐慌">运行时恐慌</a>以及由程序定义的错误情况。
</p>

<pre class="grammar">
func panic(interface{})
func recover() interface{}
</pre>

<div class="english">
<p>
While executing a function <code>F</code>,
an explicit call to <code>panic</code> or a <a href="#Run_time_panics">run-time panic</a>
terminates the execution of <code>F</code>.
Any functions <a href="#Defer_statements">deferred</a> by <code>F</code>
are then executed as usual.
Next, any deferred functions run by <code>F's</code> caller are run,
and so on up to any deferred by the top-level function in the executing goroutine.
At that point, the program is terminated and the error
condition is reported, including the value of the argument to <code>panic</code>.
This termination sequence is called <i>panicking</i>.
</p>
</div>

<p>
当执行函数 <code>F</code> 时，一个显式的 <code>panic</code> 调用或<a href="#运行时恐慌">运行时恐慌</a>
均会终止 <code>F</code> 的执行。任何被 <code>F</code> <a href="#Defer语句">推迟</a>的函数都会像往常一样继续执行。
接着，任何被 <code>F</code> 的调用者推迟的函数开始运行，如此继续，直到该执行的Go程中被顶级函数推迟的任何函数均开始运行。
到那时，该程序将被终止，而该错误情况会被报告，包括引发 <code>panic</code> 的实参值。
此终止序列称为<b>恐慌过程</b>。
</p>

<pre>
panic(42)
panic("unreachable")
panic(Error("cannot parse"))
</pre>

<div class="english">
<p>
The <code>recover</code> function allows a program to manage behavior
of a panicking goroutine.
Suppose a function <code>G</code> defers a function <code>D</code> that calls
<code>recover</code> and a panic occurs in a function on the same goroutine in which <code>G</code>
is executing.
When the running of deferred functions reaches <code>D</code>,
the return value of <code>D</code>'s call to <code>recover</code> will be the value passed to the call of <code>panic</code>.
If <code>D</code> returns normally, without starting a new
<code>panic</code>, the panicking sequence stops. In that case,
the state of functions called between <code>G</code> and the call to <code>panic</code>
is discarded, and normal execution resumes.
Any functions deferred by <code>G</code> before <code>D</code> are then run and <code>G</code>'s
execution terminates by returning to its caller.
</p>
</div>

<p>
<code>recover</code> 函数允许程序管理恐慌状态的Go程的行为。
假设函数 <code>G</code> 推迟了一个函数 <code>D</code>，该函数调用了
<code>recover</code>，而执行了 <code>G</code> 的Go程中的函数又引发了恐慌，
那么当被推迟函数的运行到达 <code>D</code> 时，<code>D</code> 调用 <code>recover</code>
的返回值会正常返回，若未开始新的 <code>panic</code>，那么恐慌过程序列就会停止。
在此情况下，<code>G</code> 和 <code>panic</code> 调用之间的函数调用会被丢弃，
然后继续正常执行。任何在 <code>D</code> 之前被 <code>G</code>
推迟的函数继续运行，<code>G</code> 的执行则会因返回给其调用者而终止。
</p>

<div class="english">
<p>
The return value of <code>recover</code> is <code>nil</code> if any of the following conditions holds:
</p>
<ul>
<li>
<code>panic</code>'s argument was <code>nil</code>;
</li>
<li>
the goroutine is not panicking;
</li>
<li>
<code>recover</code> was not called directly by a deferred function.
</li>
</ul>
</div>

<p>
若满足以下任一条件，<code>recover</code> 的返回值即为 <code>nil</code>：
</p>
<ul>
<li>
<code>panic</code> 的实参为 <code>nil</code>；
</li>
<li>
Go程未处于恐慌状态
</li>
<li>
<code>recover</code> 未直接被已推迟函数。
</li>
</ul>

<div class="english">
<p>
The <code>protect</code> function in the example below invokes
the function argument <code>g</code> and protects callers from
run-time panics raised by <code>g</code>.
</p>

<pre>
func protect(g func()) {
	defer func() {
		log.Println("done")  // Println executes normally even if there is a panic
		if x := recover(); x != nil {
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
</pre>
</div>

<pre>
func protect(g func()) {
	defer func() {
		log.Println("done")  // 即使有恐慌 Println 也会正常执行
		if x := recover(); x != nil {
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
</pre>

<p>
下面例子中的 <code>protect</code> 函数调用函数实参 <code>g</code> 并保护由 <code>g</code>
提升的来自运行时恐慌的调用者。
</p>


<div class="english">
<h3 id="Bootstrapping">Bootstrapping</h3>
</div>

<h3 id="引导">引导</h3>

<div class="english">
<p>
Current implementations provide several built-in functions useful during
bootstrapping. These functions are documented for completeness but are not
guaranteed to stay in the language. They do not return a result.
</p>

<pre class="grammar">
Function   Behavior

print      prints all arguments; formatting of arguments is implementation-specific
println    like print but prints spaces between arguments and a newline at the end
</pre>
</div>

<p>
当前实现提供了几个在引导过程中有用的内建函数。这些函数因完整性而被保留，
但不保证会继续留在该语言中。它们并不返回结果。
</p>

<pre class="grammar">
函数       行为

print      打印所有实参；实参的格式取决于具体实现
println    类似 print，但会在实参之间打印空格并在末尾打印新行
</pre>

<p>
Implementation restriction: <code>print</code> and <code>println</code> need not
accept arbitrary argument types, but printing of boolean, numeric, and string
<a href="#Types">types</a> must be supported.
</p>

<div class="english">
<h2 id="Packages">Packages</h2>
</div>

<h2 id="包">包</h2>

<div class="english">
<p>
Go programs are constructed by linking together <i>packages</i>.
A package in turn is constructed from one or more source files
that together declare constants, types, variables and functions
belonging to the package and which are accessible in all files
of the same package. Those elements may be
<a href="#Exported_identifiers">exported</a> and used in another package.
</p>
</div>

<p>
Go 程序由联系在一起的<b>包</b>构造。包由一个或更多源文件构造转化而来，
源文件与其常量、类型、变量和函数声明一同属于该包，且在相同包的所有文件中它们可互相访问。
这些元素可<a href="#可导出标识符">被导出</a>并用于其它包。
</p>

<div class="english">
<h3 id="Source_file_organization">Source file organization</h3>
</div>

<h3 id="源文件的组织">源文件的组织</h3>

<div class="english">
<p>
Each source file consists of a package clause defining the package
to which it belongs, followed by a possibly empty set of import
declarations that declare packages whose contents it wishes to use,
followed by a possibly empty set of declarations of functions,
types, variables, and constants.
</p>

<pre class="ebnf">
SourceFile       = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
</pre>
</div>

<p>
每个源文件都由这些部分构成：首先是一个定义该源文件所属包的包子句，
然后是一个可能为空的声明所需内容所在包的导入声明的集，最后是一个可能为空的函数、
类型、变量与常量声明的集。
</p>

<pre class="ebnf">
源文件 = 包子句 ";" { 导入声明 ";" } { 顶级声明 ";" } .
</pre>

<div class="english">
<h3 id="Package_clause">Package clause</h3>
</div>

<h3 id="包子句">包子句</h3>

<div class="english">
<p>
A package clause begins each source file and defines the package
to which the file belongs.
</p>

<pre class="ebnf">
PackageClause  = "package" PackageName .
PackageName    = identifier .
</pre>
</div>

<p>
包子句起始于每个源文件并定义该文件所属的包。
</p>

<pre class="ebnf">
包子句  = "package" 包名 .
包名    = 标识符 .
</pre>

<div class="english">
<p>
The PackageName must not be the <a href="#Blank_identifier">blank identifier</a>.
</p>
</div>

<p>
包名不能为<a href="#空白标识符">空白标识符</a>.
</p>

<pre>
package math
</pre>

<div class="english">
<p>
A set of files sharing the same PackageName form the implementation of a package.
An implementation may require that all source files for a package inhabit the same directory.
</p>
</div>

<p>
一个文件集通过共享相同的包名来构成包的实现。实现可能要求包的所有源文件放置在同一目录下。
</p>

<div class="english">
<h3 id="Import_declarations">Import declarations</h3>
</div>

<h3 id="导入声明">导入声明</h3>

<div class="english">
<p>
An import declaration states that the source file containing the declaration
depends on functionality of the <i>imported</i> package
(<a href="#Program_initialization_and_execution">§Program initialization and execution</a>)
and enables access to <a href="#Exported_identifiers">exported</a> identifiers
of that package.
The import names an identifier (PackageName) to be used for access and an ImportPath
that specifies the package to be imported.
</p>

<pre class="ebnf">
ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
ImportSpec       = [ "." | PackageName ] ImportPath .
ImportPath       = string_lit .
</pre>
</div>

<p>
导入声明陈述了源文件中所包含的声明，这取决于<b>已导入</b>包的功能
（§<a href="#程序初始化与执行">程序初始化与执行</a>），
并使其能够访问该包的<a href="#可导出标识符">可导出</a>标识符。
导入通过命名一个标识符（包名）用于访问，而导入路径则指定可导出的包。
</p>

<pre class="ebnf">
导入声明       = "import" ( 导入指定 | "(" { 导入指定 ";" } ")" ) .
导入指定       = [ "." | 包名 ] 导入路径 .
导入路径       = 字符串字面 .
</pre>

<div class="english">
<p>
The PackageName is used in <a href="#Qualified_identifiers">qualified identifiers</a>
to access exported identifiers of the package within the importing source file.
It is declared in the <a href="#Blocks">file block</a>.
If the PackageName is omitted, it defaults to the identifier specified in the
<a href="#Package_clause">package clause</a> of the imported package.
If an explicit period (<code>.</code>) appears instead of a name, all the
package's exported identifiers declared in that package's
<a href="#Blocks">package block</a> will be declared in the importing source
file's file block and must be accessed without a qualifier.
</p>
</div>

<p>
包名作为<a href="#限定标识符">限定标识符</a>来访问导入的源文件中包的可导出标识符。
它在<a href="#块">文件块</a>中声明。若该包名已省略，则默认由已导入包的包子句中的标识符指定。
若出现一个显式的点号（<code>.</code>）来代替名字，
所有在该包的包块中声明的可导出标识符将在导入源文件的文件块中声明，且无需标识符必能访问。
</p>

<div class="english">
<p>
The interpretation of the ImportPath is implementation-dependent but
it is typically a substring of the full file name of the compiled
package and may be relative to a repository of installed packages.
</p>
</div>

<p>
导入路径的解释取决于具体实现，但它是一个典型的已编译包的完整文件名的子串，且可能是相对于一个已安装包的仓库的。
</p>

<div class="english">
<p>
Implementation restriction: A compiler may restrict ImportPaths to
non-empty strings using only characters belonging to
<a href="https://www.unicode.org/versions/Unicode6.3.0/">Unicode's</a>
L, M, N, P, and S general categories (the Graphic characters without
spaces) and may also exclude the characters
<code>!"#$%&amp;'()*,:;&lt;=&gt;?[\]^`{|}</code>
and the Unicode replacement character U+FFFD.
</p>
</div>

<p>
实现限制：编译器会限制导入路径使用只属于<a href="http://www.unicode.org/versions/Unicode6.3.0/">Unicode</a>
中 L、M、N、P 及 S 一般类别（不带空格的图形字符）中的非空字符串，且不含字符
<code>!"#$%&amp;'()*,:;&lt;=&gt;?[\]^`{|}</code> 以及 Unicode 占位字符 U+FFFD。
</p>

<div class="english">
<p>
Assume we have compiled a package containing the package clause
<code>package math</code>, which exports function <code>Sin</code>, and
installed the compiled package in the file identified by
<code>"lib/math"</code>.
This table illustrates how <code>Sin</code> is accessed in files
that import the package after the
various types of import declaration.
</p>

<pre class="grammar">
Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin
</pre>
</div>

<p>
假定我们拥有包含包子句 <code>package math</code> 的已编译包，它导出函数 <code>Sin</code>，
且该包已被安装在标识为<code>"lib/math"</code>的文件中。此表单阐明了在各种类型的导入声明之后，
<code>Sin</code> 在导入该包的文件中如何访问。
</p>

<pre class="grammar">
导入声明                    Sin 的本地名

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin
</pre>

<div class="english">
<p>
An import declaration declares a dependency relation between
the importing and imported package.
It is illegal for a package to import itself, directly or indirectly,
or to directly import a package without
referring to any of its exported identifiers. To import a package solely for
its side-effects (initialization), use the <a href="#Blank_identifier">blank</a>
identifier as explicit package name:
</p>
</div>

<p>
导入声明用来声明导入包与被导入包之间的从属关系。包直接或间接地导入其自身，
或直接导入一个包而不引用其中任何一个已导出标识符是非法的。
要为包的副作用（初始化）而单独导入它，需使用<a href="#空白标识符">空白</a>标识符作为明确的包名：
</p>

<pre>
import _ "lib/math"
</pre>


<div class="english">
<h3 id="An_example_package">An example package</h3>
</div>

<h3 id="一个例子包">一个例子包</h3>

<div class="english">
<p>
Here is a complete Go package that implements a concurrent prime sieve.
</p>

<pre>
package main

import "fmt"

// Send the sequence 2, 3, 4, … to channel 'ch'.
func generate(ch chan&lt;- int) {
	for i := 2; ; i++ {
		ch &lt;- i  // Send 'i' to channel 'ch'.
	}
}

// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
	for i := range src {  // Loop over values received from 'src'.
		if i%prime != 0 {
			dst &lt;- i  // Send 'i' to channel 'dst'.
		}
	}
}

// The prime sieve: Daisy-chain filter processes together.
func sieve() {
	ch := make(chan int)  // Create a new channel.
	go generate(ch)       // Start generate() as a subprocess.
	for {
		prime := &lt;-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}

func main() {
	sieve()
}
</pre>
</div>

<p>
以下为实现了并发质数筛的完整 Go 包。
</p>

<pre>
package main

import "fmt"

// 将序列 2, 3, 4, … 发送至信道'ch'。
func generate(ch chan&lt;- int) {
	for i := 2; ; i++ {
		ch &lt;- i  // 将 'i' 发送至信道'ch'。
	}
}

// 将值从信道'src'中复制至信道'dst'，
// 移除可被'prime'整除的数。
func filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
	for i := range src {  // 循环遍历从'src'接收的值。
		if i%prime != 0 {
			dst &lt;- i  // 将'i'发送至'dst'。
		}
	}
}

// 质数筛：将过滤器串联在一起处理。
func sieve() {
	ch := make(chan int)  // 创建一个新信道。
	go generate(ch)       // 将 generate()作为子进程开始。
	for {
		prime := &lt;-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}

func main() {
	sieve()
}
</pre>

<div class="english">
<h2 id="Program_initialization_and_execution">Program initialization and execution</h2>
</div>

<h2 id="程序初始化与执行">程序初始化与执行</h2>

<div class="english">
<h3 id="The_zero_value">The zero value</h3>
</div>

<h3 id="零值">零值</h3>

<div class="english">
<p>
When storage is allocated for a <a href="#Variables">variable</a>,
either through a declaration or a call of <code>new</code>, or when
a new value is created, either through a composite literal or a call
of <code>make</code>,
and no explicit initialization is provided, the variable or value is
given a default value.  Each element of such a variable or value is
set to the <i>zero value</i> for its type: <code>false</code> for booleans,
<code>0</code> for numeric types, <code>""</code>
for strings, and <code>nil</code> for pointers, functions, interfaces, slices, channels, and maps.
This initialization is done recursively, so for instance each element of an
array of structs will have its fields zeroed if no value is specified.
</p>
</div>

<p>
当为<a href="#变量">变量</a>分配存储时，不是通过声明就是通过 <code>new</code> 调用；
或当创建一个新值时，不是通过复合字面就是通过 <code>make</code> 调用。
而在未提供显式的初始化时，变量或值将被赋予一个默认值。每个这样的变量或值的元素将置为该类型的<b>零值</b>：
布尔类型为 <code>false</code>，整数类型为 <code>0</code>，浮点数类型为 <code>0.0</code>，
字符串类型为 <code>""</code>，而指针、函数、接口、切片、信道及映射类型则为 <code>nil</code>。
该初始化递归地完成，例如，对于结构体的数组的每一个元素，若没有值被指定，则将其拥有的字段归零。
</p>

<div class="english">
<p>
These two simple declarations are equivalent:
</p>
</div>

<p>
以下两个简单声明是等价的：
</p>

<pre>
var i int
var i int = 0
</pre>

<div class="english">
<p>
After
</p>
</div>

<p>
在
</p>

<pre>
type T struct { i int; f float64; next *T }
t := new(T)
</pre>

<div class="english">
<p>
the following holds:
</p>
</div>

<p>
之后，以下表达式成立：
</p>

<pre>
t.i == 0
t.f == 0.0
t.next == nil
</pre>

<div class="english">
<p>
The same would also be true after
</p>
</div>

<p>
同样，在
</p>

<pre>
var t T
</pre>

<p>
之后，上面的表达式仍然为真。
</p>

<div class="english">
<h3 id="Package_initialization">Package initialization</h3>
</div>

<h3 id="包初始化">包初始化</h3>

<div class="english">
<p>
Within a package, package-level variable initialization proceeds stepwise,
with each step selecting the variable earliest in <i>declaration order</i>
which has no dependencies on uninitialized variables.
</p>
</div>

<p>
在包中，包级变量在其<b>依赖</b>的变量初始化后按照<b>声明顺序</b>初始化，
</p>

<div class="english">
<p>
More precisely, a package-level variable is considered <i>ready for
initialization</i> if it is not yet initialized and either has
no <a href="#Variable_declarations">initialization expression</a> or
its initialization expression has no <i>dependencies</i> on uninitialized variables.
Initialization proceeds by repeatedly initializing the next package-level
variable that is earliest in declaration order and ready for initialization,
until there are no variables ready for initialization.
</p>
</div>

<p>
更精确地说，包级变量在它尚未初始化或无<a href="#变量声明">初始化表达式</a>
或其初始化表达式无依赖的未初始化变量时才考虑<b>准备初始化</b>。
初始化过程通过重复地初始化下一个在声明顺序中最早的且准备好初始化的包级变量来进行，
直到不再有准备好初始化的变量为止。
</p>

<div class="english">
<p>
If any variables are still uninitialized when this
process ends, those variables are part of one or more initialization cycles,
and the program is not valid.
</p>
</div>

<p>
若初始化过程结束后仍有未初始化的变量，该变量会变为一个或更多初始化循环的一部分，
该程序即为无效的。
</p>

<div class="english">
<p>
Multiple variables on the left-hand side of a variable declaration initialized
by single (multi-valued) expression on the right-hand side are initialized
together: If any of the variables on the left-hand side is initialized, all
those variables are initialized in the same step.
</p>

<pre>
var x = a
var a, b = f() // a and b are initialized together, before x is initialized
</pre>

<p>
For the purpose of package initialization, <a href="#Blank_identifier">blank</a>
variables are treated like any other variables in declarations.
</p>

<p>
The declaration order of variables declared in multiple files is determined
by the order in which the files are presented to the compiler: Variables
declared in the first file are declared before any of the variables declared
in the second file, and so on.
</p>
</div>

<p>
在多个文件中声明的变量的声明顺序由该文件呈现给编译器的顺序决定：
第一个文件中声明的变量会在第二个文件中声明的任何变量前声明，如此继续。
</p>

<div class="english">
<p>
Dependency analysis does not rely on the actual values of the
variables, only on lexical <i>references</i> to them in the source,
analyzed transitively. For instance, if a variable <code>x</code>'s
initialization expression refers to a function whose body refers to
variable <code>y</code> then <code>x</code> depends on <code>y</code>.
Specifically:
</p>
</div>

<p>
依赖分析不会依赖于变量的实际值，只会根据源码中对它们的<b>引用</b>传递性地分析。
例如，若变量 <code>x</code> 的初始化表达式引用了一个函数，其函数体又引用了变量
<code>y</code>，那么 <code>x</code> 依赖于 <code>y</code>。特别地：
</p>

<div class="english">
<ul>
<li>
A reference to a variable or function is an identifier denoting that
variable or function.
</li>

<li>
A reference to a method <code>m</code> is a
<a href="#Method_values">method value</a> or
<a href="#Method_expressions">method expression</a> of the form
<code>t.m</code>, where the (static) type of <code>t</code> is
not an interface type, and the method <code>m</code> is in the
<a href="#Method_sets">method set</a> of <code>t</code>.
It is immaterial whether the resulting function value
<code>t.m</code> is invoked.
</li>

<li>
A variable, function, or method <code>x</code> depends on a variable
<code>y</code> if <code>x</code>'s initialization expression or body
(for functions and methods) contains a reference to <code>y</code>
or to a function or method that depends on <code>y</code>.
</li>
</ul>
</div>

<ul>
<li>
对变量或函数的引用为表示该变量或函数的标识符。
</li>

<li>
对方法 <code>m</code> 的引用为形式为 <code>t.m</code>
的<a href="#方法值">方法值</a>或<a href="#方法表达式">方法表达式</a>，
其中 <code>t</code> 的（静态）类型不为接口类型，且方法 <code>m</code>
在 <code>t</code> 的<a href="#方法集">方法集</a>中。
<code>t.m</code> 被调用后的结果函数值并不重要。
</li>

<li>
若变量、函数或方法 <code>x</code> 的初始化表达式或主体（函数体或方法体）
包含一个对 <code>y</code> 的引用或依赖于 <code>y</code> 的函数或方法，
那么 <code>x</code> 即依赖 <code>y</code>。
</li>
</ul>

<div class="english">
<p>
Dependency analysis is performed per package; only references referring
to variables, functions, and methods declared in the current package
are considered.
</p>
</div>

<p>
依赖分析会为每个包执行，只有引用了在当前包中声明的变量、函数或方法引用才会被考虑。
</p>

<div class="english">
<p>
For example, given the declarations
</p>
</div>

<p>
例如，给定声明
</p>

<pre>
var (
	a = c + b  // == 9
	b = f()    // == 4
	c = f()    // == 5
	d = 3      // == 5 after initialization has finished
)

func f() int {
	d++
	return d
}
</pre>

<div class="english">
<p>
the initialization order is <code>d</code>, <code>b</code>, <code>c</code>, <code>a</code>.
Note that the order of subexpressions in initialization expressions is irrelevant:
<code>a = c + b</code> and <code>a = b + c</code> result in the same initialization
order in this example.
</p>

<p>
Dependency analysis is performed per package; only references referring
to variables, functions, and (non-interface) methods declared in the current
package are considered. If other, hidden, data dependencies exists between
variables, the initialization order between those variables is unspecified.
</p>

<p>
For instance, given the declarations
</p>

<pre>
var x = I(T{}).ab()   // x has an undetected, hidden dependency on a and b
var _ = sideEffect()  // unrelated to x, a, or b
var a = b
var b = 42

type I interface      { ab() []int }
type T struct{}
func (T) ab() []int   { return []int{a, b} }
</pre>

<p>
the variable <code>a</code> will be initialized after <code>b</code> but
whether <code>x</code> is initialized before <code>b</code>, between
<code>b</code> and <code>a</code>, or after <code>a</code>, and
thus also the moment at which <code>sideEffect()</code> is called (before
or after <code>x</code> is initialized) is not specified.
</p>
</div>

<p>
那么初始化顺序为 <code>d</code>、<code>b</code>、<code>c</code>、<code>a</code>。
</p>

<div class="english">
<p>
Variables may also be initialized using functions named <code>init</code>
declared in the package block, with no arguments and no result parameters.
</p>
</div>

<p>
变量也可使用包块中声明的名为 <code>init</code> 的函数初始化，该函数无实参和结果形参。
</p>

<pre>
func init() { … }
</pre>

<div class="english">
<p>
Multiple such functions may be defined per package, even within a single
source file. In the package block, the <code>init</code> identifier can
be used only to declare <code>init</code> functions, yet the identifier
itself is not <a href="#Declarations_and_scope">declared</a>. Thus
<code>init</code> functions cannot be referred to from anywhere
in a program.
</p>
</div>

<p>
这样的函数在每个包中都可定义多个，甚至在单个源文件内。在包块中，<code>init</code>
仅能用于声明 <code>init</code> 方法，而标识符本身并非<a href="#声明与作用域">声明</a>，
因此 <code>init</code> 函数并不能在程序中的任何地方引用。
</p>

<div class="english">
<p>
A package with no imports is initialized by assigning initial values
to all its package-level variables followed by calling all <code>init</code>
functions in the order they appear in the source, possibly in multiple files,
as presented to the compiler.
If a package has imports, the imported packages are initialized
before initializing the package itself. If multiple packages import
a package, the imported package will be initialized only once.
The importing of packages, by construction, guarantees that there
can be no cyclic initialization dependencies.
</p>
</div>

<p>
无导入的包在初始化时，会在为所有包级变量赋予初始值后，
按照将包内的多个源码文件呈现给编译器的顺序依次调用其中所有的 <code>init</code> 函数。
若包中存在导入，被导入的包会先于该包初始化。若有多个包导入了一个包，被导入的包只会初始化一次。
根据构造导入的包可保证在初始化中没有循环依赖。
</p>

<div class="english">
<p>
Package initialization&mdash;variable initialization and the invocation of
<code>init</code> functions&mdash;happens in a single goroutine,
sequentially, one package at a time.
An <code>init</code> function may launch other goroutines, which can run
concurrently with the initialization code. However, initialization
always sequences
the <code>init</code> functions: it will not invoke the next one
until the previous one has returned.
</p>
</div>

<p>
包初始化 &mdash;变量初始化与 <code>init</code> 函数的调用 &mdash;连续地发生在单一的 Go 程中，一次一包。
一个 <code>init</code> 函数可能在其它 Go 程中启动，它可以与初始化代码一同运行。然而，初始化总是按顺序执行
<code>init</code> 函数：直到上一个返回后，它才会调用下一个。
</p>

<div class="english">
<p>
To ensure reproducible initialization behavior, build systems are encouraged
to present multiple files belonging to the same package in lexical file name
order to a compiler.
</p>
</div>

<p>
为确保可重现的初始化行为，规范鼓励构建系统将属于同一包中的多个文件按词法文件名顺序呈现给编译器。
</p>


<div class="english">
<h3 id="Program_execution">Program execution</h3>
</div>

<h3 id="程序执行">程序执行</h3>

<div class="english">
<p>
A complete program is created by linking a single, unimported package
called the <i>main package</i> with all the packages it imports, transitively.
The main package must
have package name <code>main</code> and
declare a function <code>main</code> that takes no
arguments and returns no value.
</p>
</div>

<p>
一个完整的程序通过链接一个单一的、不会被导入的、称为 <b>主包</b> 的，带所有其传递地导入包的包创建。
主包必须拥有包名 <code>main</code> 且声明一个无实参无返回值的函数 <code>main</code>。
</p>

<pre>
func main() { … }
</pre>

<div class="english">
<p>
Program execution begins by initializing the main package and then
invoking the function <code>main</code>.
When that function invocation returns, the program exits.
It does not wait for other (non-<code>main</code>) goroutines to complete.
</p>
</div>

<p>
程序通过初始化主包然后调用函数 <code>main</code> 开始执行。当该函数调用返回后，
程序退出。它不会等待其它（非 <code>main</code>）Go 程完成。
</p>


<div class="english">
<h2 id="Errors">Errors</h2>
</div>

<h2 id="错误">错误</h2>

<div class="english">
<p>
The predeclared type <code>error</code> is defined as
</p>
</div>

<p>
预声明类型 <code>error</code> 定义为
</p>

<pre>
type error interface {
	Error() string
}
</pre>

<div class="english">
<p>
It is the conventional interface for representing an error condition,
with the nil value representing no error.
For instance, a function to read data from a file might be defined:
</p>
</div>

<p>
它是表示一种错误状态的传统接口，用 <code>nil</code> 值表示没有错误。
例如，一个从文件中读取数据的函数可被定义为：
</p>

<pre>
func Read(f *File, b []byte) (n int, err error)
</pre>

<div class="english">
<h2 id="Run_time_panics">Run-time panics</h2>
</div>

<h2 id="运行时恐慌">运行时恐慌</h2>

<div class="english">
<p>
Execution errors such as attempting to index an array out
of bounds trigger a <i>run-time panic</i> equivalent to a call of
the built-in function <a href="#Handling_panics"><code>panic</code></a>
with a value of the implementation-defined interface type <code>runtime.Error</code>.
That type satisfies the predeclared interface type
<a href="#Errors"><code>error</code></a>.
The exact error values that
represent distinct run-time error conditions are unspecified.
</p>

<pre>
package runtime

type Error interface {
	error
	// and perhaps other methods
}
</pre>
</div>

<p>
例如试图索引一个越界的数组这类的执行错误会引发<b>运行时恐慌</b>，它等价于
一个定义实现了接口类型 <code>runtime.Error</code> 的值的内建函数
<a href="#恐慌处理"><code>panic</code></a> 的调用。该类型满足预声明接口类型
<a href="#错误"><code>error</code></a>。表示明显的运行时错误状态的准确错误值是不确定的。
</p>

<pre>
package runtime

type Error interface {
	error
	// 可能还有其它方法
}
</pre>

<div class="english">
<h2 id="System_considerations">System considerations</h2>
</div>

<h2 id="系统考虑">系统考虑</h2>

<div class="english">
<h3 id="Package_unsafe">Package <code>unsafe</code></h3>
</div>

<h3 id="包 unsafe">包 <code>unsafe</code> </h3>

<div class="english">
<p>
The built-in package <code>unsafe</code>, known to the compiler
and accessible through the <a href="#Import_declarations">import path</a> <code>"unsafe"</code>,
provides facilities for low-level programming including operations
that violate the type system. A package using <code>unsafe</code>
must be vetted manually for type safety and may not be portable.
The package provides the following interface:
</p>

<pre class="grammar">
package unsafe

type ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uintptr
func Sizeof(variable ArbitraryType) uintptr
</pre>
</div>

<p>
编译器已知的内建包 <code>unsafe</code> 为包括违反类型系统操作在内的低级编程提供工具。使用
<code>unsafe</code> 的包为了类型安全必须手动进行审查且可能无法移植。该包提供以下接口：
</p>

<pre class="grammar">
package unsafe

type ArbitraryType int  // 任意 Go 类型的简写，它并非真正的类型
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uintptr
func Sizeof(variable ArbitraryType) uintptr
</pre>

<div class="english">
<p>
A <code>Pointer</code> is a <a href="#Pointer_types">pointer type</a> but a <code>Pointer</code>
value may not be <a href="#Address_operators">dereferenced</a>.
Any pointer or value of <a href="#Types">underlying type</a> <code>uintptr</code> can be converted to
a type of underlying type <code>Pointer</code> and vice versa.
The effect of converting between <code>Pointer</code> and <code>uintptr</code> is implementation-defined.
</p>
</div>

<p>
<code>Pointer</code> 为<a href="#指针类型">指针类型</a>但 <code>Pointer</code>
值可能并未<a href="#地址操作符">解引用</a>。
任何<a href="#类型">基本类型</a>为 <code>uintptr</code> 的指针或值均可转换为底层类型 <code>Pointer</code>，反之亦然。
<code>Pointer</code> 和 <code>uintptr</code> 的转换效果由实现定义。
</p>

<pre>
var f float64
bits = *(*uint64)(unsafe.Pointer(&amp;f))

type ptr unsafe.Pointer
bits = *(*uint64)(ptr(&amp;f))

var p ptr = nil
</pre>

<div class="english">
<p>
The functions <code>Alignof</code> and <code>Sizeof</code> take an expression <code>x</code>
of any type and return the alignment or size, respectively, of a hypothetical variable <code>v</code>
as if <code>v</code> was declared via <code>var v = x</code>.
</p>
</div>

<p>
函数 <code>Alignof</code> 与 <code>Sizeof</code> 接受一个任何类型的表达式 <code>x</code>，
就好像通过 <code>var v = x</code> 声明的变量 <code>v</code> 一样，分别返回其对齐或大小。
</p>

<div class="english">
<p>
The function <code>Offsetof</code> takes a (possibly parenthesized) <a href="#Selectors">selector</a>
<code>s.f</code>, denoting a field <code>f</code> of the struct denoted by <code>s</code>
or <code>*s</code>, and returns the field offset in bytes relative to the struct's address.
If <code>f</code> is an <a href="#Struct_types">embedded field</a>, it must be reachable
without pointer indirections through fields of the struct.
For a struct <code>s</code> with field <code>f</code>:
</p>
</div>

<p>
函数 <code>Offsetof</code> 接受一个（可能带括号的）<a href="#选择器">选择器</a>
<code>s.f</code>，它表示一个由 <code>s</code> 或 <code>*s</code> 表示的结构体的字段 <code>f</code>，
并返回该字段相对于该结构体地址偏移的字节。若 <code>f</code> 是一个<a href="#结构体类型">内嵌字段</a>，
它必须能通过（无指针间接引用的）结构体字段获取。
对于带字段 <code>f</code> 的结构体 <code>s</code> ：
</p>

<pre>
uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&amp;s.f))
</pre>

<div class="english">
<p>
Computer architectures may require memory addresses to be <i>aligned</i>;
that is, for addresses of a variable to be a multiple of a factor,
the variable's type's <i>alignment</i>.  The function <code>Alignof</code>
takes an expression denoting a variable of any type and returns the
alignment of the (type of the) variable in bytes.  For a variable
<code>x</code>:
</p>
</div>

<p>
计算机架构可能需要内存地址 <b>对齐</b>，即，为使变量的地址为因数的倍数，该变量的类型需要对齐。函数
<code>Alignof</code> 接受一个表示任何类型变量的表达式并返回该（类型的）变量对齐的字节。对于变量 <code>x</code>：
</p>

<pre>
uintptr(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == 0
</pre>

<div class="english">
<p>
Calls to <code>Alignof</code>, <code>Offsetof</code>, and
<code>Sizeof</code> are compile-time constant expressions of type <code>uintptr</code>.
</p>
</div>

<p>
调用 <code>Alignof</code>、<code>Offsetof</code> 和 <code>Sizeof</code> 是类型为
<code>uintptr</code> 的编译时常量表达式。
</p>


<div class="english">
<h3 id="Size_and_alignment_guarantees">Size and alignment guarantees</h3>
</div>

<h3 id="大小与对齐保证">大小与对齐保证</h3>

<div class="english">
<p>
For the <a href="#Numeric_types">numeric types</a>, the following sizes are guaranteed:
</p>

<pre class="grammar">
type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16
</pre>
</div>

<p>
对于<a href="#数值类型">数值类型</a>，以下大小给予保证：
</p>

<pre class="grammar">
类型                               字节大小

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16
</pre>

<div class="english">
<p>
The following minimal alignment properties are guaranteed:
</p>
<ol>
<li>For a variable <code>x</code> of any type: <code>unsafe.Alignof(x)</code> is at least 1.
</li>

<li>For a variable <code>x</code> of struct type: <code>unsafe.Alignof(x)</code> is the largest of
    all the values <code>unsafe.Alignof(x.f)</code> for each field <code>f</code> of <code>x</code>, but at least 1.
</li>

<li>For a variable <code>x</code> of array type: <code>unsafe.Alignof(x)</code> is the same as
	the alignment of a variable of the array's element type.
</li>
</ol>
</div>

<p>
以下最小对齐属性给予保证：
</p>
<ol>
<li>对于任何类型的变量 <code>x</code>：<code>unsafe.Alignof(x)</code> 至少为 1。
</li>

<li>对于结构体类型的变量 <code>x</code>：对于 <code>x</code> 的每一个字段 <code>f</code>，
   <code>unsafe.Alignof(x)</code> 的值为所有 <code>unsafe.Alignof(x.f)</code> 值中最大的，但至少为 1。
</li>

<li>对于数组类型的变量 <code>x</code>：<code>unsafe.Alignof(x)</code> 与
   <code>unsafe.Alignof(x[0])</code> 相同，但至少为 1。
</li>
</ol>

<div class="english">
<p>
A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.
</p>
</div>

<p>
若结构体或数组类型不包含大小大于零的字段或元素，它们的大小即为零。两个不同的零大小变量在内存中可能有相同的地址。
</p>
